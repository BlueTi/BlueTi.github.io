---
emoji: 🧢
title: RGB거리
date: '2021-03-05T01:15:37.121Z'
categories: 알고리즘
author: Jard
description: '백준 1149번 문제'
---

[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1149)

<div style="text-align:center"><a href="https://www.acmicpc.net/problem/1149">https://www.acmicpc.net/problem/1149</a></div>

---

> i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.

- 이 문장을 읽으면 순간 복잡하게 생각이 들었지만 따지고 보면 그냥 앞집의 색과 다르면 그만이다
- 도색에 드는 비용이 들어있는 배열(ar) | 여태까지 겹치지 않고 최소값으로 도배를 해온 비용으로 나누어 배열(dp)을 만들어 채운다.
- 최소도색비용 배열(dp)을 채울때 위에서 색을 정하고(dp[i-1][0])
- 이전 줄(dp[i-1])의 겹치지 않는 색의 최소도배비용을 비교하여 더 작은값(dp[i-1][1] < dp[i-1][2]?)과 현재 집에 선택한 색의 도색비용을 더해준다(+ar[i][0]).

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

/**
 * RGB거리 문제 해결
 * 인접한 집은 같은 색으로 칠할 수 없을 때, 모든 집을 칠하는 최소 비용을 구하는 문제
 * 다이나믹 프로그래밍을 사용하여 각 집을 각 색으로 칠할 때의 최소 비용을 계산
 */
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(reader.readLine()); // 집의 개수
        int[][] ar = new int[n][3], dp = new int[n][3]; // ar: 각 집의 RGB 비용, dp: 최소 비용

        // 각 집의 RGB 비용 입력
        for (int i = 0; i < n; i++) {
            ar[i] = Arrays.stream(reader.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
        }

        // 첫 번째 집은 그대로 초기화
        dp[0] = ar[0];
        
        // 두 번째 집부터: 이전 집과 다른 색을 선택하여 최소 비용 계산
        for (int i = 1; i < n; i++) {
            // i번째 집을 빨강(0)으로 칠할 때: 이전 집은 초록 또는 파랑 중 최소 비용 선택
            dp[i][0] = (dp[i - 1][1] < dp[i - 1][2] ? dp[i - 1][1] : dp[i - 1][2]) + ar[i][0];
            // i번째 집을 초록(1)으로 칠할 때: 이전 집은 빨강 또는 파랑 중 최소 비용 선택
            dp[i][1] = (dp[i - 1][0] < dp[i - 1][2] ? dp[i - 1][0] : dp[i - 1][2]) + ar[i][1];
            // i번째 집을 파랑(2)으로 칠할 때: 이전 집은 빨강 또는 초록 중 최소 비용 선택
            dp[i][2] = (dp[i - 1][0] < dp[i - 1][1] ? dp[i - 1][0] : dp[i - 1][1]) + ar[i][2];
        }

        // 마지막 집의 세 가지 색 중 최소 비용 선택
        int min = dp[n - 1][0] < dp[n - 1][1] ? dp[n - 1][0] : dp[n - 1][1];
        System.out.println(min < dp[n - 1][2] ? min : dp[n - 1][2]);
    }
}

```
