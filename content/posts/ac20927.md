---
emoji: ğŸ§¢
title: 'Degree Bounded Minimum Spanning Tree'
date: '2021-04-21T10:10:37.121Z'
categories: ì•Œê³ ë¦¬ì¦˜
author: Jard
description: 'ë°±ì¤€ 20927ë²ˆ ë¬¸ì œ'
---

[![ë°±ì¤€](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/20927)

<div style="text-align:center"><a href="https://www.acmicpc.net/problem/20927">https://www.acmicpc.net/problem/20927</a></div>

---

- ë¬¸ì œì—ì„œ ìŠ¤íŒ¨ë‹íŠ¸ë¦¬ë§Œ ì½ê³  ìµœì†Œ ìŠ¤íŒ¨ë‹íŠ¸ë¦¬ë¡œ í•˜ë©´ ë‹µì´ ì—†ë‹¤.
- ë¸Œë£¨íŠ¸í¬ìŠ¤ë¡œ ì ‘ê·¼í•´ì•¼í•œë‹¤.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

/**
 * Degree Bounded Minimum Spanning Tree ë¬¸ì œ í•´ê²°
 * ê° ì •ì ì˜ ì°¨ìˆ˜ ì œí•œì„ ë§Œì¡±í•˜ëŠ” ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ë¥¼ ì°¾ëŠ” ë¬¸ì œ
 * ë°±íŠ¸ë˜í‚¹ì„ ì‚¬ìš©í•˜ì—¬ ëª¨ë“  ê°€ëŠ¥í•œ ê°„ì„  ì¡°í•©ì„ íƒìƒ‰
 */

/**
 * ê°„ì„ ì„ ë‚˜íƒ€ë‚´ëŠ” í´ë˜ìŠ¤
 * ì‹œì‘ì , ëì , ë¹„ìš©ì„ ì €ì¥í•˜ê³  ë¹„ìš© ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬ ê°€ëŠ¥
 */
class Node implements Comparable<Node>{
    int start,end,cost;
    public Node(int start,int end,int cost){
        // ì‹œì‘ì ê³¼ ëì ì„ ì‘ì€ ê°’ì´ start, í° ê°’ì´ endê°€ ë˜ë„ë¡ ì •ë ¬
        this.start = (start<end?start:end);
        this.end = (start<end?end:end);
        this.cost = cost;
    }
    @Override
    public int compareTo(Node o) {
        // ë¹„ìš© ê¸°ì¤€ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
        return this.cost - o.cost;
    }
}

public class Main {
    static BufferedReader br;
    static BufferedWriter bw;
    static StringBuilder sb;
    // ar: Union-Findë¥¼ ìœ„í•œ ë¶€ëª¨ ë°°ì—´
    // limit: ê° ì •ì ì˜ ì°¨ìˆ˜ ì œí•œ
    // degree: ê° ì •ì ì˜ í˜„ì¬ ì°¨ìˆ˜
    // check: ë°±íŠ¸ë˜í‚¹ì—ì„œ ê°„ì„  ì„ íƒ ì—¬ë¶€ë¥¼ ì²´í¬í•˜ëŠ” ë°°ì—´
    static int[] ar,limit,degree,check;
    static int n,m,sum=Integer.MAX_VALUE; // n: ì •ì  ìˆ˜, m: ê°„ì„  ìˆ˜, sum: ìµœì†Œ ë¹„ìš©
    static Queue<Node> nodes = new LinkedList<Node>(); // ìµœì¢… ì„ íƒëœ ê°„ì„ ë“¤ì„ ì €ì¥
    static ArrayList<Node> edges = new ArrayList<Node>(); // ëª¨ë“  ê°„ì„  ì •ë³´
    
    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));
        sb = new StringBuilder();
        StringTokenizer st = new StringTokenizer(br.readLine());
        n  = Integer.parseInt(st.nextToken()); // ì •ì ì˜ ê°œìˆ˜
        m = Integer.parseInt(st.nextToken()); // ê°„ì„ ì˜ ê°œìˆ˜
        limit = new int[n+1]; // ê° ì •ì ì˜ ì°¨ìˆ˜ ì œí•œ
        check = new int[m+1]; // ê°„ì„  ì„ íƒ ì—¬ë¶€ ì²´í¬ ë°°ì—´
        
        // ê° ì •ì ì˜ ì°¨ìˆ˜ ì œí•œ ì…ë ¥
        st = new StringTokenizer(br.readLine());
        for(int i=1;i<=n;i++){
            limit[i] = Integer.parseInt(st.nextToken());
        }
        
        // ê°„ì„  ì •ë³´ ì…ë ¥ (ì‹œì‘ì , ëì , ë¹„ìš©)
        for(int i=0;i<m;i++){
            st = new StringTokenizer(br.readLine());
            edges.add(new Node(Integer.parseInt(st.nextToken()),Integer.parseInt(st.nextToken()),Integer.parseInt(st.nextToken())));
        }
        
        // ê°„ì„ ì„ ë¹„ìš© ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬ (ë°±íŠ¸ë˜í‚¹ íš¨ìœ¨ì„±ì„ ìœ„í•´)
        Collections.sort(edges);
        
        // ë°±íŠ¸ë˜í‚¹ ì‹œì‘: n-1ê°œì˜ ê°„ì„ ì„ ì„ íƒí•˜ì—¬ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ êµ¬ì„±
        backtrack(0,0);

        // ê²°ê³¼ ì¶œë ¥
        // ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ë¥¼ ì°¾ì§€ ëª»í•œ ê²½ìš°
        if(nodes.isEmpty()){
            // ì •ì ì´ 1ê°œì¸ ê²½ìš°ëŠ” í•­ìƒ ê°€ëŠ¥, ê·¸ ì™¸ëŠ” ë¶ˆê°€ëŠ¥
            sb.append(n==1?"YES":"NO");
        }
        else{
            // ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ë¥¼ ì°¾ì€ ê²½ìš° YESì™€ ì„ íƒëœ ê°„ì„ ë“¤ ì¶œë ¥
            sb.append("YES\n");
            while(!nodes.isEmpty()){
                Node node = nodes.poll();
                sb.append(node.start+" "+node.end+(nodes.isEmpty()?"":"\n"));
            }
        }
        bw.write(sb.toString());
        bw.flush();
        bw.close();
    }
    
    /**
     * ë°±íŠ¸ë˜í‚¹ì„ ì‚¬ìš©í•˜ì—¬ n-1ê°œì˜ ê°„ì„ ì„ ì„ íƒ
     * @param index: í˜„ì¬ ê³ ë ¤í•  ê°„ì„ ì˜ ì¸ë±ìŠ¤
     * @param cnt: í˜„ì¬ê¹Œì§€ ì„ íƒí•œ ê°„ì„ ì˜ ê°œìˆ˜
     */
    private static void backtrack(int index, int cnt) {
        // n-1ê°œì˜ ê°„ì„ ì„ ì„ íƒí–ˆìœ¼ë©´ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ì¸ì§€ í™•ì¸
        if(cnt==n-1){
            boolean flag = true;
            int tsum = 0; // í˜„ì¬ ì„ íƒí•œ ê°„ì„ ë“¤ì˜ ì´ ë¹„ìš©
            
            // Union-Find ì´ˆê¸°í™”
            ar = new int[n+1];
            Arrays.fill(ar,-1); // -1ì€ ë£¨íŠ¸ ë…¸ë“œë¥¼ ì˜ë¯¸
            degree = new int[n+1]; // ê° ì •ì ì˜ ì°¨ìˆ˜ ì´ˆê¸°í™”
            Queue<Node> temp = new LinkedList<Node>(); // í˜„ì¬ ì„ íƒí•œ ê°„ì„ ë“¤ ì„ì‹œ ì €ì¥

            // ì„ íƒëœ ê°„ì„ ë“¤ì„ ì‚¬ìš©í•˜ì—¬ Union-Find ìˆ˜í–‰
            for(int i=0;i<m;i++){
                if(check[i]==0)continue; // ì„ íƒë˜ì§€ ì•Šì€ ê°„ì„ ì€ ê±´ë„ˆëœ€
                Node node = edges.get(i);
                // ë‘ ì •ì ì´ ë‹¤ë¥¸ ì§‘í•©ì— ì†í•´ìˆìœ¼ë©´ (ì‚¬ì´í´ì´ ì—†ìœ¼ë©´)
                if(find(node.start)!=find(node.end)){
                    union(node.start, node.end); // ë‘ ì§‘í•©ì„ í•©ì¹¨
                    degree[node.start]++; // ë‘ ì •ì ì˜ ì°¨ìˆ˜ ì¦ê°€
                    degree[node.end]++;
                    temp.add(node); // ì„ íƒëœ ê°„ì„  ì €ì¥
                    tsum+=node.cost; // ë¹„ìš© ëˆ„ì 
                }
            }

            // ëª¨ë“  ì •ì ì´ ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸ (ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ ì¡°ê±´)
            // ê·¸ë¦¬ê³  ê° ì •ì ì˜ ì°¨ìˆ˜ê°€ ì œí•œì„ ë„˜ì§€ ì•ŠëŠ”ì§€ í™•ì¸
            for(int i=1;i<=n;i++){
                // ì´ì „ ì •ì ê³¼ ì—°ê²°ë˜ì–´ ìˆì§€ ì•Šê±°ë‚˜, ì°¨ìˆ˜ê°€ ì œí•œì„ ì´ˆê³¼í•˜ë©´ ì‹¤íŒ¨
                if((i>1&&find(i-1)!=find(i))||(degree[i]>limit[i])){
                    flag=false;
                    break;
                }
            }

            // ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ë¥¼ ì°¾ì•˜ê³ , ë¹„ìš©ì´ ë” ì‘ìœ¼ë©´ ì—…ë°ì´íŠ¸
            if(flag){
                if(sum>tsum){
                    sum=tsum;
                    nodes=new LinkedList<>(temp);
                }
            }

            return;
        }

        // ë°±íŠ¸ë˜í‚¹: ê°„ì„ ì„ ì„ íƒí•˜ê±°ë‚˜ ì„ íƒí•˜ì§€ ì•ŠìŒ
        for(int i=index;i<m;i++){
            if(check[i]==1)continue; // ì´ë¯¸ ì„ íƒëœ ê°„ì„ ì€ ê±´ë„ˆëœ€
            check[i]=1; // ê°„ì„  ì„ íƒ
            backtrack(i+1, cnt+1); // ë‹¤ìŒ ê°„ì„ ìœ¼ë¡œ ì¬ê·€
            check[i]=0; // ë°±íŠ¸ë˜í‚¹: ì„ íƒ ì·¨ì†Œ
        }
    }
    /**
     * Union-Find: ë‘ ì§‘í•©ì„ í•©ì¹˜ëŠ” í•¨ìˆ˜
     * @param start: ì²« ë²ˆì§¸ ì •ì 
     * @param end: ë‘ ë²ˆì§¸ ì •ì 
     */
    private static void union(int start, int end) {
        int pa = find(start),pb=find(end); // ê° ì •ì ì˜ ë£¨íŠ¸ ì°¾ê¸°
        if(pa==pb)return; // ì´ë¯¸ ê°™ì€ ì§‘í•©ì— ì†í•´ìˆìœ¼ë©´ ì¢…ë£Œ
        // pbì˜ ë¶€ëª¨ë¥¼ paë¡œ ì„¤ì •í•˜ì—¬ ë‘ ì§‘í•©ì„ í•©ì¹¨
        // ar[pa]+=ar[pb]; // ì£¼ì„ ì²˜ë¦¬ëœ ë¶€ë¶„ì€ ë­í¬ ê¸°ë°˜ ìµœì í™”
        ar[pb]=pa;
        return;
    }
    
    /**
     * Union-Find: ì •ì ì˜ ë£¨íŠ¸ë¥¼ ì°¾ëŠ” í•¨ìˆ˜ (ê²½ë¡œ ì••ì¶• ì ìš©)
     * @param index: ì°¾ì„ ì •ì 
     * @return: ì •ì ì´ ì†í•œ ì§‘í•©ì˜ ë£¨íŠ¸
     */
    private static int find(int index) {
        // ar[index] < 0ì´ë©´ ë£¨íŠ¸ ë…¸ë“œ
        if(ar[index]<0)return index;
        // ê²½ë¡œ ì••ì¶•: ë¶€ëª¨ë¥¼ ë£¨íŠ¸ë¡œ ì§ì ‘ ì—°ê²°í•˜ì—¬ ë‹¤ìŒ ì¡°íšŒ ì‹œ ì†ë„ í–¥ìƒ
        return ar[index] = find(ar[index]);
    }
}



```
