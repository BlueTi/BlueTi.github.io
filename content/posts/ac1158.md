---
emoji: 🧢
title: '요세푸스 문제'
date: '2019-05-31T15:23:37.121Z'
categories: 알고리즘
author: Jard
description: '백준 1158번 큐 문제'
---

[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1158)

<div style="text-align:center"><a href="https://www.acmicpc.net/problem/1158">https://www.acmicpc.net/problem/1158</a></div>

---

- prev와 next란 배열을 서로 인덱스로 교차하며 배열을 출력한다.

- n이 7이고 m이 3일 경우 처음 모양은 이러하다.

|      |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |
| :--: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| prev | -1  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |
| next |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |

- prev의 1번째에는 n을 넣고 next의 n번째에는 1을 넣는다.

|      |  0  |    1     |  2  |  3  |  4  |  5  |  6  |    7     |
| :--: | :-: | :------: | :-: | :-: | :-: | :-: | :-: | :------: |
| prev | -1  | <b>7</b> |  1  |  2  |  3  |  4  |  5  |    6     |
| next |  1  |    2     |  3  |  4  |  5  |  6  |  7  | <b>1</b> |

<br />

- i에 next[i]를 넣으면서 탐색을 나가는데 0부터 시작하여 m번 반복한다.<br />
  i = (next[0] => next[1] => next[2]) =>3<br />
  i = 3<br />

- i 값을 출력해주고 next에 이전 값이 담긴 자리에 다음 위치의 값을 넣는다.<br />
  next[prev[i]] = next[i];<br />
  next[prev[3]] = next[3];<br />
  next[2] = next[3];<br />

|      |  0  |  1  |    2    |  3  |  4  |  5  |  6  |  7  |
| :--: | :-: | :-: | :-----: | :-: | :-: | :-: | :-: | :-: |
| prev | -1  |  7  |    1    |  2  |  3  |  4  |  5  |  6  |
| next |  1  |  2  | <b>4</b> |  4  |  5  |  6  |  7  |  1  |

<br />

- 그리고 prev 배열에는 출력된 값의 자리에 그 이전 값을 넣는다.<br />
  prev[next[i]] = prev[i];<br />
  prev[next[3]] = prev[3];<br />
  prev[4] = prev[3];<br />

|      |  0  |  1  |  2  |  3  |    4     |  5  |  6  |  7  |
| :--: | :-: | :-: | :-: | :-: | :------: | :-: | :-: | :-: |
| prev | -1  |  7  |  1  |  2  | <b>2</b> |  4  |  5  |  6  |
| next |  1  |  2  |  4  |  4  |    5     |  6  |  7  |  1  |

<br />

- 위 과정을 반복한다.

- 2년전에 푼 문제인데 내가 풀었다기엔 어떻게 이렇게 푼건지 모르겠고 어디서 봤다기엔 검색을 해도 안나오고 한번에 맞췄다.

---

```C
#include <stdio.h>

/**
 * 요세푸스 문제 해결
 * 원형 연결 리스트를 배열로 구현하여 K번째 사람을 제거하는 문제
 * prev와 next 배열을 사용하여 원형 구조를 표현
 */
int main() {
    int n, m, i, j; // n: 사람 수, m: 제거할 간격, i: 현재 위치, j: 반복 변수

    scanf("%d %d", &n, &m);
	int prev[n+1], next[n+1]; // prev: 이전 노드, next: 다음 노드

    // 원형 연결 리스트 초기화
    for (i = 0; i <= n;++i) {
        prev[i] = i - 1;
        next[i] = i + 1;
    }
    // 원형 구조 만들기: 첫 번째와 마지막 연결
    prev[1] = n;
    next[n] = 1;

    printf("<");
    i = 0; // 시작 위치
    for (;--n;) { // n-1번 반복 (마지막 하나 남을 때까지)
        // m번째 사람까지 이동
        for (j = 0;j < m;++j)
            i = next[i];
        printf("%d, ", i);
        // i번째 노드를 리스트에서 제거
        next[prev[i]] = next[i]; // 이전 노드의 next를 다음 노드로 연결
        prev[next[i]] = prev[i]; // 다음 노드의 prev를 이전 노드로 연결
    }
    printf("%d>", next[i]); // 마지막 남은 사람 출력

    return 0;
}
```
