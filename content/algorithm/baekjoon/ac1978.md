---
emoji: 🧢
title: 소수 찾기
date: '2021-04-10T20:17:37.121Z'
categories: 알고리즘
author: Jard
description: '백준 1978번 정수론 문제'
---

[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1978)

<div style="text-align:center"><a href="https://www.acmicpc.net/problem/1978">https://www.acmicpc.net/problem/1978</a></div>

---

- 1과 자기 자신 외에 나눠지지 않는 소수를 찾는 문제이다.
- 처음 생각한 코드는 2부터 주어진 수의 제곱근까지 반복시켜 소수를 판별했다.

---

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine()), count = 0;
        StringTokenizer st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            int num = Integer.parseInt(st.nextToken());
            if (num == 1)
                continue;
            boolean flag = true;
            for (int j = 2; j <= Math.sqrt(num); j++) {
                if (num % j == 0) {
                    flag = false;
                    break;
                }
            }
            if (flag)
                count++;
        }
        System.out.println(count);
    }
}
```

---

- 하지만 걸린 시간과 메로리가 더 짧은 방법이 있었다.
- 최대 1000까지 입력이므로 불린형 배열에 true false로 소수 판별을 미리 만들어 놓고 인덱스로 찾아가서 true면 출력.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        boolean[] ar = new boolean[1001];
        int n = Integer.parseInt(br.readLine());
        int count = 0;

        StringTokenizer st = new StringTokenizer(br.readLine());

        for (int i = 0; i < n; i++) {
            ar[Integer.parseInt(st.nextToken())] = true;
        }

        for (int i = 2; i <= 1000; i++) {
            if (ar[i])
                count++;
            for (int j = 2;; j++) {
                if (i * j > 1000)
                    break;
                ar[i * j] = false;
            }
        }
        bw.write(count + "");
        bw.flush();
    }
}
```
