---
emoji: 🧢
title: 최소 스패닝 트리
date: '2021-03-09T11:31:37.121Z'
categories: 알고리즘
author: Jard
description: '백준 1197번 문제'
---

[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1197)

<div style="text-align:center"><a href="https://www.acmicpc.net/problem/1197">https://www.acmicpc.net/problem/1197</a></div>

---

- '최소 스패닝 트리'에 대한 설명이 적혀있는데 잘 모르겠다.

  - 검색해보니 크루스칼 알고리즘을 쓰라는데 그렇다면 크루스칼 알고리즘은 또 무엇인가?
    ![](/media/ac1197/1.jpg)
  - 위와 같은 노드와 노드를 잇는 가중치가 주어질때 최소값으로 정렬 후 '순환하지 않게' 모두 이어준다.
  - 가중치 정렬표

  | B-C | A-B | D-E | B-D | C-E | A-D | A-E | C-D |
  | --- | --- | --- | --- | --- | --- | --- | --- |
  | 1   | 3   | 3   | 4   | 4   | 5   | 7   | 8   |

  - 이제 저기서 최소값부터 하나씩 이어준다.
    ![](/media/ac1197/2.jpg)
    이렇게 잇기 시작해서
    ![](/media/ac1197/3.jpg)
    하나씩 연결해주는데 저렇게 모든 점들이 연결되고 C-E도 4이긴 하지만 연결시 순환되므로 생략한다.
    https://yabmoons.tistory.com/186를 참조했습니다.

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.stream.IntStream;

public class Main {
    static int[] parent;

    public static int find(int x) {
        if (parent[x] == x) {
            return x;
        }
        return parent[x] = find(parent[x]);
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] input = reader.readLine().split(" ");
        int v = Integer.parseInt(input[0]), e = Integer.parseInt(input[1]);
        ArrayList<int[]> ar = new ArrayList<int[]>();
        parent = IntStream.range(0, v + 1).toArray();
        int sum = 0;

        for (int i = 0; i < e; i++) {
            input = reader.readLine().split(" ");
            int[] temp = new int[3];
            for (int j = 0; j < 3; j++)
                temp[j] = Integer.parseInt(input[j]);
            ar.add(temp);
        }

        ar.sort(Comparator.comparing(o -> o[2]));

        for (int[] x : ar) {
            int a = find(x[0]), b = find(x[1]);
            if (a != b) {
                sum += x[2];
                if (a != b)
                    parent[b] = a;
            }
        }

        System.out.println(sum);
    }
}
```

- 일단 답은 맞췄는데 메모리가 범람했다. 메모리계의 을지문덕이 되었다.
  ![](/media/ac1197/4.jpg)

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.PriorityQueue;
import java.util.StringTokenizer;
import java.util.stream.IntStream;

public class Main {
    static class Node implements Comparable<Node> {
        int a, b, c;

        Node(int a, int b, int c) {
            this.a = a;
            this.b = b;
            this.c = c;
        }

        @Override
        public int compareTo(Node arg0) {
            return arg0.c >= this.c ? -1 : 1;
        }
    }

    static int[] parent;

    public static int find(int x) {
        if (parent[x] == x) {
            return x;
        }
        return parent[x] = find(parent[x]);
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer input = new StringTokenizer(reader.readLine());
        int v = Integer.parseInt(input.nextToken()), e = Integer.parseInt(input.nextToken());
        PriorityQueue<Node> ar = new PriorityQueue<Node>();
        parent = IntStream.range(0, v + 1).toArray();
        int sum = 0;

        for (int i = 0; i < e; i++) {
            input = new StringTokenizer(reader.readLine());
            ar.add(new Node(Integer.parseInt(input.nextToken()), Integer.parseInt(input.nextToken()),
                    Integer.parseInt(input.nextToken())));
        }
        input = null;
        reader.close();

        while (!ar.isEmpty()) {
            Node x = ar.poll();
            int a = find(x.a), b = find(x.b);
            if (a != b) {
                sum += x.c;
                if (a != b)
                    parent[b] = a;
            }
        }

        System.out.println(sum);
    }
}
```

- 커스텀 클래스로 만들어서 Comparable를 받아서 만들어주니 메모리가 많이 줄었다.
- 정렬을 커스텀으로 하는게 메모리를 많이 먹나보다.
  ![](/media/ac1197/5.jpg)
