---
emoji: 🧢
title: '중량제한'
date: '2021-07-07T23:55:37.121Z'
categories: 알고리즘
author: Jard
description: '백준 1939번 유니온 파인드 문제'
---

[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1939)

<div style="text-align:center"><a href="https://www.acmicpc.net/problem/1939">https://www.acmicpc.net/problem/1939</a></div>

---

- 가능한 다리의 무게를 무거운 순서로 정렬하여 꺼내면서 부모 노드를 합쳐준다.
- 합쳐준 부모 노드 기록을 참조하여 합치기가 끝날때 시작점과 끝이 같아졌는지 확인한다.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.Arrays;
import java.util.Collections;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

class Node implements Comparable<Node> {
    //시작점,도착점,가능한 무게 변수
    public int start, end, weight;

    public Node(int start, int end, int weight) {
        this.start = start;
        this.end = end;
        this.weight = weight;
    }

    //역순으로 정렬한다.
    @Override
    public int compareTo(Node o) {
        return o.weight - this.weight;
    }
}

public class Main {
    static BufferedReader br;
    static BufferedWriter bw;
    static StringBuilder sb;

    //부모노드 기록을 위한 배열
    static int[] ar;


    //합칠때 한쪽 값을 다른쪽에 더하고 한쪽에는 노드 인덱스를 기록하여 부모는 음수의 값을 갖는다.
    private static void merge(int cur_start, int cur_end) {
        int pa = findRoot(cur_start), pb = findRoot(cur_end);
        if (pa == pb)
            return;
        ar[pa] += ar[pb];
        ar[pb] = pa;
        return;
    }

    //부모 노드는 음수의 정수를 가지고 있으므로 배열 안의 값이 0보다 작을 경우 부모이다.
    private static int findRoot(int index) {
        if (ar[index] < 0)
            return index;
        return ar[index] = findRoot(ar[index]);
    }

    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));

        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken()), m = Integer.parseInt(st.nextToken()), ans = Integer.MAX_VALUE;
        PriorityQueue<Node> q = new PriorityQueue<Node>();
        ar = new int[n + 1];
        //부모 노드 기록을 -1로 채운다.
        Arrays.fill(ar, -1);
        for (int i = 0; i < m; i++) {
            st = new StringTokenizer(br.readLine());
            q.add(new Node(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken()),
                    Integer.parseInt(st.nextToken())));
        }
        st = new StringTokenizer(br.readLine());
        int start = Integer.parseInt(st.nextToken()), end = Integer.parseInt(st.nextToken());
        //큐에서 꺼내서 확인
        while (!q.isEmpty()) {
            Node node = q.poll();
            int cur_start = node.start, cur_end = node.end, cur_weight = node.weight;
            if (findRoot(cur_start) == findRoot(cur_end))
                continue;
            //무게는 정수 최대값에서 점차 내림차순이므로 더 작은 값을 집어 넣는다.
            ans = Math.min(ans, cur_weight);
            merge(cur_start, cur_end);
            if (findRoot(start) == findRoot(end))
                break;
        }
        bw.write("" + ans);
        bw.flush();
    }
}
```
