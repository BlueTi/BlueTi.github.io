---
emoji: 🧢
title: 'Degree Bounded Minimum Spanning Tree'
date: '2021-04-21T10:10:37.121Z'
categories: 알고리즘
author: Jard
description: '백준 20927번 문제'
---

[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/20927)

<div style="text-align:center"><a href="https://www.acmicpc.net/problem/20927">https://www.acmicpc.net/problem/20927</a></div>

---

- 문제에서 스패닝트리만 읽고 최소 스패닝트리로 하면 답이 없다.
- 브루트포스로 접근해야한다.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

class Node implements Comparable<Node>{
    int start,end,cost;
    public Node(int start,int end,int cost){
        this.start = (start<end?start:end);
        this.end = (start<end?end:end);
        this.cost = cost;
    }
    @Override
    public int compareTo(Node o) {
        return this.cost - o.cost;
    }
}

public class Main {
    static BufferedReader br;
    static BufferedWriter bw;
    static StringBuilder sb;
    static int[] ar,limit,degree,check;
    static int n,m,sum=Integer.MAX_VALUE;
    static Queue<Node> nodes = new LinkedList<Node>();
    static ArrayList<Node> edges = new ArrayList<Node>();
    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));
        sb = new StringBuilder();
        StringTokenizer st = new StringTokenizer(br.readLine());
        n  = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        limit = new int[n+1];
        check = new int[m+1];
        st = new StringTokenizer(br.readLine());
        for(int i=1;i<=n;i++){
            limit[i] = Integer.parseInt(st.nextToken());
        }
        for(int i=0;i<m;i++){
            st = new StringTokenizer(br.readLine());
            edges.add(new Node(Integer.parseInt(st.nextToken()),Integer.parseInt(st.nextToken()),Integer.parseInt(st.nextToken())));
        }
        Collections.sort(edges);
        backtrack(0,0);

        if(nodes.isEmpty()){
            sb.append(n==1?"YES":"NO");
        }
        else{
            sb.append("YES\n");
            while(!nodes.isEmpty()){
                Node node = nodes.poll();
                sb.append(node.start+" "+node.end+(nodes.isEmpty()?"":"\n"));
            }
        }
        bw.write(sb.toString());
        bw.flush();
        bw.close();
    }
    private static void backtrack(int index, int cnt) {
        if(cnt==n-1){
            boolean flag = true;
            int tsum = 0;
            ar = new int[n+1];
            Arrays.fill(ar,-1);
            degree = new int[n+1];
            Queue<Node> temp = new LinkedList<Node>();

            for(int i=0;i<m;i++){
                if(check[i]==0)continue;
                Node node = edges.get(i);
                if(find(node.start)!=find(node.end)){
                    union(node.start, node.end);
                    degree[node.start]++;
                    degree[node.end]++;
                    temp.add(node);
                    tsum+=node.cost;
                }
            }

            for(int i=1;i<=n;i++){
                if((i>1&&find(i-1)!=find(i))||(degree[i]>limit[i])){
                    flag=false;
                    break;
                }
            }

            if(flag){
                if(sum>tsum){
                    sum=tsum;
                    nodes=new LinkedList<>(temp);
                }
            }

            return;
        }

        for(int i=index;i<m;i++){
            if(check[i]==1)continue;
            check[i]=1;
            backtrack(i+1, cnt+1);
            check[i]=0;
        }
    }
    private static void union(int start, int end) {
        int pa = find(start),pb=find(end);
        if(pa==pb)return;
        // ar[pa]+=ar[pb];
        ar[pb]=pa;
        return;
    }
    private static int find(int index) {
        if(ar[index]<0)return index;
        return ar[index] = find(ar[index]);
    }
}



```
