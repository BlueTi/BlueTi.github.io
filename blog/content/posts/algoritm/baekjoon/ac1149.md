---
title: RGB거리
date: "2021-03-05T01:15:37.121Z"
template: "post"
draft: false
slug: "ac1149"
category: "알고리즘"
tags:
  - "알고리즘"
  - "백준"
  - "1149"
  - "문제풀이"
  - "java"
description: "백준 1149번 문제"
socialImage: "/media/algorithm.png"
---

[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1149)
<div style="text-align:center"><a href="https://www.acmicpc.net/problem/1149">https://www.acmicpc.net/problem/1149</a></div>

---

> i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다. 

- 이 문장을 읽으면 순간 복잡하게 생각이 들었지만 따지고 보면 그냥 앞집의 색과 다르면 그만이다
- 도색에 드는 비용이 들어있는 배열(ar) | 여태까지 겹치지 않고 최소값으로 도배를 해온 비용으로 나누어 배열(dp)을 만들어 채운다.
- 최소도색비용 배열(dp)을 채울때 위에서 색을 정하고(dp[i-1][0])
- 이전 줄(dp[i-1])의 겹치지 않는 색의 최소도배비용을 비교하여 더 작은값(dp[i-1][1] < dp[i-1][2]?)과 현재 집에 선택한 색의 도색비용을 더해준다(+ar[i][0]).


```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(reader.readLine());
        int[][] ar = new int[n][3], dp = new int[n][3];

        for (int i = 0; i < n; i++) {
            ar[i] = Arrays.stream(reader.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
        }

        dp[0] = ar[0];
        for (int i = 1; i < n; i++) {
            dp[i][0] = (dp[i - 1][1] < dp[i - 1][2] ? dp[i - 1][1] : dp[i - 1][2]) + ar[i][0];
            dp[i][1] = (dp[i - 1][0] < dp[i - 1][2] ? dp[i - 1][0] : dp[i - 1][2]) + ar[i][1];
            dp[i][2] = (dp[i - 1][0] < dp[i - 1][1] ? dp[i - 1][0] : dp[i - 1][1]) + ar[i][2];
        }

        int min = dp[n - 1][0] < dp[n - 1][1] ? dp[n - 1][0] : dp[n - 1][1];
        System.out.println(min < dp[n - 1][2] ? min : dp[n - 1][2]);
    }
}

```