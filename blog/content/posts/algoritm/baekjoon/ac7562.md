---
title: "나이트의 이동"
date: "2021-06-14T10:18:37.121Z"
template: "post"
draft: false
slug: "ac7562"
category: "알고리즘"
tags:
  - "알고리즘"
  - "백준"
  - "7562"
  - "너비 우선 탐색"
  - "그래프 탐색"
  - "문제풀이"
  - "java"
description: "백준 7562번 문제"
socialImage: "/media/algorithm.png"
---

[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/7562)
<div style="text-align:center"><a href="https://www.acmicpc.net/problem/7562">https://www.acmicpc.net/problem/7562</a></div>

---

- 큐를 이용해 탐색할 작업을 돈다.
- 처음 도착한 값이 최소 값이므로 break.

---



```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;

class Main {
    static BufferedReader br;
    static BufferedWriter bw;

    //이동 가능한 방위 좌표를 정한다.
    static int[][] direction = new int[][] { { -2, 1 }, { -1, 2 }, { 1, 2 }, { 2, 1 }, { 2, -1 }, { 1, -2 }, { -1, -2 },
            { -2, -1 } };

    public static void main(String[] args) throws java.lang.Exception {
        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));

        //테스트케이스 갯수
        int t = Integer.parseInt(br.readLine());
        while (t-- > 0) {
            //테스트케이스 마다 초기화한다.
            Queue<int[]> q = new LinkedList<int[]>();
            //체스판 한 변의 길이
            int l = Integer.parseInt(br.readLine());
            //접근 숫자를 저장해줄 int배열
            int[][] count = new int[l][l];
            //시작위치 pos, 도착위치 dest, 현재위치 cur를 선언한다.
            int[] pos = Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray(),
                    dest = Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray(),
                    cur = new int[2];

            //-1일경우는 방문하지 않았다는 의미를 준다.
            for (int i = 0; i < l; i++) {
                Arrays.fill(count[i], -1);
            }

            //시작위치는 0부터 시작
            count[pos[0]][pos[1]] = 0;
            //탐색 작업을 위해 큐에 넣어준다.
            q.add(pos);

            //더 이상 탐색할 일이 없을 때까지 반복한다.
            while (!q.isEmpty()) {
                //탐색할 현재 위치를 꺼내서 cur에 대입
                cur = q.remove();
                // 목적지에 도착했다면 break
                if (cur[0] == dest[0] && cur[1] == dest[1])
                    break;

                //각 방향을 하나씩 꺼내서 확인한다.
                for (int[] dir : direction) {
                    int x = cur[0] + dir[0], y = cur[1] + dir[1];
                    //x,y가 체스판을 벗어나지 않는 범위 내에서 실행한다.
                    if (x >= 0 && x < l && y >= 0 && y < l) {
                        //방문한적 없는 위치라면
                        if (count[x][y] == -1) {
                            //이전 위치 값에서 1을 늘려 입력하고
                            count[x][y] = count[cur[0]][cur[1]] + 1;
                            //큐에 다음 탐색할 위치로 저장한다.
                            q.add(new int[] { x, y });
                        }
                    }
                }
            }
            //도착한 위치의 카운트 값 출력
            bw.write(count[cur[0]][cur[1]] + (t == 0 ? "" : "\n"));
        }
        bw.flush();
    }
}
```