---
title: "구슬 탈출 2"
date: "2021-06-18T15:16:37.121Z"
template: "post"
draft: false
slug: "ac13460"
category: "알고리즘"
tags:
  - "알고리즘"
  - "백준"
  - "13460"
  - "그래프이론"
  - "그래프탐색"
  - "너비 우선 탐색"
  - "문제풀이"
  - "java"
description: "백준 13460번 문제"
socialImage: "/media/algorithm.png"
---

[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/13460)
<div style="text-align:center"><a href="https://www.acmicpc.net/problem/13460">https://www.acmicpc.net/problem/13460</a></div>

---

- 구슬이 어딘가 부딛힐때까지 움직인다.
- 빨간 구슬과 파란 구슬은 겹쳐지지 않는다.
- 파란 구슬과 빨간 구슬이 같은 방향으로 동시에 빠질 경우 실패.
- 파란 구슬이 먼저 빠져도 안된다.
- 10번 이내 해야하고 그러지 못 할 경우 -1을 출력.
 


---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class Main {
    static BufferedReader br;
    static BufferedWriter bw;

    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken()), m = Integer.parseInt(st.nextToken());
        char[][] map = new char[n][m];
        //상태를 담아서 전달할 배열 status
        //0,1 = 빨간 구슬 y,x | 2,3 = 파란 구슬 y,x | 4 = 이동횟수
        int[] status = new int[5];
        //빨간구슬위치[][] 파란구슬위치[][]에 온적이 있는지 체크할 목록
        boolean[][][][] visited = new boolean[n][m][n][m];
        for (int i = 0; i < n; i++) {
            char[] input = br.readLine().toCharArray();
            for (int j = 0; j < m; j++) {
                char c = input[j];
                map[i][j] = c;
                //구슬의 위치는 따로 저장해놓고 지도 상에는 .으로 표기
                if (c == 'R') {
                    status[0] = i;
                    status[1] = j;
                    map[i][j] = '.';
                } else if (c == 'B') {
                    status[2] = i;
                    status[3] = j;
                    map[i][j] = '.';
                }
            }
        }

        //탐색목록 BFS를 위한 큐
        Queue<int[]> queue = new LinkedList<int[]>();
        queue.add(status);

        //상하좌우 좌표
        int[][] directions = new int[][] { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };
        //탐색할게 없을때까지 반복
        while (!queue.isEmpty()) {
            status = queue.remove();

            //10번 이상 움직일 경우 -1 출력을 위해 status[4]에 -1을 대입하고 while종료
            if (status[4] > 10) {
                status[4] = -1;
                break;
            }
            
            //파란구슬이 빠진경우(파란구슬이 먼저빠짐, 파란구슬과 빨간구슬이 동시에 빠짐) 큐에 더 넣지 않고 생략
            if (map[status[2]][status[3]] == 'O')
                continue;
            //빨간 구슬만 빠진경우 while종료
            else if (map[status[0]][status[1]] == 'O') 
                break;


            //4방위탐색
            for (int j = 0; j < 4; j++) {
                int[] dir = directions[j];
                //빨간 구슬의 위치를 따로 꺼냄
                int[] cur_red = new int[] { status[0], status[1] };
                // 구슬이 빠지거나 벽 위치까지 굴림
                while (true) {
                    cur_red[0] += dir[0];
                    cur_red[1] += dir[1];
                    if (map[cur_red[0]][cur_red[1]] == 'O' || map[cur_red[0]][cur_red[1]] == '#')
                        break;
                }
                //벽위치로 간 경우 전 칸으로 옮겨준다.
                if (map[cur_red[0]][cur_red[1]] == '#') {
                    cur_red[0] -= dir[0];
                    cur_red[1] -= dir[1];
                }
                // 파란 구슬도 반복
                int[] cur_blue = new int[] { status[2], status[3] };
                while (true) {
                    int next_y = cur_blue[0] + dir[0], next_x = cur_blue[1] + dir[1];
                    cur_blue[0] = next_y;
                    cur_blue[1] = next_x;
                    if (map[next_y][next_x] == 'O' || map[next_y][next_x] == '#')
                        break;
                }
                if (map[cur_blue[0]][cur_blue[1]] == '#') {
                    cur_blue[0] -= dir[0];
                    cur_blue[1] -= dir[1];
                }

                // 빨간 구슬과 파란 구슬이 같은 위치에 도달하였으나 구멍이 아닌경우
                if (cur_blue[0] == cur_red[0] && cur_blue[1] == cur_red[1] && map[cur_red[0]][cur_red[1]] != 'O') {
                    // 두 구슬이 이동한 거리를 계산하여 더 멀리서 온 구슬이 나중에 온것이므로 그 전칸으로 조정
                    int red_dis = Math.abs(status[0] - cur_red[0]) + Math.abs(status[1] - cur_red[1]);
                    int blue_dis = Math.abs(status[2] - cur_blue[0]) + Math.abs(status[3] - cur_blue[1]);
                    if (red_dis > blue_dis) {
                        cur_red[0] -= dir[0];
                        cur_red[1] -= dir[1];
                    } else {
                        cur_blue[0] -= dir[0];
                        cur_blue[1] -= dir[1];
                    }
                }
                // 현 구슬들의 위치가 방문한적이 있는지 확인 있을경우는 이미 탐색을 했으므로 하지 않는다.
                if (!visited[cur_red[0]][cur_red[1]][cur_blue[0]][cur_blue[1]]) {
                    visited[cur_red[0]][cur_red[1]][cur_blue[0]][cur_blue[1]] = true;
                    queue.add(new int[] { cur_red[0], cur_red[1], cur_blue[0], cur_blue[1], status[4] + 1 });
                }
            }
        }

        //탐색을 마쳤는데 구슬이 안빠진 경우 -1 아니면 status에 들어있는 이동횟수를 출력해준다.
        bw.write((map[status[2]][status[3]] != 'O' && map[status[0]][status[1]] == 'O'? status[4]:-1) + "");
        bw.flush();
    }
}
```