---
title: "여행 가자"
date: "2021-07-05T01:31:37.121Z"
template: "post"
draft: false
slug: "ac1976"
category: "알고리즘"
tags:
  - "알고리즘"
  - "백준"
  - "1976"
  - "유니온 파인드"
  - "문제풀이"
  - "java"
description: "백준 1976번 문제"
socialImage: "/media/algorithm.png"
---

[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1976)
<div style="text-align:center"><a href="https://www.acmicpc.net/problem/1976">https://www.acmicpc.net/problem/1976</a></div>

---

- 여행지의 각 위치를 숫자로 표기한다.
- 입력 배열에서 1이 들어올 경우 i,j 위치를 이어준다(각 값을 비교하여 루트를 넣어준다).

---



```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.StringTokenizer;

public class Main {
    static BufferedReader br;
    static BufferedWriter bw;

    //연결 위치가 기록될 배열
    static int[] ar;

    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));

        StringTokenizer st = null;
        int n = Integer.parseInt(br.readLine()), m = Integer.parseInt(br.readLine());
        ar = new int[n + 1];
        //각 노드의 루트를 자신으로 초기화한다.
        for (int i = 1; i <= n; i++) {
            ar[i] = i;
        }

        for (int i = 1; i <= n; i++) {
            st = new StringTokenizer(br.readLine());
            for (int j = 1; j <= n; j++) {
                //입력 배열 길이 만큼 반복한다.
                int cmd = Integer.parseInt(st.nextToken());

                // 1이 입력될 경우 배열 i,j를 이어준다.
                if (cmd == 1) {
                    union(i, j);
                }
            }
        }

        //여행 계획을 입력받는다.
        st = new StringTokenizer(br.readLine());
        //여행을 시작할 위치의 루트노드를 찾는다.
        int startRoot = findROOT(Integer.parseInt(st.nextToken()));
        //결과 값을 확인할 boolean값을 정의한다.
        boolean can = true;
        for (int i = 1; i < m; i++) {
            //다음 여행갈 목적지를 입력 받고 시작 위치와 이어져 있는지 확인한다.
            int next = Integer.parseInt(st.nextToken());
            //시작 위치에서 갈 수 없는 경우 boolean 값에 false를 넣고 반복문을 종료한다.
            if (startRoot != findROOT(next)) {
                can = false;
                break;
            }
        }
        //모든 목적지에 갈 수 있을 경우 YES : 불가능 할 경우 NO
        bw.write(can ? "YES" : "NO");
        bw.flush();
    }

    private static int findROOT(int index) {
        if (ar[index] == index)
            return index;
        return ar[index] = findROOT(ar[index]);
    }

    private static void union(int i, int j) {
        i = findROOT(i);
        j = findROOT(j);

        if (i < j) {
            ar[j] = i;
        } else if (i > j) {
            ar[i] = j;
        }
    }
}
```
