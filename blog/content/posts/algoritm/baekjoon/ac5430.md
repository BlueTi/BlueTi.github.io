---
title: "AC"
date: "2021-05-31T00:54:37.121Z"
template: "post"
draft: false
slug: "ac5430"
category: "알고리즘"
tags:
  - "알고리즘"
  - "백준"
  - "5430"
  - "자료구조"
  - "문자열"
  - "파싱"
  - "덱"
  - "문제풀이"
  - "java"
description: "백준 5430번 문제"
socialImage: "/media/algorithm.png"
---

[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/5430)
<div style="text-align:center"><a href="https://www.acmicpc.net/problem/5430">https://www.acmicpc.net/problem/5430</a></div>

---

- 문제 자체는 단순하다. 명령대로 R일 경우 순서를 뒤집고, D일 경우 앞에서 하나를 빼준다.
- 하지만 일일히 뒤집으면 시간이 오래 걸리므로 인덱스 left,right를 선언하여 한칸씩 움직여봤다.

---


```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

class Main {
    static BufferedReader br;
    static BufferedWriter bw;
    static int target, n, min = Integer.MAX_VALUE;

    public static void main(String[] args) throws java.lang.Exception {
        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));
        //결과를 위한 StringBuilder
        StringBuilder sb = new StringBuilder();
        //TestCase
        int T = Integer.parseInt(br.readLine());

        for (int i = 0; i < T; i++) {
            //String.charAt() 보다 char[] 탐색이 빨라서 변경
            char[] cmds = br.readLine().toCharArray();
            //배열의 길이
            int len = Integer.parseInt(br.readLine());
            //오른쪽인덱스는 배열의 길이보다 하나작게
            int right = len - 1;
            //왼쪽인덱스는 0부터
            int left = 0;

            //배열 입력
            String ar = br.readLine();
            //앞뒤의 []을 제거해준다.
            ar = ar.substring(1, ar.length() - 1);
            // , 기준으로 배열로 변환
            String[] arr = ar.split(",");

            // 에러나지 않고 내용물을 출력해주는 신호 print_flag와 R명령어 인식을 위한 reverse_flag 선언
            boolean print_flag = true, reverse_flag = false;

            //커맨드 배열에서 하나씩 꺼내서 실행한다.
            for (char cmd : cmds) {
                if (cmd == 'R') { //명령어 R일 경우 배열을 뒤집어야 하지만 그냥 인덱스 처리만 뒤집기 위한 reverse_flag 조작
                    reverse_flag = !reverse_flag;
                } else if (cmd == 'D') { //명령어 D일 경우 
                    //R이 안나왔다면 맨 앞 값을 제거해야하지만 left 인덱스 증가
                    if (!reverse_flag)
                        left++;
                    //R이 나왔다면 맨 뒤 값을 제거해야하지만 right 인덱스를 감소
                    else
                        right--;

                    //만약 left인덱스가 right + 1한 값보다 크다면 에러, +1 한 이유는 빈 배열도 출력해야한다.
                    if (left > right + 1) {
                        sb.append("error\n");
                        print_flag = false;
                        break;
                    }
                }
            }
            //출력
            if (print_flag) {
                sb.append('[');
                //인덱스 증가를 뒤집어졌다면 1씩 내려가고 아니라면 1씩 올라가면서 출력
                int step = 1;
                if (reverse_flag) {
                    step *= -1;
                }

                //시작 인덱스는 뒤집어 졌다면 right 아니면 left부터 시작
                //인덱스 범위는 left와 right안에 있다.
                for (int index = (reverse_flag ? right : left); index <= right && index >= left; index += step) {
                    sb.append(arr[index] + (index != (reverse_flag ? left : right) ? "," : ""));
                }
                sb.append("]\n");
            }
        }

        //완성된 String 출력
        bw.write(sb.toString());
        bw.flush();
    }
}
```


---

- 위와 같이 푸는 방식도 있지만 java에는 Deque 클래스가 있으므로 일일히 구현할 필요 없이 이미 구현된 클래스를 사용하여도 된다.


```java
...
import java.util.Deque;
import java.util.LinkedList;

class Main {
    ...

    public static void main(String[] args) throws java.lang.Exception {
        ...

        for (int i = 0; i < T; i++) {
            ...
            String[] arr = ar.split(",");
            //Deque를 선언하여 값을 하나씩 넣어준다.
            Deque dq = new LinkedList();
            for (int j = 0; j < len; j++) {
                dq.add(Integer.parseInt(arr[j]));
            }

            boolean print_flag = true, reverse_flag = false;
            for (char cmd : cmds) {
                if (cmd == 'R') {
                    reverse_flag = !reverse_flag;
                } else if (cmd == 'D') {
                    //Deque가 비어있는데 삭제를 요청했으므로 에러를 출력하고 반복문을 종료
                    if (dq.isEmpty()) {
                        sb.append("error\n");
                        print_flag = !print_flag;
                        break;
                    }

                    // Deque가 그대로라면 앞에서 삭제
                    if (!reverse_flag)
                        dq.removeFirst();
                    // Deque가 뒤집어졌다면 뒤에서 삭제
                    else
                        dq.removeLast();

                }
            }
            if (print_flag) {
                sb.append("[");
                //Deque가 빌때까지 반복
                while (!dq.isEmpty()) {
                    //reverse_flag가 true면 뒤에서 하나씩 꺼내고 false라면 앞에서 하나씩 꺼내어 문장에 붙인다.
                    sb.append((reverse_flag ? dq.pollLast() : dq.pollFirst()) + (dq.isEmpty() ? "" : ","));
                }
                sb.append("]\n");
            }
        }
        ...
```