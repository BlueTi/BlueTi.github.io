---
title: "연산자 끼워넣기"
date: "2021-05-31T18:32:37.121Z"
template: "post"
draft: false
slug: "ac14888"
category: "알고리즘"
tags:
  - "알고리즘"
  - "백준"
  - "14888"
  - "백트레킹"
  - "브루트포스"
  - "문제풀이"
  - "java"
description: "백준 14888번 문제"
socialImage: "/media/algorithm.png"
---

[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/14888)
<div style="text-align:center"><a href="https://www.acmicpc.net/problem/14888">https://www.acmicpc.net/problem/14888</a></div>

---

- 연산자의 갯수가 주어지고 주어진 숫자 배열에 끼워 넣어 만든 값의 최대,최소 값을 출력하는 문제
- 연산자 하나 끼워서 계산해보고 다시 빼서 다른거 끼워보며 연산을 하는 과정으로 생각하면 편하다.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.StringTokenizer;

class Main {
    static BufferedReader br;
    static BufferedWriter bw;
    //dfs를 쓰기 위해 크기(n), 최소값(min), 최대값(max)를 전역 변수로 선언한다.
    //max는 비교하여 넣기 위해 int의 최소값을, min은 비교하여 최소 값이 들어가야하므로 최대값을 미리 넣어놓는다.
    static int n, min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;
    //숫자배열(numbers), 연산자(oper)는 +,-,*,/ 순서로 갯수가 주어지므로 길이가 4인 배열을 선언한다.
    static int[] numbers, oper = new int[4];

    public static void main(String[] args) throws java.lang.Exception {
        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));

        n = Integer.parseInt(br.readLine());
        //숫자 배열을 문자열 한줄로 입력 받아 띄어쓰기로 분리해주는 StringTokenizer에 담아 하나씩 꺼내쓴다.
        StringTokenizer st = new StringTokenizer(br.readLine());
        numbers = new int[n];
        for (int i = 0; i < n; i++)
            numbers[i] = Integer.parseInt(st.nextToken());

        //연산자도 위와 같은 방법을 사용한다.
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < 4; i++)
            oper[i] = Integer.parseInt(st.nextToken());

        //첫번째 숫자와 숫자 하나를 사용했으므로 다음 값을 찾기 위해 인덱스를 하나 늘려서 1로 전달한다.
        dfs(numbers[0], 1);
        System.out.println(max + "\n" + min);
    }

    public static void dfs(int num, int index) {
        //전달 받은 인덱스값이 n과 같다는것은 배열의 범위보다 1크므로 모든배열을 탐색했다는 의미를 가진다.
        //연산이 끝났으므로 값을 최소 최대를 비교하여 넣고 함수를 끝낸다.
        if (index == n) {
            min = min > num ? num : min;
            max = max < num ? num : max;
            return;
        }


        //연산자 4개 반복
        for (int i = 0; i < 4; i++) {
            //주어진 연산자 갯수가 있다면
            if (oper[i] > 0) {
                //꺼내쓰므로 -1 한다.
                oper[i]--;
                //연산자에 따라 탐색을 달리하고 다음 숫자를 꺼내기 위해 index+1을 한다.
                switch (i) {
                    case 0:
                        dfs(num + numbers[index], index + 1);
                        break;
                    case 1:
                        dfs(num - numbers[index], index + 1);
                        break;
                    case 2:
                        dfs(num * numbers[index], index + 1);
                        break;
                    case 3:
                        dfs(num / numbers[index], index + 1);
                        break;
                }
                //위의 연산이 끝났다면 사용한 연산자를 돌려준다.
                oper[i]++;
            }
        }

    }

}
```