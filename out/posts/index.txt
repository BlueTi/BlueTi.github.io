2:I[9201,["972","static/chunks/972-6576aeaf1f991e3d.js","991","static/chunks/app/posts/page-5987fd68959a3c37.js"],"default"]
4b:I[4707,[],""]
4c:I[6423,[],""]
4d:I[4058,["972","static/chunks/972-6576aeaf1f991e3d.js","185","static/chunks/app/layout-2b57208f03ac30e3.js"],"default"]
4e:I[2972,["972","static/chunks/972-6576aeaf1f991e3d.js","931","static/chunks/app/page-515b9a9216b60d52.js"],""]
4f:I[9922,["972","static/chunks/972-6576aeaf1f991e3d.js","185","static/chunks/app/layout-2b57208f03ac30e3.js"],"default"]
3:Teac,
[![프로그래머스](https://file.newswire.co.kr/data/datafile2/thumb_640/2021/06/1993996598_20210610150326_5364622170.jpg)](https://programmers.co.kr/learn/courses/30/lessons/72412)

<div className="text-center"><a href="https://programmers.co.kr/learn/courses/30/lessons/60058">https://programmers.co.kr/learn/courses/30/lessons/72412</a></div>

- Map안에 List를 넣어 관리한다
- 검색가능한 쿼리 키를 미리 만들어 목록을 작성한다
- 조건맞을 맞춘 목록에서 이분 탐색으로 속도를 구해야한다

```java
import java.util.*;

/**
 * 순위 검색 문제 해결
 * 지원자 정보를 조건별로 분류하고, 쿼리에 맞는 지원자 수를 구하는 문제
 * Map을 사용하여 조건별로 점수를 저장하고, 이분 탐색으로 효율적으로 검색
 */
class Solution {
    Map<String, List<Integer>> allInfo; // 조건별 점수 리스트를 저장하는 Map
    List<Integer> scores;

    public int[] solution(String[] info, String[] query) {
        int[] answer = new int[query.length];
        allInfo = new HashMap<String, List<Integer>>(); // 모든 데이터를 담기 위한 Map
        
        // 지원자 정보를 모든 가능한 조건 조합으로 저장
        for (String infoDetail : info) {
            saveData(0, "", infoDetail.split(" "));
        }
        
        // 저장해둔 리스트들을 모두 정렬 (이분 탐색을 위해)
        for (String key : allInfo.keySet()) {
            allInfo.get(key).sort(Comparator.naturalOrder());
        }

        // 각 쿼리에 대해 검색
        for (int i = 0; i < query.length; i++) {
            String[] columns = query[i].replace(" and ", "").split(" ");
            answer[i] = search(columns[0], Integer.parseInt(columns[1])); // 조건 검색
        }

        return answer;
    }

    /**
     * 지원자 정보를 모든 가능한 조건 조합으로 저장
     * "-"는 해당 조건을 무시하는 것을 의미
     * @param depth: 현재 처리할 조건의 인덱스 (0~3)
     * @param key: 현재까지 만든 조건 키
     * @param details: 지원자 정보 배열
     */
    public void saveData(int depth, String key, String[] details) {
        // 쿼리 내 변수 4개를 다 채웠을 경우 키에 대한 값을 추가
        if (depth == 4) {
            if (!allInfo.containsKey(key)) {
                scores = new ArrayList<Integer>();
                scores.add(Integer.parseInt(details[4]));
                allInfo.put(key, scores);
            } else {
                allInfo.get(key).add(Integer.parseInt(details[4]));
            }
            return;
        }
        // 해당 조건에 대한 키 생성: "-" (조건 무시) 또는 실제 값
        saveData(depth + 1, key + "-", details);
        saveData(depth + 1, key + details[depth], details);
    }

    /**
     * 조건에 맞는 지원자 수를 이분 탐색으로 찾음
     * @param query: 검색 조건 키
     * @param score: 최소 점수
     * @return: 조건에 맞는 지원자 수
     */
    public int search(String query, int score) {
        if (!allInfo.containsKey(query)) // 포함된 조건 키가 없을 경우 0 반환
            return 0;
        List<Integer> list = allInfo.get(query); // 조건 키가 있을 경우 이분 탐색
        int left = 0, right = list.size() - 1;
        
        // 이분 탐색: score 이상인 점수의 개수를 찾음
        while (left <= right) {
            int mid = (left + right) / 2;
            if (list.get(mid) < score)
                left = mid + 1;
            else
                right = mid - 1;
        }
        // left부터 끝까지가 score 이상인 점수들
        return list.size() - left;
    }
}
```
4:Te4c,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1922)

<div className="text-center"><a href="https://www.acmicpc.net/problem/1922">https://www.acmicpc.net/problem/1922</a></div>

---

- <a href='https://m.blog.naver.com/kks227/220799105543'>최소 스패닝 트리</a>에 대한 문제이다.
- 연결 비용을 오름차순으로 정렬 후 연결 목록을 꺼내 부모노드가 다를때 같아지게 만들고, 같다면 넘겨서 모두를 잇는다.
- 유니온 파인드에 이어서 보면 매우 편하다.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.PriorityQueue;
import java.util.StringTokenizer;
import java.util.stream.IntStream;

/**
 * 네트워크 연결 문제 해결
 * 최소 스패닝 트리를 구하는 문제
 * 크루스칼 알고리즘과 Union-Find를 사용
 */

/**
 * 간선을 나타내는 클래스
 */
class Node implements Comparable<Node>{
    int start,end,cost; // 시작점, 도착점, 비용
    public Node(int start,int end, int cost){
        this.start = start;
        this.end = end;
        this.cost = cost;
    }

    /**
     * 비용 오름차순으로 정렬하고 같을 경우 낮은 시작점을 앞으로 함
     */
    @Override
    public int compareTo(Node o) {
        if(this.cost == o.cost)
            return this.start-o.start;
        return this.cost-o.cost;
    }
}


public class Main {
    static BufferedReader br;
    static BufferedWriter bw;
    static StringBuilder sb;
    static int[] ar; // Union-Find를 위한 부모 배열

    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st = null;
        int n = Integer.parseInt(br.readLine()),m = Integer.parseInt(br.readLine()),allCost=0; // n: 컴퓨터 개수, m: 연결 개수
        // 부모 노드 표기 자리에 본인 위치로 초기화
        ar = IntStream.range(0, n+1).toArray();
        PriorityQueue<Node> q = new PriorityQueue<Node>(); // 비용이 작은 간선부터 선택
        
        // 간선 정보 입력
        for(int i = 0; i < m; i++){
            st = new StringTokenizer(br.readLine());
            q.add(new Node(Integer.parseInt(st.nextToken()),Integer.parseInt(st.nextToken()),Integer.parseInt(st.nextToken())));
        }

        // 크루스칼 알고리즘: 비용이 작은 간선부터 선택
        while(!q.isEmpty()){
            Node node = q.poll();
            // 부모 노드가 같은지 확인하고 다르면 합친 뒤 필요한 비용에 더해줌
            if(find(node.start)!=find(node.end)){
                union(node.start,node.end);
                allCost+=node.cost;
            }
        }
        bw.write(allCost+"");
        bw.flush();
    }

    /**
     * 시작점의 부모와 도착점의 부모를 잇는다 (Union)
     */
    private static void union(int start, int end) {
        ar[find(start)] = find(end);
    }

    /**
     * 부모 노드를 찾는 함수 (경로 압축 적용)
     * 부모 노드 위치에 본인 값이 들어있다면 본인이 최고 부모이므로 값을 반환
     * 그렇지 않을 경우 거슬러 올라가면서 부모값을 대입
     */
    private static int find(int index) {
        if(ar[index]==index)return index;
        // 경로 압축: 부모를 루트로 직접 연결
        return ar[index]=find(ar[index]);
    }
}
```
5:T1094,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1939)

<div className="text-center"><a href="https://www.acmicpc.net/problem/1939">https://www.acmicpc.net/problem/1939</a></div>

---

- 가능한 다리의 무게를 무거운 순서로 정렬하여 꺼내면서 부모 노드를 합쳐준다.
- 합쳐준 부모 노드 기록을 참조하여 합치기가 끝날때 시작점과 끝이 같아졌는지 확인한다.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.Arrays;
import java.util.Collections;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

/**
 * 중량제한 문제 해결
 * 시작점에서 끝점까지 이동할 수 있는 최대 중량을 구하는 문제
 * Union-Find와 그리디 알고리즘을 사용: 무게가 큰 다리부터 연결
 */

/**
 * 다리를 나타내는 클래스
 */
class Node implements Comparable<Node> {
    public int start, end, weight; // 시작점, 도착점, 가능한 무게

    public Node(int start, int end, int weight) {
        this.start = start;
        this.end = end;
        this.weight = weight;
    }

    /**
     * 역순으로 정렬 (무게가 큰 것부터)
     */
    @Override
    public int compareTo(Node o) {
        return o.weight - this.weight;
    }
}

public class Main {
    static BufferedReader br;
    static BufferedWriter bw;
    static StringBuilder sb;

    // 부모 노드 기록을 위한 배열
    static int[] ar;

    /**
     * 두 집합을 합치는 함수 (Union)
     * 합칠 때 한쪽 값을 다른쪽에 더하고 한쪽에는 노드 인덱스를 기록하여 부모는 음수의 값을 가짐
     */
    private static void merge(int cur_start, int cur_end) {
        int pa = findRoot(cur_start), pb = findRoot(cur_end);
        if (pa == pb)
            return;
        ar[pa] += ar[pb];
        ar[pb] = pa;
        return;
    }

    /**
     * 부모 노드를 찾는 함수 (경로 압축 적용)
     * 부모 노드는 음수의 정수를 가지고 있으므로 배열 안의 값이 0보다 작을 경우 부모
     */
    private static int findRoot(int index) {
        if (ar[index] < 0)
            return index;
        return ar[index] = findRoot(ar[index]);
    }

    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));

        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken()), m = Integer.parseInt(st.nextToken()), ans = Integer.MAX_VALUE; // n: 섬 개수, m: 다리 개수
        PriorityQueue<Node> q = new PriorityQueue<Node>(); // 무게가 큰 다리부터 선택
        ar = new int[n + 1];
        // 부모 노드 기록을 -1로 채움
        Arrays.fill(ar, -1);
        
        // 다리 정보 입력
        for (int i = 0; i < m; i++) {
            st = new StringTokenizer(br.readLine());
            q.add(new Node(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken()),
                    Integer.parseInt(st.nextToken())));
        }
        st = new StringTokenizer(br.readLine());
        int start = Integer.parseInt(st.nextToken()), end = Integer.parseInt(st.nextToken()); // 시작점, 끝점
        
        // 큐에서 꺼내서 확인: 무게가 큰 다리부터 연결
        while (!q.isEmpty()) {
            Node node = q.poll();
            int cur_start = node.start, cur_end = node.end, cur_weight = node.weight;
            // 이미 연결되어 있으면 건너뜀
            if (findRoot(cur_start) == findRoot(cur_end))
                continue;
            // 무게는 정수 최대값에서 점차 내림차순이므로 더 작은 값을 집어 넣음
            ans = Math.min(ans, cur_weight);
            merge(cur_start, cur_end);
            // 시작점과 끝점이 연결되었으면 종료
            if (findRoot(start) == findRoot(end))
                break;
        }
        bw.write("" + ans);
        bw.flush();
    }
}
```
6:Td83,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1976)

<div className="text-center"><a href="https://www.acmicpc.net/problem/1976">https://www.acmicpc.net/problem/1976</a></div>

---

- 여행지의 각 위치를 숫자로 표기한다.
- 입력 배열에서 1이 들어올 경우 i,j 위치를 이어준다(각 값을 비교하여 루트를 넣어준다).

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.StringTokenizer;

/**
 * 여행 가자 문제 해결
 * 여행 계획의 모든 도시가 연결되어 있는지 확인하는 문제
 * Union-Find를 사용하여 도시들의 연결 관계를 관리
 */
public class Main {
    static BufferedReader br;
    static BufferedWriter bw;

    // 연결 위치가 기록될 배열 (Union-Find)
    static int[] ar;

    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));

        StringTokenizer st = null;
        int n = Integer.parseInt(br.readLine()), m = Integer.parseInt(br.readLine()); // n: 도시 개수, m: 여행 계획 도시 개수
        ar = new int[n + 1];
        // 각 노드의 루트를 자신으로 초기화
        for (int i = 1; i <= n; i++) {
            ar[i] = i;
        }

        // 도시 간 연결 정보 입력
        for (int i = 1; i <= n; i++) {
            st = new StringTokenizer(br.readLine());
            for (int j = 1; j <= n; j++) {
                int cmd = Integer.parseInt(st.nextToken());

                // 1이 입력될 경우 배열 i,j를 이어줌 (연결됨)
                if (cmd == 1) {
                    union(i, j);
                }
            }
        }

        // 여행 계획을 입력받음
        st = new StringTokenizer(br.readLine());
        // 여행을 시작할 위치의 루트 노드를 찾음
        int startRoot = findROOT(Integer.parseInt(st.nextToken()));
        // 결과 값을 확인할 boolean 값 정의
        boolean can = true;
        
        // 나머지 여행 계획 도시들이 시작 도시와 연결되어 있는지 확인
        for (int i = 1; i < m; i++) {
            // 다음 여행갈 목적지를 입력 받고 시작 위치와 이어져 있는지 확인
            int next = Integer.parseInt(st.nextToken());
            // 시작 위치에서 갈 수 없는 경우 boolean 값에 false를 넣고 반복문을 종료
            if (startRoot != findROOT(next)) {
                can = false;
                break;
            }
        }
        // 모든 목적지에 갈 수 있을 경우 YES : 불가능 할 경우 NO
        bw.write(can ? "YES" : "NO");
        bw.flush();
    }

    /**
     * 루트 노드를 찾는 함수 (경로 압축 적용)
     */
    private static int findROOT(int index) {
        if (ar[index] == index)
            return index;
        return ar[index] = findROOT(ar[index]);
    }

    /**
     * 두 집합을 합치는 함수 (Union)
     * 작은 번호를 부모로 설정
     */
    private static void union(int i, int j) {
        i = findROOT(i);
        j = findROOT(j);

        if (i < j) {
            ar[j] = i;
        } else if (i > j) {
            ar[i] = j;
        }
    }
}
```
7:Tb6e,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1717)

<div className="text-center"><a href="https://www.acmicpc.net/problem/1717">https://www.acmicpc.net/problem/1717</a></div>

---

- 연결된 숫자들을 찾는 배열을 선언합니다.
- 부모노드를 숫자가 더 작은 쪽으로 몰아 넣어준다.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.StringTokenizer;

/**
 * 집합의 표현 문제 해결
 * Union-Find를 사용하여 두 원소가 같은 집합에 속해있는지 확인하는 문제
 * 부모 노드를 숫자가 더 작은 쪽으로 통일
 */
public class Main {
    static BufferedReader br;
    static BufferedWriter bw;
    static StringBuilder sb;

    static int[] ar; // Union-Find를 위한 부모 배열

    /**
     * 부모를 찾는 함수 (경로 압축 적용)
     * @param index: 찾을 원소
     * @return: 루트 노드
     */
    public static int findROOT(int index) {
        // 부모 노드는 위가 없으므로 자기 자신을 찾았다면 반환
        if (ar[index] == index) {
            return index;
        }
        // 현재 인덱스 값에 부모 노드 값을 넣으면서 반환 (경로 압축)
        return ar[index] = findROOT(ar[index]);
    }

    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));
        sb = new StringBuilder();

        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken()), m = Integer.parseInt(st.nextToken()); // n: 원소 개수, m: 연산 개수
        ar = new int[n + 1];
        // 각 노드 위치에 자기 값을 넣음 (초기화)
        for (int i = 0; i <= n; i++)
            ar[i] = i;

        for (int i = 0; i < m; i++) {
            st = new StringTokenizer(br.readLine());
            int c = Integer.parseInt(st.nextToken()), a = Integer.parseInt(st.nextToken()),
                    b = Integer.parseInt(st.nextToken());
            // c가 0일 경우 두 집합을 합침 (Union)
            if (c == 0) {
                a = findROOT(a);
                b = findROOT(b);
                // b가 더 작을 경우 a의 부모에 b를 입력
                if (a > b)
                    ar[a] = b;
                // a가 더 작을 경우 b의 부모에 a를 입력
                else if (a < b)
                    ar[b] = a;
            } else if (c == 1) { // c가 1일 경우 같은 집합에 속해있는지 확인 (Find)
                sb.append((findROOT(a) == findROOT(b) ? "YES" : "NO") + "\n");
            }
        }
        bw.write(sb.toString());
        bw.flush();
    }
}
```
8:Te4a,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1827)

<div className="text-center"><a href="https://www.acmicpc.net/problem/1827">https://www.acmicpc.net/problem/1827</a></div>

---

- 주유소를 거리가 짧은 순으로 정렬하여 현재 연료로 접근할 수 있는 주유소로 접근한다.
- 넣을 수 있는 기름의 양이 큰 순서로 접근한 주유소 목록 정렬하여 큰 양을 넣는다.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.Comparator;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

/**
 * 연료 채우기 문제 해결
 * 목적지까지 가기 위해 필요한 최소 주유소 방문 횟수를 구하는 문제
 * 그리디 알고리즘: 현재 연료로 접근 가능한 주유소 중 연료를 가장 많이 주는 곳을 선택
 */

/**
 * 주유소 정보를 담는 클래스
 */
class Node {
    int dist, fuel; // 거리, 연료량

    public Node(int dist, int fuel) {
        this.dist = dist;
        this.fuel = fuel;
    }
}

public class Main {
    static BufferedReader br;
    static BufferedWriter bw;
    static StringBuilder sb;

    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));
        int N = Integer.parseInt(br.readLine()); // 주유소 개수
        
        // 정렬을 새로 정의하여 거리가 가까운 순서로 주유소를 입력받아 정렬
        PriorityQueue<Node> stations = new PriorityQueue<Node>(new Comparator<Node>() {
            @Override
            public int compare(Node o1, Node o2) {
                return o1.dist - o2.dist; // 거리 오름차순
            }
        });
        
        // 앞으로 들어올 방문한 주유소 목록을 넣을 수 있는 가스가 큰 순서로 정렬
        PriorityQueue<Node> gas = new PriorityQueue<Node>(new Comparator<Node>() {
            @Override
            public int compare(Node o1, Node o2) {
                return o2.fuel - o1.fuel; // 연료량 내림차순
            }
        });
        
        StringTokenizer st;
        // 주유소 정보 입력
        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine());
            stations.add(new Node(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken())));
        }
        st = new StringTokenizer(br.readLine());
        int L = Integer.parseInt(st.nextToken()), P = Integer.parseInt(st.nextToken()); // L: 목적지 거리, P: 현재 연료

        int count = 0; // 주유소 방문 횟수
        // P가 현재 연료이므로 연료량이 L이 넘거나 같을 때까지 반복
        while (P < L) {
            // 현재 연료로 접근 가능한 주유소 목록에 주유소를 추가
            while (!stations.isEmpty() && stations.peek().dist <= P) {
                Node n = stations.poll();
                gas.add(n);
            }
            // 연료(P)로 목표점(L)까지 가지 못했는데 접근 가능한 주유소가 없을 경우 도착할 수 없으므로 -1 출력
            if (gas.isEmpty()) {
                count = -1;
                break;
            }
            // 현재 연료량에 접근 가능한 주유소 중 가장 많은 양의 기름을 넣어줌
            P += gas.poll().fuel;
            count++;
        }
        bw.write(count + "");
        bw.flush();
    }
}
```
9:Td23,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/11000)

<div className="text-center"><a href="https://www.acmicpc.net/problem/11000">https://www.acmicpc.net/problem/11000</a></div>

---

- 강의 시간을 정렬하여 넣는데 빠른 강의가 앞에 오도록 넣는다.
- 시간표 큐의 가장 앞 강의가 넣으려는 시간보다 늦다면 끝났다는 의미이므로 빼버리고 그렇지 않다면 강의중이므로 새 강의를 넣어 큐의 크기(강의실)을 늘린다.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

/**
 * 강의실 배정 문제 해결
 * 모든 강의를 진행하기 위해 필요한 최소 강의실 개수를 구하는 문제
 * 그리디 알고리즘과 우선순위 큐를 사용
 */

/**
 * 강의를 나타내는 클래스
 * 시작 시간과 종료 시간을 저장
 */
class Node implements Comparable<Node> {
    int start, end; // 수업의 시작시간과 끝시간

    public Node(int start, int end) {
        this.start = start;
        this.end = end;
    }

    /**
     * 정렬 기준: 시작 시간이 빠른 순서, 같으면 종료 시간이 빠른 순서
     */
    @Override
    public int compareTo(Node o) {
        // 시작 시간이 같을 경우 종료 시간이 짧은 강의가 앞에 오도록 함
        if (this.start == o.start)
            return this.end - o.end;
        // 시작 시간이 빠른 강의가 앞으로 오도록 설정
        return this.start - o.start;
    }
}

public class Main {
    static BufferedReader br;
    static BufferedWriter bw;

    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int N = Integer.parseInt(br.readLine());
        // 강의 예정 시간표 큐 (시작 시간 순으로 정렬)
        PriorityQueue<Node> q = new PriorityQueue<Node>();
        // 강의실 현재 시간표 큐 (각 강의실의 마지막 강의 종료 시간 저장)
        PriorityQueue<Integer> time = new PriorityQueue<Integer>();
        StringTokenizer st;
        
        // 강의 정보 입력
        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine());
            q.add(new Node(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken())));
        }

        // 첫 수업을 강의실에 배정 (종료 시간 저장)
        time.add(q.poll().end);

        while (!q.isEmpty()) {
            // 다음 수업을 꺼내 비교
            Node n = q.poll();
            // 시간표의 가장 앞 시간(가장 빨리 끝나는 강의)이 현재 강의 시작 시간보다 이전이면
            // 그 강의실을 재사용할 수 있으므로 큐에서 제거
            if (time.peek() <= n.start)
                time.poll();
            // 현재 강의를 강의실에 배정 (종료 시간 추가)
            time.add(n.end);
        }
        // 강의 시간표 큐의 사이즈가 필요한 강의실의 개수가 됨
        bw.write(time.size() + "");
        bw.flush();
    }
}


```
a:T8ea,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/11286)

<div className="text-center"><a href="https://www.acmicpc.net/problem/11286">https://www.acmicpc.net/problem/11286</a></div>

---

- N개의 숫자를 입력받고 숫자가 0일 경우 절댓값이 가장 작은 값을 출력한다.
- PriorityQueue에서 절대값이 작은경우 앞으로 가도록 하고 나중에 입력받은 값이 뒤로 가도록 정렬한다.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.Comparator;
import java.util.PriorityQueue;

/**
 * 절댓값 힙 문제 해결
 * 절댓값이 가장 작은 값을 출력하는 힙 구현
 * 절댓값이 같으면 실제 값이 작은 것을 우선
 */
public class Main {
    static BufferedReader br;
    static BufferedWriter bw;
    static StringBuilder sb;

    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int N = Integer.parseInt(br.readLine()); // 연산 개수
        
        // 커스텀 정렬을 사용하는 우선순위 큐
        PriorityQueue<Integer> queue = new PriorityQueue<Integer>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                // 절댓값이 같은 경우 실제 값이 작은 것이 앞으로 (음수가 우선)
                if (Math.abs(o1) == Math.abs(o2)) {
                    return o1 - o2; // 실제 값 비교
                }
                // 절댓값이 더 작은 것이 앞으로
                return Math.abs(o1) - Math.abs(o2);
            }
        });
        
        for (int i = 0; i < N; i++) {
            int t = Integer.parseInt(br.readLine());
            if (t == 0) {
                // 0이면 절댓값이 가장 작은 값 출력
                Integer max = queue.poll();
                bw.write((max == null ? 0 : max) + "\n");
            } else
                queue.add(t); // 0이 아니면 큐에 추가
        }
        bw.flush();
    }
}

```
b:T76c,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/11279)

<div className="text-center"><a href="https://www.acmicpc.net/problem/11279">https://www.acmicpc.net/problem/11279</a></div>

---

- N개 숫자를 받고 0일 경우 가장 큰 값을 출력한다.
- 자바의 PriorityQueue를 역정렬 시켜서 나오게 만든다.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.Collections;
import java.util.PriorityQueue;

/**
 * 최대 힙 문제 해결
 * 최대 힙을 구현하는 문제
 * PriorityQueue를 역순으로 정렬하여 최대값이 먼저 나오도록 함
 */
public class Main {
    static BufferedReader br;
    static BufferedWriter bw;
    static StringBuilder sb;

    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int N = Integer.parseInt(br.readLine()); // 연산 개수
        
        // PriorityQueue를 역순으로 정렬하여 가장 큰 수가 앞으로 오도록 설정
        PriorityQueue<Integer> queue = new PriorityQueue<Integer>(Collections.reverseOrder());
        
        for (int i = 0; i < N; i++) {
            int t = Integer.parseInt(br.readLine());
            // 입력받은 값이 0일 경우 Queue에서 가장 큰 값을 출력
            if (t == 0) {
                Integer max = queue.poll(); // 최대값 제거 및 반환
                // 큐가 비어있으면 0 출력, 아니면 최대값 출력
                bw.write((max == null ? 0 : max) + "\n");
            } else
                queue.add(t); // 0이 아니면 큐에 추가
        }
        bw.flush();
    }

}


```
c:Ta13,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/13305)

<div className="text-center"><a href="https://www.acmicpc.net/problem/13305">https://www.acmicpc.net/problem/13305</a></div>

---

- 어쨋거나 도착할 수 있다.
- 기름을 넣어서 이동하는게 아니라 기름을 꿔서 움직인다고 생각하자.
- 일단 이동을 하고 이전 주유소의 가격이 더 쌀 경우 그 가격으로 사는거다.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.Arrays;
import java.util.Comparator;
import java.util.StringTokenizer;

/**
 * 주유소 문제 해결
 * 각 도시의 주유소 가격이 다를 때, 목적지까지 가는 최소 비용을 구하는 문제
 * 그리디 알고리즘: 지금까지 지나온 주유소 중 가장 저렴한 가격으로 기름을 구매
 */
public class Main {
    static BufferedReader br;
    static BufferedWriter bw;
    static StringBuilder sb;

    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));
        
        // 주유소 개수
        int N = Integer.parseInt(br.readLine());
        // 주유소 간의 거리 distance, 각 주유소의 비용을 cost로 선언
        long[] distance = new long[N - 1], cost = new long[N];
        StringTokenizer st = new StringTokenizer(br.readLine());
        
        // 도시 간 거리 입력
        for (int i = 0; i < N - 1; i++) {
            distance[i] = Long.parseLong(st.nextToken());
        }
        
        // 각 도시의 주유소 가격 입력
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < N; i++) {
            cost[i] = Long.parseLong(st.nextToken());
        }

        // 총비용 sum, 지금까지 지나온 주유소 중 최소 비용을 min_cost로 선언
        // 처음에는 출발지의 주유소 가격을 사용
        long sum = 0, min_cost = cost[0];

        for (int i = 0; i < N - 1; i++) {
            // 주유소 간 비용을 비교하여 더 쌀 경우 min_cost 업데이트
            if (cost[i] < min_cost)
                min_cost = cost[i];
            // 최소 비용으로 다음 도시까지 가는 거리만큼 기름 구매
            sum += min_cost * distance[i];
        }

        bw.write(sum + "");
        bw.flush();
    }

}
```
d:Tdf0,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1931)

<div className="text-center"><a href="https://www.acmicpc.net/problem/1931">https://www.acmicpc.net/problem/1931</a></div>

---

- 회의 끝나는 시간을 기준으로 정렬한다.
- 끝나는 시간이 같을 경우 더 늦게 시작하여 회의시간이 짧은 경우를 넣는다.
- 그림으로 다른분께서 보기 좋게 정리해주셨다.(https://st-lab.tistory.com/145)
  ![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcewRBZ%2FbtqJ92Ggx03%2F1lekgEQnnITL75Kcls4M0k%2Fimg.png)
- 처음 입력된 회의 시간 목록이다.
  ![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FkWMC8%2FbtqJ3iJ7hIS%2FGteyzJuATQuqKajK9Qj0Qk%2Fimg.png)
- 위의 조건으로 정렬한 그림이다. 여기서 앞에 회의시간을 넣고 앞 시간의 끝시간과 다음 시간의 시작시간이 겹치지 않는것을 이어준다.
  ![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FculRjv%2FbtqKfp2amld%2FfRbwvDQgtpsTrYejNECQk1%2Fimg.png)

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.Arrays;
import java.util.Comparator;
import java.util.StringTokenizer;

/**
 * 회의실 배정 문제 해결
 * 회의실을 사용할 수 있는 최대 회의 개수를 구하는 문제
 * 그리디 알고리즘: 끝나는 시간이 빠른 회의부터 선택
 */
public class Main {
    static BufferedReader br;
    static BufferedWriter bw;
    static StringBuilder sb;

    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));
        
        // 회의실 시간 개수 t와 횟수 count 선언
        int t = Integer.parseInt(br.readLine()), count = 0;
        // 요청 시간표를 입력하는 ar 선언
        int[][] ar = new int[t][];
        
        // 회의 시간 입력
        for (int i = 0; i < t; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken()), b = Integer.parseInt(st.nextToken());
            ar[i] = new int[] { a, b }; // [시작 시간, 끝 시간]
        }
        
        // 요청 시간표를 끝 시간으로 오름차순 정렬하고 같을 경우는 시작 시간이 늦은 것으로 정렬
        Arrays.sort(ar, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                if (o1[1] == o2[1]) {
                    return o1[0] - o2[0]; // 끝 시간이 같으면 시작 시간 오름차순
                }
                return o1[1] - o2[1]; // 끝 시간 오름차순
            }
        });

        // 직전 시간을 기록해줄 변수 prev_time 시작 시간은 0부터 시작
        int prev_time = 0;

        for (int i = 0; i < t; i++) {
            // 꺼낸 시간이 이전 타임 끝 시간과 같거나 늦을 경우 (겹치지 않음)
            if (prev_time <= ar[i][0]) {
                // 다음 타임 끝 시간을 넣어주고 카운트를 증가시킴
                prev_time = ar[i][1];
                count++;
            }
        }
        bw.write(count + "");
        bw.flush();
    }

}
```
e:T1d6e,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/13460)

<div className="text-center"><a href="https://www.acmicpc.net/problem/13460">https://www.acmicpc.net/problem/13460</a></div>

---

- 구슬이 어딘가 부딛힐때까지 움직인다.
- 빨간 구슬과 파란 구슬은 겹쳐지지 않는다.
- 파란 구슬과 빨간 구슬이 같은 방향으로 동시에 빠질 경우 실패.
- 파란 구슬이 먼저 빠져도 안된다.
- 10번 이내 해야하고 그러지 못 할 경우 -1을 출력.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

/**
 * 구슬 탈출 2 문제 해결
 * BFS를 사용하여 최소 이동 횟수를 찾는 문제
 * 빨간 구슬만 구멍에 빠뜨리는 최소 횟수를 구함
 */
public class Main {
    static BufferedReader br;
    static BufferedWriter bw;

    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken()), m = Integer.parseInt(st.nextToken());
        char[][] map = new char[n][m];
        
        // 상태를 담아서 전달할 배열 status
        // 0,1 = 빨간 구슬 y,x 좌표 | 2,3 = 파란 구슬 y,x 좌표 | 4 = 이동횟수
        int[] status = new int[5];
        
        // 빨간구슬위치[][] 파란구슬위치[][]에 온적이 있는지 체크할 목록
        // 4차원 배열로 두 구슬의 위치 조합을 모두 체크
        boolean[][][][] visited = new boolean[n][m][n][m];
        // 맵 정보를 입력받고 구슬의 초기 위치를 저장
        for (int i = 0; i < n; i++) {
            char[] input = br.readLine().toCharArray();
            for (int j = 0; j < m; j++) {
                char c = input[j];
                map[i][j] = c;
                // 구슬의 위치는 따로 저장해놓고 지도 상에는 .으로 표기
                // (구슬은 이동하므로 맵에는 표시하지 않음)
                if (c == 'R') {
                    status[0] = i;
                    status[1] = j;
                    map[i][j] = '.';
                } else if (c == 'B') {
                    status[2] = i;
                    status[3] = j;
                    map[i][j] = '.';
                }
            }
        }

        // BFS를 위한 큐 초기화 및 시작 상태 추가
        Queue<int[]> queue = new LinkedList<int[]>();
        queue.add(status);

        // 상하좌우 4방향 이동 좌표 (아래, 위, 오른쪽, 왼쪽)
        int[][] directions = new int[][] { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };
        
        // BFS 탐색: 큐가 빌 때까지 반복
        while (!queue.isEmpty()) {
            status = queue.remove();

            // 10번 이상 움직일 경우 -1 출력을 위해 status[4]에 -1을 대입하고 while종료
            if (status[4] > 10) {
                status[4] = -1;
                break;
            }

            // 파란구슬이 빠진 경우 (파란구슬이 먼저 빠짐, 파란구슬과 빨간구슬이 동시에 빠짐)
            // 이 경우는 실패이므로 큐에 더 넣지 않고 생략
            if (map[status[2]][status[3]] == 'O')
                continue;
            // 빨간 구슬만 빠진 경우 성공이므로 while 종료
            else if (map[status[0]][status[1]] == 'O')
                break;


            // 4방향 탐색 (상하좌우)
            for (int j = 0; j < 4; j++) {
                int[] dir = directions[j];
                
                // 빨간 구슬을 현재 방향으로 굴리기
                // 구슬의 현재 위치를 복사
                int[] cur_red = new int[] { status[0], status[1] };
                // 구슬이 구멍에 빠지거나 벽에 부딪힐 때까지 이동
                while (true) {
                    cur_red[0] += dir[0];
                    cur_red[1] += dir[1];
                    if (map[cur_red[0]][cur_red[1]] == 'O' || map[cur_red[0]][cur_red[1]] == '#')
                        break;
                }
                // 벽 위치로 간 경우 한 칸 뒤로 되돌림 (벽 앞에 멈춤)
                if (map[cur_red[0]][cur_red[1]] == '#') {
                    cur_red[0] -= dir[0];
                    cur_red[1] -= dir[1];
                }
                
                // 파란 구슬도 같은 방향으로 굴리기
                int[] cur_blue = new int[] { status[2], status[3] };
                while (true) {
                    int next_y = cur_blue[0] + dir[0], next_x = cur_blue[1] + dir[1];
                    cur_blue[0] = next_y;
                    cur_blue[1] = next_x;
                    if (map[next_y][next_x] == 'O' || map[next_y][next_x] == '#')
                        break;
                }
                // 벽에 부딪힌 경우 한 칸 뒤로 되돌림
                if (map[cur_blue[0]][cur_blue[1]] == '#') {
                    cur_blue[0] -= dir[0];
                    cur_blue[1] -= dir[1];
                }

                // 빨간 구슬과 파란 구슬이 같은 위치에 도달하였으나 구멍이 아닌 경우
                // 두 구슬은 겹칠 수 없으므로, 더 멀리서 온 구슬을 한 칸 뒤로 이동시킴
                if (cur_blue[0] == cur_red[0] && cur_blue[1] == cur_red[1] && map[cur_red[0]][cur_red[1]] != 'O') {
                    // 두 구슬이 이동한 거리를 계산하여 더 멀리서 온 구슬이 나중에 온 것이므로 그 전 칸으로 조정
                    int red_dis = Math.abs(status[0] - cur_red[0]) + Math.abs(status[1] - cur_red[1]);
                    int blue_dis = Math.abs(status[2] - cur_blue[0]) + Math.abs(status[3] - cur_blue[1]);
                    if (red_dis > blue_dis) {
                        // 빨간 구슬이 더 멀리서 왔으므로 한 칸 뒤로
                        cur_red[0] -= dir[0];
                        cur_red[1] -= dir[1];
                    } else {
                        // 파란 구슬이 더 멀리서 왔으므로 한 칸 뒤로
                        cur_blue[0] -= dir[0];
                        cur_blue[1] -= dir[1];
                    }
                }
                
                // 현재 구슬들의 위치 조합이 방문한 적이 있는지 확인
                // 이미 탐색한 경우 중복 탐색을 방지하기 위해 큐에 추가하지 않음
                if (!visited[cur_red[0]][cur_red[1]][cur_blue[0]][cur_blue[1]]) {
                    visited[cur_red[0]][cur_red[1]][cur_blue[0]][cur_blue[1]] = true;
                    // 이동 횟수를 1 증가시켜서 큐에 추가
                    queue.add(new int[] { cur_red[0], cur_red[1], cur_blue[0], cur_blue[1], status[4] + 1 });
                }
            }
        }

        // 탐색을 마쳤는데 빨간 구슬만 빠진 경우 이동 횟수 출력, 그 외의 경우 -1 출력
        // (파란 구슬이 빠지지 않았고 빨간 구슬만 빠진 경우 성공)
        bw.write((map[status[2]][status[3]] != 'O' && map[status[0]][status[1]] == 'O'? status[4]:-1) + "");
        bw.flush();
    }
}
```
f:Tea2,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/7562)

<div className="text-center"><a href="https://www.acmicpc.net/problem/7562">https://www.acmicpc.net/problem/7562</a></div>

---

- 큐를 이용해 탐색할 작업을 돈다.
- 처음 도착한 값이 최소 값이므로 break.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;

/**
 * 나이트의 이동 문제 해결
 * 체스판에서 나이트가 시작 위치에서 목표 위치까지 가는 최소 이동 횟수를 구하는 문제
 * BFS를 사용하여 최단 경로 탐색
 */
class Main {
    static BufferedReader br;
    static BufferedWriter bw;

    // 이동 가능한 방위 좌표를 정함 (나이트는 8방향으로 이동 가능)
    static int[][] direction = new int[][] { { -2, 1 }, { -1, 2 }, { 1, 2 }, { 2, 1 }, { 2, -1 }, { 1, -2 }, { -1, -2 },
            { -2, -1 } };

    public static void main(String[] args) throws java.lang.Exception {
        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));

        // 테스트케이스 개수
        int t = Integer.parseInt(br.readLine());
        while (t-- > 0) {
            // 테스트케이스마다 초기화
            Queue<int[]> q = new LinkedList<int[]>();
            // 체스판 한 변의 길이
            int l = Integer.parseInt(br.readLine());
            // 접근 숫자를 저장해줄 int 배열 (이동 횟수 저장)
            int[][] count = new int[l][l];
            // 시작위치 pos, 도착위치 dest, 현재위치 cur를 선언
            int[] pos = Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray(),
                    dest = Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray(),
                    cur = new int[2];

            // -1일 경우는 방문하지 않았다는 의미를 줌
            for (int i = 0; i < l; i++) {
                Arrays.fill(count[i], -1);
            }

            // 시작위치는 0부터 시작
            count[pos[0]][pos[1]] = 0;
            // 탐색 작업을 위해 큐에 넣어줌
            q.add(pos);

            // 더 이상 탐색할 일이 없을 때까지 반복
            while (!q.isEmpty()) {
                // 탐색할 현재 위치를 꺼내서 cur에 대입
                cur = q.remove();
                // 목적지에 도착했다면 break (BFS이므로 처음 도착한 것이 최단 경로)
                if (cur[0] == dest[0] && cur[1] == dest[1])
                    break;

                // 각 방향을 하나씩 꺼내서 확인
                for (int[] dir : direction) {
                    int x = cur[0] + dir[0], y = cur[1] + dir[1];
                    // x,y가 체스판을 벗어나지 않는 범위 내에서 실행
                    if (x >= 0 && x < l && y >= 0 && y < l) {
                        // 방문한 적 없는 위치라면
                        if (count[x][y] == -1) {
                            // 이전 위치 값에서 1을 늘려 입력하고
                            count[x][y] = count[cur[0]][cur[1]] + 1;
                            // 큐에 다음 탐색할 위치로 저장
                            q.add(new int[] { x, y });
                        }
                    }
                }
            }
            // 도착한 위치의 카운트 값 출력
            bw.write(count[cur[0]][cur[1]] + (t == 0 ? "" : "\n"));
        }
        bw.flush();
    }
}
```
10:Tb67,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/11724)

<div className="text-center"><a href="https://www.acmicpc.net/problem/11724">https://www.acmicpc.net/problem/11724</a></div>

---

- 방향이 없는 서로 연결된 노드 덩어리의 갯수를 세는 문제다.
- 방문한 적이 없는 자식 노드까지 탐색을 돌면 된다.

---

```java

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.StringTokenizer;

/**
 * 연결 요소의 개수 문제 해결
 * 무방향 그래프에서 연결된 노드 그룹의 개수를 구하는 문제
 * DFS를 사용하여 각 연결 요소를 탐색
 */
class Main {
    static BufferedReader br;
    static BufferedWriter bw;

    static boolean[] visited; // 방문 기록을 위한 변수
    static boolean[][] node; // 인접 행렬: node[i][j]가 true면 i와 j가 연결됨
    static int n, m; // 정점의 개수 n, 간선의 개수 m

    public static void main(String[] args) throws java.lang.Exception {
        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st = new StringTokenizer(br.readLine());
        
        // 값 입력
        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        int count = 0; // 연결 요소의 개수
        node = new boolean[n + 1][n + 1];
        visited = new boolean[n + 1];
        
        // 간선 정보 입력 (무방향 그래프)
        for (int i = 0; i < m; i++) {
            st = new StringTokenizer(br.readLine());
            int parent = Integer.parseInt(st.nextToken()), child = Integer.parseInt(st.nextToken());
            node[parent][child] = true;
            node[child][parent] = true; // 무방향이므로 양방향으로 연결
        }

        // 방문 기록을 1부터 탐색 시작
        for (int i = 1; i <= n; i++) {
            if (!visited[i]) {
                dfs(i); // 연결된 모든 노드 탐색
                count++; // 새로운 연결 요소 발견
            }
        }
        bw.write(count+"");
        bw.flush();
    }

    /**
     * DFS를 사용하여 연결된 모든 노드를 탐색
     * @param num: 현재 탐색할 정점 번호
     */
    public static void dfs(int num) {
        // 받아온 숫자가 방문한 적이 있다면 종료
        if (visited[num])
            return;

        // 방문한 적이 없다면 기록을 남김
        visited[num] = true;
        
        // 현재 노드와 연결된 모든 노드를 탐색
        for (int i = 1; i <= n; i++) {
            // 현재 숫자와 연결된 노드를 방문한 적이 있는지 탐색
            if (node[num][i])
                dfs(i);
        }
    }
}

```
11:T1056,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/14888)

<div className="text-center"><a href="https://www.acmicpc.net/problem/14888">https://www.acmicpc.net/problem/14888</a></div>

---

- 연산자의 갯수가 주어지고 주어진 숫자 배열에 끼워 넣어 만든 값의 최대,최소 값을 출력하는 문제
- 연산자 하나 끼워서 계산해보고 다시 빼서 다른거 끼워보며 연산을 하는 과정으로 생각하면 편하다.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.StringTokenizer;

/**
 * 연산자 끼워넣기 문제 해결
 * 주어진 숫자 배열에 연산자를 끼워넣어 만들 수 있는 최대값과 최소값을 구하는 문제
 * 백트래킹을 사용하여 모든 경우의 수를 탐색
 */
class Main {
    static BufferedReader br;
    static BufferedWriter bw;
    // DFS를 쓰기 위해 크기(n), 최소값(min), 최대값(max)를 전역 변수로 선언
    // max는 비교하여 넣기 위해 int의 최소값을, min은 비교하여 최소 값이 들어가야하므로 최대값을 미리 넣어놓음
    static int n, min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;
    // 숫자배열(numbers), 연산자(oper)는 +,-,*,/ 순서로 개수가 주어지므로 길이가 4인 배열을 선언
    static int[] numbers, oper = new int[4];

    public static void main(String[] args) throws java.lang.Exception {
        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));

        n = Integer.parseInt(br.readLine());
        // 숫자 배열을 문자열 한 줄로 입력 받아 띄어쓰기로 분리해주는 StringTokenizer에 담아 하나씩 꺼내씀
        StringTokenizer st = new StringTokenizer(br.readLine());
        numbers = new int[n];
        for (int i = 0; i < n; i++)
            numbers[i] = Integer.parseInt(st.nextToken());

        // 연산자도 위와 같은 방법을 사용
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < 4; i++)
            oper[i] = Integer.parseInt(st.nextToken());

        // 첫 번째 숫자와 숫자 하나를 사용했으므로 다음 값을 찾기 위해 인덱스를 하나 늘려서 1로 전달
        dfs(numbers[0], 1);
        System.out.println(max + "\n" + min);
    }

    /**
     * 백트래킹을 사용하여 모든 연산자 조합을 탐색
     * @param num: 현재까지 계산된 값
     * @param index: 다음에 사용할 숫자의 인덱스
     */
    public static void dfs(int num, int index) {
        // 전달 받은 인덱스값이 n과 같다는 것은 배열의 범위보다 1 크므로 모든 배열을 탐색했다는 의미
        // 연산이 끝났으므로 값을 최소 최대를 비교하여 넣고 함수를 끝냄
        if (index == n) {
            min = min > num ? num : min;
            max = max < num ? num : max;
            return;
        }

        // 연산자 4개 반복 (+,-,*,/)
        for (int i = 0; i < 4; i++) {
            // 주어진 연산자 개수가 있다면
            if (oper[i] > 0) {
                // 꺼내쓰므로 -1 함
                oper[i]--;
                // 연산자에 따라 탐색을 달리하고 다음 숫자를 꺼내기 위해 index+1을 함
                switch (i) {
                    case 0: // 덧셈
                        dfs(num + numbers[index], index + 1);
                        break;
                    case 1: // 뺄셈
                        dfs(num - numbers[index], index + 1);
                        break;
                    case 2: // 곱셈
                        dfs(num * numbers[index], index + 1);
                        break;
                    case 3: // 나눗셈
                        dfs(num / numbers[index], index + 1);
                        break;
                }
                // 위의 연산이 끝났다면 사용한 연산자를 돌려줌 (백트래킹)
                oper[i]++;
            }
        }

    }

}
```
12:T1b60,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/5430)

<div className="text-center"><a href="https://www.acmicpc.net/problem/5430">https://www.acmicpc.net/problem/5430</a></div>

---

- 문제 자체는 단순하다. 명령대로 R일 경우 순서를 뒤집고, D일 경우 앞에서 하나를 빼준다.
- 하지만 일일히 뒤집으면 시간이 오래 걸리므로 인덱스 left,right를 선언하여 한칸씩 움직여봤다.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

/**
 * AC 문제 해결 (방법 1 - 인덱스 사용)
 * R(뒤집기)과 D(삭제) 명령을 처리하는 문제
 * 실제로 배열을 뒤집지 않고 인덱스로 처리하여 효율성 향상
 */
class Main {
    static BufferedReader br;
    static BufferedWriter bw;
    static int target, n, min = Integer.MAX_VALUE;

    public static void main(String[] args) throws java.lang.Exception {
        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));
        // 결과를 위한 StringBuilder
        StringBuilder sb = new StringBuilder();
        // TestCase
        int T = Integer.parseInt(br.readLine());

        for (int i = 0; i < T; i++) {
            // String.charAt() 보다 char[] 탐색이 빨라서 변경
            char[] cmds = br.readLine().toCharArray();
            // 배열의 길이
            int len = Integer.parseInt(br.readLine());
            // 오른쪽 인덱스는 배열의 길이보다 하나 작게
            int right = len - 1;
            // 왼쪽 인덱스는 0부터
            int left = 0;

            // 배열 입력
            String ar = br.readLine();
            // 앞뒤의 []을 제거해줌
            ar = ar.substring(1, ar.length() - 1);
            // , 기준으로 배열로 변환
            String[] arr = ar.split(",");

            // 에러나지 않고 내용물을 출력해주는 신호 print_flag와 R명령어 인식을 위한 reverse_flag 선언
            boolean print_flag = true, reverse_flag = false;

            // 커맨드 배열에서 하나씩 꺼내서 실행
            for (char cmd : cmds) {
                if (cmd == 'R') { 
                    // 명령어 R일 경우 배열을 뒤집어야 하지만 그냥 인덱스 처리만 뒤집기 위한 reverse_flag 조작
                    reverse_flag = !reverse_flag;
                } else if (cmd == 'D') { 
                    // 명령어 D일 경우
                    // R이 안나왔다면 맨 앞 값을 제거해야하지만 left 인덱스 증가
                    if (!reverse_flag)
                        left++;
                    // R이 나왔다면 맨 뒤 값을 제거해야하지만 right 인덱스를 감소
                    else
                        right--;

                    // 만약 left 인덱스가 right + 1한 값보다 크다면 에러, +1 한 이유는 빈 배열도 출력해야함
                    if (left > right + 1) {
                        sb.append("error\n");
                        print_flag = false;
                        break;
                    }
                }
            }
            // 출력
            if (print_flag) {
                sb.append('[');
                // 인덱스 증가를 뒤집어졌다면 1씩 내려가고 아니라면 1씩 올라가면서 출력
                int step = 1;
                if (reverse_flag) {
                    step *= -1;
                }

                // 시작 인덱스는 뒤집어졌다면 right 아니면 left부터 시작
                // 인덱스 범위는 left와 right 안에 있음
                for (int index = (reverse_flag ? right : left); index <= right && index >= left; index += step) {
                    sb.append(arr[index] + (index != (reverse_flag ? left : right) ? "," : ""));
                }
                sb.append("]\n");
            }
        }

        // 완성된 String 출력
        bw.write(sb.toString());
        bw.flush();
    }
}
```

---

- 위와 같이 푸는 방식도 있지만 java에는 Deque 클래스가 있으므로 일일히 구현할 필요 없이 이미 구현된 클래스를 사용하여도 된다.

```java
/**
 * AC 문제 해결 (방법 2 - Deque 사용)
 * R(뒤집기)과 D(삭제) 명령을 처리하는 문제
 * Java의 Deque 클래스를 사용하여 간단하게 구현
 */
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.Deque;
import java.util.LinkedList;

class Main {
    static BufferedReader br;
    static BufferedWriter bw;

    public static void main(String[] args) throws java.lang.Exception {
        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringBuilder sb = new StringBuilder();
        int T = Integer.parseInt(br.readLine());

        for (int i = 0; i < T; i++) {
            char[] cmds = br.readLine().toCharArray();
            int len = Integer.parseInt(br.readLine());
            
            String ar = br.readLine();
            ar = ar.substring(1, ar.length() - 1);
            String[] arr = ar.split(",");
            
            // Deque를 선언하여 값을 하나씩 넣어줌
            Deque dq = new LinkedList();
            for (int j = 0; j < len; j++) {
                dq.add(Integer.parseInt(arr[j]));
            }

            boolean print_flag = true, reverse_flag = false;
            for (char cmd : cmds) {
                if (cmd == 'R') {
                    reverse_flag = !reverse_flag;
                } else if (cmd == 'D') {
                    // Deque가 비어있는데 삭제를 요청했으므로 에러를 출력하고 반복문을 종료
                    if (dq.isEmpty()) {
                        sb.append("error\n");
                        print_flag = false;
                        break;
                    }

                    // Deque가 그대로라면 앞에서 삭제
                    if (!reverse_flag)
                        dq.removeFirst();
                    // Deque가 뒤집어졌다면 뒤에서 삭제
                    else
                        dq.removeLast();
                }
            }
            if (print_flag) {
                sb.append("[");
                // Deque가 빌 때까지 반복
                while (!dq.isEmpty()) {
                    // reverse_flag가 true면 뒤에서 하나씩 꺼내고 false라면 앞에서 하나씩 꺼내어 문장에 붙임
                    sb.append((reverse_flag ? dq.pollLast() : dq.pollFirst()) + (dq.isEmpty() ? "" : ","));
                }
                sb.append("]\n");
            }
        }
        
        bw.write(sb.toString());
        bw.flush();
    }
}
13:Ta67,
[![프로그래머스](https://file.newswire.co.kr/data/datafile2/thumb_640/2021/06/1993996598_20210610150326_5364622170.jpg)](https://programmers.co.kr/learn/courses/30/lessons/42585)

<div className="text-center"><a href="https://programmers.co.kr/learn/courses/30/lessons/42585">https://programmers.co.kr/learn/courses/30/lessons/42585</a></div>

---

- 주어진 숫자를 붙여 가며 사칙연산을 통과시켜 값을 확인한다.
- N이 1부터 9이하로 주어지니 반복횟수를 맞추기 위해 0부터 8로한다.
- 처음 식은 5가 주어지고 사칙연산을 붙일 수 없으니 카운트 1부터 사칙연산으로 나눠진다.
- 그런식으로 각 dfs들이 목표 숫자에 도달했을때 최소 값인지 비교하여 대입한다.

```java
/**
 * N으로 표현 문제 해결
 * 숫자 N을 사용하여 목표 숫자를 만드는 최소 사용 횟수를 구하는 문제
 * DFS를 사용하여 모든 경우의 수를 탐색
 */
class Solution {
    // target과 써야하는 숫자 n을 함수 호출시 매개변수가 늘어나므로 매개변수로 쓰기보다 전역변수로 빼 놓음
    int target,n,min=Integer.MAX_VALUE;

    public int solution(int N, int number) {
        target = number;
        n = N;
        // 0부터 시작 (사용 횟수, 현재 값)
        dfs(0, 0);
        return min == Integer.MAX_VALUE ? -1 : min;
    }

    /**
     * DFS를 사용하여 모든 경우의 수를 탐색
     * @param count: 현재까지 사용한 N의 개수
     * @param num: 현재까지 만든 숫자
     */
    public void dfs(int count, int num) {
        // count는 0부터 8로 9번, 그보다 크면 -1을 돌려줌
        if (count > 8) {
            min = -1;
            return;
        }
        // 생성된 숫자가 목표 값일 경우
        if (num == target) {
            // 기존의 목표 생성까지 최소 카운트 값과 비교하여 더 작을 경우 min에 대입
            min = min<count?min:count;
            return;
        }

        int tempN = n;
        // 현재 카운트에서 8까지 접근할 만큼 dfs를 반복
        // N, NN, NNN... 형태로 숫자를 만들 수 있음
        for (int i = 0; i < 8 - count; i++) {
            int newCount = count + i + 1; // N을 i+1개 사용
            // 사칙연산을 수행
            dfs(newCount, num + tempN);
            dfs(newCount, num - tempN);
            dfs(newCount, num * tempN);
            dfs(newCount, num / tempN);

            // 현재 만든 숫자를 한 칸 앞으로 밀고 n을 추가하여 숫자를 만듦 (N -> NN -> NNN...)
            tempN = tempN * 10 + n;
        }
    }
}
```
14:T618,
[![프로그래머스](https://file.newswire.co.kr/data/datafile2/thumb_640/2021/06/1993996598_20210610150326_5364622170.jpg)](https://programmers.co.kr/learn/courses/30/lessons/43105)

## <div className="text-center"><a href="https://programmers.co.kr/learn/courses/30/lessons/43105">https://programmers.co.kr/learn/courses/30/lessons/43105</a></div>

- 삼각형의 밑바닥부터 훑고 올라간다.
- 맨 밑 우측 끝의 두값을 비교해서 위에 칸에 더해준다.
- 최대 값은 자연스럽게 0,0에 들어가게 된다.

```java
/**
 * 정수 삼각형 문제 해결
 * 삼각형의 꼭대기에서 바닥까지 내려올 때, 거쳐간 숫자의 합이 최대가 되는 경로를 찾는 문제
 * 다이나믹 프로그래밍: 아래에서 위로 올라가며 최대값 계산
 */
class Solution {
    public int solution(int[][] triangle) {
        int len = triangle.length;
        int[][] dp = new int[len][len]; // dp[i][j]: i행 j열까지의 최대 합
        
        // 맨 밑바닥은 그대로 초기화
        dp[len - 1] = triangle[len - 1];
        
        // 삼각형의 밑바닥부터 위로 올라가며 최대값 계산
        for (int i = len - 2; i >= 0; i--) {
            for (int j = i; j >= 0; j--) {
                // 아래 행의 두 값 중 큰 값을 선택하여 현재 값과 더함
                dp[i][j] = Math.max(dp[i + 1][j], dp[i + 1][j + 1]) + triangle[i][j];
            }
        }

        // 최대값은 자연스럽게 꼭대기(0,0)에 들어감
        return dp[0][0];
    }
}
```
15:T961,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/11729)

<div className="text-center"><a href="https://www.acmicpc.net/problem/11729">https://www.acmicpc.net/problem/11729</a></div>

---

- 규칙

  - 1 2 3 칸이 있고 1에 있는 원판을 3으로 옮겨야한다.
  - 원판은 크기 순서로 쌓여 있는데 큰 원판이 작은원판 위로 갈 수 없다.
  - 1에서 3으로 옮기려는 원판을 놓고
  - 1에서 그 다음 원판을 2에 놓고
  - 3에서 2로 옮긴뒤
  - 2에서 쌓여있는 원판들을 3으로 옮긴다.
  - 반복

- hanoi 함수에서 마지막 원판을 옮기는 것부터 조건을 놓고 그 숫자가 마지막 숫자가 아니라면 그 전의 동작으로 거슬러 올라간다.

---

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;

/**
 * 하노이 탑 이동 순서 문제 해결
 * 하노이 탑을 이동시키는 최소 이동 횟수와 이동 순서를 구하는 문제
 * 재귀를 사용하여 해결
 */
class Main {
    static StringBuilder sb = new StringBuilder(); // 이동 순서를 저장할 문자열
    static int count = 0; // 이동 횟수

    public static void main(String[] args) throws java.lang.Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine()); // 원판 개수
        hanoi(n, 1, 2, 3); // 1번 기둥에서 3번 기둥으로 이동
        System.out.println(count + "\n" + sb);
    }

    /**
     * 하노이 탑 재귀 함수
     * @param n: 이동할 원판 개수
     * @param start: 시작 기둥
     * @param mid: 보조 기둥
     * @param end: 목표 기둥
     */
    public static void hanoi(int n, int start, int mid, int end) {
        count++; // 이동 횟수 증가
        if (n == 1) {
            // 원판이 1개면 바로 이동
            sb.append(start + " " + end + "\n");
        } else {
            // 1단계: n-1개 원판을 시작 기둥에서 보조 기둥으로 이동
            hanoi(n - 1, start, end, mid);
            // 2단계: 가장 큰 원판을 시작 기둥에서 목표 기둥으로 이동
            sb.append(start + " " + end + "\n");
            // 3단계: n-1개 원판을 보조 기둥에서 목표 기둥으로 이동
            hanoi(n - 1, mid, start, end);
        }
    }
}
```
16:T854,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/2579)

<div className="text-center"><a href="https://www.acmicpc.net/problem/2579">https://www.acmicpc.net/problem/2579</a></div>

---

- 계단은 3번 연속 갈 수 없다.
- 고로 현재 칸까지 합은 전전칸까지 합+현재칸 이거나 전전전 칸까지 합+ 전 칸 + 현재 칸 중 큰 것을 넣어준다.

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

/**
 * 계단 오르기 문제 해결
 * 계단을 오를 때 연속으로 3개를 밟을 수 없으므로
 * 다이나믹 프로그래밍을 사용하여 최대 점수를 구함
 */
class Main {
    static int[] dp = new int[300]; // dp[i]: i번째 계단까지의 최대 점수
    static int[] ar = new int[300]; // ar[i]: i번째 계단의 점수

    public static int max(int a, int b) {
        return a > b ? a : b;
    }

    public static void main(String[] args) throws java.lang.Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        int n = Integer.parseInt(br.readLine()); // 계단 개수
        
        // 각 계단의 점수 입력
        for (int i = 0; i < n; i++) {
            ar[i] = Integer.parseInt(br.readLine());
        }

        // 초기값 설정
        dp[0] = ar[0]; // 첫 번째 계단
        dp[1] = max(ar[0] + ar[1], ar[1]); // 두 번째 계단: 0->1 또는 바로 1
        dp[2] = max(ar[0] + ar[2], ar[1] + ar[2]); // 세 번째 계단: 0->2 또는 1->2
        
        // 4번째 계단부터: 연속 3개를 밟을 수 없으므로
        // 경우 1: i-2에서 바로 i로 (dp[i-2] + ar[i])
        // 경우 2: i-3 -> i-1 -> i로 (dp[i-3] + ar[i-1] + ar[i])
        for (int i = 3; i < n; i++)
            dp[i] = max(dp[i - 2], dp[i - 3] + ar[i - 1]) + ar[i];
        
        bw.write(dp[n - 1] + ""); // 마지막 계단까지의 최대 점수
        bw.flush();
    }
}
```
17:T89e,
[![프로그래머스](https://file.newswire.co.kr/data/datafile2/thumb_640/2021/06/1993996598_20210610150326_5364622170.jpg)](https://programmers.co.kr/learn/courses/30/lessons/60058)

<div className="text-center"><a href="https://programmers.co.kr/learn/courses/30/lessons/60058">https://programmers.co.kr/learn/courses/30/lessons/60058</a></div>

- 입력받은 문자열을 완전한 괄호 부분이 있는지 확인한다.
- 앞부분이 완전한 괄호라면 뒤엣 부분을 다시 체크.
- 완전하지 않다면 길이만큼 재구성한다.

```java
/**
 * 괄호 변환 문제 해결
 * 균형잡힌 괄호 문자열을 올바른 괄호 문자열로 변환하는 문제
 * 재귀를 사용하여 문제를 분할하여 해결
 */
class Solution {
    public String solution(String p) {
        // 빈 문자열이면 그대로 반환
        if (p.length() == 0)
            return p;

        String u = "", v = ""; // u: 균형잡힌 괄호 문자열, v: 나머지
        int count = 0; // 괄호 균형 체크
        boolean flag = true; // 올바른 괄호 문자열인지 여부
        
        // 균형잡힌 괄호 문자열 u를 찾음
        for (int i = 0; i < p.length(); i++) {
            if (p.charAt(i) == '(')
                count++;
            else
                count--;

            // ')'가 먼저 나오면 올바른 괄호 문자열이 아님
            if (count < 0)
                flag = false;

            // 균형잡힌 괄호 문자열을 찾음
            else if (count == 0) {
                u = p.substring(0, i + 1);
                v = p.substring(i + 1);
                break;
            }

        }

        // u가 올바른 괄호 문자열이면 v를 재귀적으로 처리
        if (flag)
            return u + solution(v);

        // u가 올바른 괄호 문자열이 아니면 변환 필요
        // 1. '(' + solution(v) + ')'
        String result = "(" + solution(v) + ")";
        // 2. u의 첫 번째와 마지막 문자를 제거하고 나머지 괄호를 뒤집음
        for (int i = 1; i < u.length() - 1; i++) {
            result += u.charAt(i) == '(' ? ")" : "(";
        }

        return result;
    }
}
```
18:T782,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1927)

<div className="text-center"><a href="https://www.acmicpc.net/problem/1927">https://www.acmicpc.net/problem/1927</a></div>

---

- 우선순위 큐를 이용하여 정렬한 수 입력받은 값이 0일 경우 가장 작은 값을 출력하도록 한다.
- 자바의 PriorityQueue를 사용한다.
- 보통 퀵소트 구현을 하던가 하지만 <a href="https://www.joinc.co.kr/w/Site/Test/PqueueVsQsort">어떤 분께서 실험한 글</a>에 따르면 자바 내장 우선순위 큐가 나쁘지 않다고 하니 구현된 것을 사용한다.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.PriorityQueue;

/**
 * 최소 힙 문제 해결
 * 최소 힙을 구현하는 문제
 * PriorityQueue를 사용하여 최소값이 먼저 나오도록 함
 */
class Main {
    public static void main(String[] args) throws java.lang.Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        int n = Integer.parseInt(br.readLine()); // 연산 개수
        
        // 우선순위 큐 선언 (기본적으로 최소 힙)
        PriorityQueue<Integer> q = new PriorityQueue<Integer>();
        
        for (int i = 0; i < n; i++) {
            int temp = Integer.parseInt(br.readLine());
            // 입력 값이 0일 경우 가장 앞으로 정렬된 최소 값을 출력
            if (temp == 0) {
                // 큐에 비어있을 경우 그냥 0을 출력
                bw.write((q.size() == 0 ? 0 : q.poll()) + "\n");
            } else {
                q.add(temp); // 0이 아니면 큐에 추가
            }
        }
        bw.flush();
    }
}
```
19:T961,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/12015)

<div className="text-center"><a href="https://www.acmicpc.net/problem/12015">https://www.acmicpc.net/problem/12015</a></div>

---

- 입력 받는 값을 순차적으로 받는다.
- 받은 값을 결과 배열에서 탐색을 해서 끼워넣거나 새로 넣는다.
- 최대 값보다 큰 경우는 새로 넣는다.
- 그렇지 않은 경우 기존 배열에 탐색해서 적합한 자리를 찾아 새로 갱신한다.

---

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.StringTokenizer;

/**
 * 가장 긴 증가하는 부분 수열 문제 해결
 * 이분 탐색을 사용하여 O(n log n) 시간 복잡도로 해결
 * result 배열에는 각 길이의 증가하는 부분 수열의 마지막 원소 중 최소값을 저장
 */
class Main {
    public static void main(String[] args) throws java.lang.Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        int[] ar = new int[n];
        ArrayList<Integer> result = new ArrayList<Integer>();
        result.add(0); // 인덱스 0은 사용하지 않음 (1부터 시작)
        StringTokenizer st = new StringTokenizer(br.readLine(), " ");
        
        for (int i = 0; i < n; i++) {
            int num = ar[i] = Integer.parseInt(st.nextToken());
            
            // 현재 값이 result의 마지막 값보다 크면 추가 (부분 수열 길이 증가)
            if (num > result.get(result.size() - 1))
                result.add(num);
            else {
                // 이분 탐색으로 적절한 위치를 찾아 값 갱신
                int left = 0, right = result.size() - 1;
                while (left < right) {
                    int mid = (left + right) / 2;
                    if (result.get(mid) < num)
                        left = mid + 1;
                    else
                        right = mid;
                }
                // 해당 길이의 부분 수열의 마지막 원소를 더 작은 값으로 갱신
                result.set(right, num);
            }
        }
        // result.size() - 1이 가장 긴 증가하는 부분 수열의 길이
        System.out.println(result.size() - 1);
    }
}
```
1a:T11fc,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/3055)

<div className="text-center"><a href="https://www.acmicpc.net/problem/3055">https://www.acmicpc.net/problem/3055</a></div>

---

- 물웅덩이가 '시간마다' 번지고 고슴도치가 '시간마다' 움직인다.
- BFS를 써서 푼다.
- 일단 물이 먼저 퍼지고, 그 다음 고슴도치가 움직인다.
- 물의 위치를 큐에 넣고 탐색을 처음 큐 길이만큼 돌려서 새로 넣은 물의 위치는 다음 타임에 한다.
- 거리를 적어놓는 int배열 dist를 만들어서 고슴도치가 움직일때마다 현위치에서 이동할 곳에 +1을 넣어준다.
- 고슴도치가 목적지에 도착하면 고슴도치 위치 큐에 넣지 않아 큐가 비가 되어 while문을 멈춘다.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.LinkedList;
import java.util.Queue;

/**
 * 탈출 문제 해결
 * 물이 퍼지고 고슴도치가 이동하는 시뮬레이션 문제
 * BFS를 사용하여 물이 먼저 퍼지고, 그 다음 고슴도치가 이동
 */
class Main {

    public static void main(String[] args) throws java.lang.Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        String[] input = br.readLine().split(" ");
        int N = Integer.parseInt(input[0]), M = Integer.parseInt(input[1]); // N: 세로, M: 가로
        char[][] map = new char[N + 1][M + 1];
        int[][] directions = new int[][] { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } }; // 상하좌우
        int[][] dist = new int[N + 1][M + 1]; // 고슴도치의 이동 거리
        int[] dest = new int[2]; // 목적지 위치
        Queue<int[]> waterQ = new LinkedList<int[]>(), sonicQ = new LinkedList<int[]>(); // 물 큐, 고슴도치 큐

        // 맵 입력 및 초기 위치 설정
        for (int i = 0; i < N; i++) {
            char[] temp = br.readLine().toCharArray();
            for (int j = 0; j < M; j++) {
                map[i][j] = temp[j];
                if (temp[j] == '*')
                    waterQ.add(new int[] { i, j }); // 물 위치
                else if (temp[j] == 'S')
                    sonicQ.add(new int[] { i, j }); // 고슴도치 시작 위치
                else if (temp[j] == 'D')
                    dest = new int[] { i, j }; // 목적지
            }
        }

        // BFS: 매 시간마다 물이 먼저 퍼지고, 그 다음 고슴도치가 이동
        while (!sonicQ.isEmpty()) {
            // 물이 먼저 퍼짐: 현재 큐에 있는 물만 퍼짐 (다음 시간의 물은 제외)
            int size = waterQ.size();
            while (size-- > 0) {
                int[] pos = waterQ.poll();
                for (int[] dir : directions) {
                    int next_y = pos[0] + dir[0], next_x = pos[1] + dir[1];
                    // 범위 내이고, 빈 공간이거나 고슴도치 위치면 물이 퍼짐
                    if (!(next_y < 0 || next_x < 0 || next_y >= N || next_x >= M)
                            && (map[next_y][next_x] == '.' || map[next_y][next_x] == 'S')) {
                        map[next_y][next_x] = '*';
                        waterQ.add(new int[] { next_y, next_x });
                    }
                }
            }

            // 고슴도치 이동: 현재 큐에 있는 고슴도치만 이동
            size = sonicQ.size();
            while (size-- > 0) {
                int[] pos = sonicQ.poll();
                for (int[] dir : directions) {
                    int next_y = pos[0] + dir[0], next_x = pos[1] + dir[1];
                    // 범위 내이고, 물이 아니고, 돌이 아니고, 아직 방문하지 않았으면 이동
                    if (!(next_y < 0 || next_x < 0 || next_y >= N || next_x >= M)
                            && (map[next_y][next_x] != '*' && map[next_y][next_x] != 'X')
                            && dist[next_y][next_x] == 0) {
                        dist[next_y][next_x] = dist[pos[0]][pos[1]] + 1; // 거리 증가
                        sonicQ.add(new int[] { next_y, next_x });
                    }
                }
            }
        }

        int result = dist[dest[0]][dest[1]];
        // 목적지에 도달했으면 거리 출력, 아니면 "KAKTUS" 출력
        bw.write(result != 0 ? result + "" : "KAKTUS");
        bw.flush();
    }
}
```
1b:T742,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/9012)

<div className="text-center"><a href="https://www.acmicpc.net/problem/9012">https://www.acmicpc.net/problem/9012</a></div>

- '('의 갯수 와 ')'갯수를 세어 )가 더 크게 되면 갯수가 맞지 않으므로 NO를 출력
- 끝까지 가면 YES를 출력

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

/**
 * 괄호 문제 해결
 * 올바른 괄호 문자열인지 확인하는 문제
 * '('와 ')'의 개수를 세어 확인
 */
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        int n = Integer.parseInt(br.readLine()); // 테스트 케이스 개수

        for (int a = 0; a < n; a++) {
            int[] ar = new int[2]; // ar[0]: '(' 개수, ar[1]: ')' 개수
            boolean flag = true;
            String input = br.readLine();

            for (int i = 0; i < input.length(); i++) {
                if (input.charAt(i) == '(')
                    ar[0]++;
                else
                    ar[1]++;

                // ')'가 '('보다 많아지면 올바른 괄호 문자열이 아님
                if (ar[0] < ar[1]) {
                    flag = false;
                    break;
                }
            }

            // '('와 ')'의 개수가 같고, 중간에 ')'가 더 많아진 적이 없어야 YES
            bw.write(flag && ar[0] == ar[1] ? "YES" : "NO");
            bw.newLine();
            bw.flush();
        }
        br.close();
        bw.close();
    }
}
```
1c:T877,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1620)

<div className="text-center"><a href="https://www.acmicpc.net/problem/1620">https://www.acmicpc.net/problem/1620</a></div>

---

- 이름을 키로 하여 번호를 갖는 맵과 번호를 인덱스로 하는 String배열을 통해 참조하도록 한다.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.HashMap;

/**
 * 나는야 포켓몬 마스터 이다솜 문제 해결
 * 포켓몬 이름과 번호를 양방향으로 조회할 수 있어야 하는 문제
 * HashMap으로 이름->번호, 배열로 번호->이름 조회
 */
class Main {
    public static void main(String[] args) throws java.lang.Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        String[] input = br.readLine().split(" ");
        int N = Integer.parseInt(input[0]), M = Integer.parseInt(input[1]); // N: 포켓몬 개수, M: 문제 개수
        
        // 이름을 키로 하여 번호를 갖는 맵과 번호를 인덱스로 하는 String 배열
        HashMap<String, Integer> map = new HashMap<String, Integer>();
        String[] ar = new String[N];
        
        // 포켓몬 정보 입력
        for (int i = 0; i < N; i++) {
            String in = br.readLine();
            map.put(in, i + 1); // 이름 -> 번호
            ar[i] = in; // 번호 -> 이름
        }

        // 문제 처리
        for (int i = 0; i < M; i++) {
            String m = br.readLine();
            // 입력이 숫자인지 확인
            if (m.matches("[-+]?\\d*\\.?\\d+")) {
                // 숫자면 배열에서 이름 조회
                bw.write(ar[Integer.parseInt(m) - 1]);
            } else {
                // 이름이면 맵에서 번호 조회
                bw.write(map.get(m) + "");
            }
            if (i != M - 1)
                bw.write("\n");
        }
        bw.flush();
    }
}


```
1d:T6fc,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/15829)

<div className="text-center"><a href="https://www.acmicpc.net/problem/15829">https://www.acmicpc.net/problem/15829</a></div>

---

- 문제를 잘 읽자.
- M값의 나머지로만 움직여야한다.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

/**
 * Hashing 문제 해결
 * 문자열을 해시값으로 변환하는 문제
 * 각 문자의 위치에 따라 가중치를 곱하여 해시값 계산
 * M값의 나머지로만 계산해야 함 (오버플로우 방지)
 */
public class Main {
    static final int r = 31; // 해시 함수의 기수
    static final int M = 1234567891; // 나머지 연산을 위한 모듈러 값

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        int n = Integer.parseInt(br.readLine());
        char[] input = br.readLine().toCharArray();
        long sum = 0;
        
        // 각 문자에 대해 해시값 계산
        // a=1, b=2, ..., z=26으로 변환하고 r의 i제곱을 곱함
        for (int i = 0; i < n; i++) {
            sum += (((input[i] - 'a') + 1) * pow(r, i));
        }

        // M으로 나눈 나머지 출력
        bw.write((sum % M) + "");

        bw.flush();
    }

    /**
     * 거듭제곱 계산 (재귀)
     * @param a: 밑
     * @param b: 지수
     * @return: a^b % M
     */
    static long pow(int a, int b) {
        return b == 0 ? 1 : a * pow(a, b - 1) % M;
    }

}
```
1e:T6be,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1107)

<div className="text-center"><a href="https://www.acmicpc.net/problem/1107">https://www.acmicpc.net/problem/1107</a></div>

---

- 시작 100이니 목적지에서 100을 절대값을 넣고 찾기 시작한다.
- 한글자씩 떼서 확인하는것이 한칸씩 움직이는것과 비교했을때 뭐가 더 적은가를 비교하며 반복한다.

---

```python
/**
 * 리모컨 문제 해결
 * 고장난 버튼을 제외하고 숫자 버튼으로 목표 채널에 도달하는 최소 버튼 클릭 횟수를 구하는 문제
 * 브루트포스 알고리즘을 사용하여 모든 가능한 채널을 확인
 */

N = int(input()) # 목표 채널
M = int(input()) # 고장난 버튼 개수

# 사용 가능한 숫자 버튼 집합 (0~9)
enable = {str(x) for x in range(10)}
if (M != 0):
    # 고장난 버튼을 사용 가능한 집합에서 제거
    enable -= set(input().split())

# 초기값: 현재 채널(100)에서 목표 채널까지 + 또는 - 버튼만 사용하는 경우
result = abs(N - 100)

# 0부터 1,000,000까지 모든 채널을 확인
for i in range(1000001):
    is_true = True
    # 현재 채널의 각 자리수가 사용 가능한 버튼인지 확인
    for c in str(i):
        if (c not in enable):
            is_true = False # 사용 불가능한 버튼이 있으면 건너뜀
            break
    # 모든 자리수가 사용 가능한 버튼이면
    if is_true is True:
        # 현재 채널로 이동하는 버튼 클릭 횟수 + 목표 채널까지의 차이
        result = min(result, abs(N - i) + len(str(i)))

print(result) # 최소 버튼 클릭 횟수 출력

```
1f:T68a,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1463)

<div className="text-center"><a href="https://www.acmicpc.net/problem/1463">https://www.acmicpc.net/problem/1463</a></div>

---

- 문제는 최단거리로 n에서 1로 가는거지만 거꾸로 1에서 최단거리로 n가는 방법도 적용된다.
- 배열은 n+1만큼 선언하여 끝까지 도달할때 더 작은값이 들어가는 조건을 찾아 비교하여 채운다.

---

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;

/**
 * 1로 만들기 문제 해결
 * 정수 n을 1로 만드는 최소 연산 횟수를 구하는 문제
 * 다이나믹 프로그래밍을 사용하여 각 숫자를 1로 만드는 최소 횟수를 계산
 */
class Main{
public static void main (String[] args) throws java.lang.Exception
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int n = Integer.parseInt(br.readLine());
		
		// ar[i]: i를 1로 만드는 최소 연산 횟수
		int[] ar = new int[n+1];
		
		// 2부터 n까지 각 숫자를 1로 만드는 최소 횟수 계산
		for(int i=2;i<=n;i++){
			// 기본값: 1을 빼는 연산 (ar[i-1] + 1)
			ar[i] = ar[i-1]+1;
			
			// 2로 나누어 떨어지는 경우: 2로 나누는 연산과 비교하여 더 작은 값 선택
			if(i%2==0)
				ar[i] = ar[i]<ar[i/2]+1?ar[i]:ar[i/2]+1;
			
			// 3으로 나누어 떨어지는 경우: 3으로 나누는 연산과 비교하여 더 작은 값 선택
			if(i%3==0)
				ar[i] = ar[i]<ar[i/3]+1?ar[i]:ar[i/3]+1;
		}
		
		// n을 1로 만드는 최소 연산 횟수 출력
		System.out.println(ar[n]);
	}
}


```
20:T63c,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1259)

<div className="text-center"><a href="https://www.acmicpc.net/problem/1259">https://www.acmicpc.net/problem/1259</a></div>

---

- 숫자가 대칭하는 모양인지 판별하는 문제이다.
- 숫자이지만 대칭하는 모양을 판별하는 것은 문자로 봐야한다.
- 문자 배열 인덱스를 하나씩 좌우에서 들어가면서 비교한다.

---

```java

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 * 펠린드롬수 문제 해결
 * 숫자가 대칭인지(펠린드롬인지) 판별하는 문제
 * 문자열로 변환하여 좌우 대칭을 확인
 */
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String input = reader.readLine();
        
        // "0"이 입력될 때까지 반복
        while (!input.equals("0")) {
            String result = "yes"; // 기본값은 펠린드롬
            // 문자열의 절반까지만 확인 (대칭이므로)
            for (int i = 0; i < input.length() / 2; i++) {
                // 앞쪽 문자와 뒤쪽 문자가 다르면 펠린드롬이 아님
                if (input.charAt(i) != input.charAt(input.length() - i - 1)) {
                    result = "no";
                    break;
                }
            }
            System.out.println(result);
            input = reader.readLine();
        }
    }
}

```
21:Tba1,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1012)

<div className="text-center"><a href="https://www.acmicpc.net/problem/1012">https://www.acmicpc.net/problem/1012</a></div>

---

- 이어진 배추가 있는지 탐색하여 필요한 배추벌레 갯수를 구한다.
- 한점을 탐색하여 상하좌우를 살펴서 있을 경우 한마리로 배추가 없을때까지 탐색을 하여 배추를 배열에서 제거하고 카운트를 늘린다.

---

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

/**
 * 유기농 배추 문제 해결
 * 배추밭에서 인접한 배추 그룹의 개수를 구하는 문제
 * DFS를 사용하여 연결된 배추들을 탐색
 */
public class Main {
    static int[][] ar; // 배추밭 지도

    /**
     * DFS를 사용하여 인접한 배추들을 모두 탐색하고 제거
     * @param x: 현재 x 좌표
     * @param y: 현재 y 좌표
     * @param m: 배추밭 가로 길이
     * @param n: 배추밭 세로 길이
     */
    public static void finder(int x, int y, int m, int n) {
        // 범위를 벗어나거나 배추가 없으면 종료
        if (x >= m || y >= n || x < 0 || y < 0 || ar[y][x] == 0)
            return;
        
        // 현재 위치의 배추를 제거 (방문 표시)
        ar[y][x] = 0;
        
        // 상하좌우 4방향으로 재귀 탐색
        finder(x + 1, y, m, n); // 오른쪽
        finder(x, y + 1, m, n); // 아래
        finder(x - 1, y, m, n); // 왼쪽
        finder(x, y - 1, m, n); // 위
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine()); // 테스트 케이스 개수
        
        for (int i = 0; i < n; i++) {
            // 입력: 가로(m), 세로(n), 배추 개수(k)
            int[] data = Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
            ar = new int[data[1]][data[0]]; // 배추밭 초기화
            
            // 배추 위치 입력
            for (int j = 0; j < data[2]; j++) {
                int[] pos = Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
                ar[pos[1]][pos[0]] = 1; // 배추 위치 표시
            }

            // 연결된 배추 그룹의 개수 세기
            int count = 0;
            for (int y = 0; y < data[1]; y++) {
                for (int x = 0; x < data[0]; x++) {
                    if (ar[y][x] == 1) {
                        count++; // 새로운 그룹 발견
                        finder(x, y, data[0], data[1]); // 연결된 모든 배추 탐색 및 제거
                    }
                }
            }
            System.out.println(count); // 필요한 지렁이 개수 출력
        }
    }
}
```
22:Tccd,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/10989)

<div className="text-center"><a href="https://www.acmicpc.net/problem/10989">https://www.acmicpc.net/problem/10989</a></div>

---

- 정렬 속도를 중요시 하는 퀵정렬을 이용한다.
- 기준을 왼쪽 앞으로 하느냐 가운데로 하느냐가 있는데 일단 왼쪽 앞으로 했다.
- 기준을 잡고 양 가운데로 나눈다.
- 왼쪽을 기준값보다 작은 값, 오른쪽을 큰 값.
- 나눠진 배열에서 기준값을 잡고 다시 양쪽으로 나누기 반복
- 두개만 남은 배열에서 정렬 시작.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

/**
 * 수 정렬하기 3 문제 해결
 * 퀵 정렬을 사용하여 배열을 정렬하는 문제
 * 분할 정복 알고리즘을 사용
 */
public class Main {
    /**
     * 파티션 함수: 기준값(pivot)을 기준으로 배열을 분할
     * @param ar: 정렬할 배열
     * @param l: 왼쪽 인덱스
     * @param r: 오른쪽 인덱스
     * @return: 기준값의 최종 위치
     */
    public int parition(int[] ar, int l, int r) {
        int p = ar[l], low = l, high = r; // 기준값은 왼쪽 첫 번째 원소
        low++;
        
        while (low <= high) {
            // 왼쪽에서 기준값보다 큰 값을 찾음
            while (low <= r && p > ar[low])
                low++;
            // 오른쪽에서 기준값보다 작은 값을 찾음
            while (high >= l && p < ar[high])
                high--;

            // low와 high가 교차하지 않았으면 두 값을 교환
            if (low <= high) {
                int temp = ar[low];
                ar[low] = ar[high];
                ar[high] = temp;
                low++;
                high--;
            }
        }
        // 기준값을 올바른 위치로 이동
        ar[l] = ar[high];
        ar[high] = p;

        return high; // 기준값의 최종 위치 반환
    }

    /**
     * 퀵 정렬 함수: 재귀적으로 배열을 정렬
     * @param ar: 정렬할 배열
     * @param left: 왼쪽 인덱스
     * @param right: 오른쪽 인덱스
     */
    public void quickSort(int[] ar, int left, int right) {
        if (left < right) {
            int p = parition(ar, left, right); // 기준값의 위치
            quickSort(ar, left, p - 1); // 왼쪽 부분 정렬
            quickSort(ar, p + 1, right); // 오른쪽 부분 정렬
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int n = Integer.parseInt(br.readLine());
        int[] ar = new int[n];
        
        // 배열 입력
        for (int i = 0; i < n; i++) {
            ar[i] = Integer.parseInt(br.readLine());
        }
        
        // 퀵 정렬 수행
        new Main().quickSort(ar, 0, n - 1);

        // 정렬된 결과 출력
        for (int s : ar)
            bw.write(s + "\n");

        bw.flush();
    }
}
```
23:T1e05,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/20927)

<div className="text-center"><a href="https://www.acmicpc.net/problem/20927">https://www.acmicpc.net/problem/20927</a></div>

---

- 문제에서 스패닝트리만 읽고 최소 스패닝트리로 하면 답이 없다.
- 브루트포스로 접근해야한다.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

/**
 * Degree Bounded Minimum Spanning Tree 문제 해결
 * 각 정점의 차수 제한을 만족하는 스패닝 트리를 찾는 문제
 * 백트래킹을 사용하여 모든 가능한 간선 조합을 탐색
 */

/**
 * 간선을 나타내는 클래스
 * 시작점, 끝점, 비용을 저장하고 비용 기준으로 정렬 가능
 */
class Node implements Comparable<Node>{
    int start,end,cost;
    public Node(int start,int end,int cost){
        // 시작점과 끝점을 작은 값이 start, 큰 값이 end가 되도록 정렬
        this.start = (start<end?start:end);
        this.end = (start<end?end:end);
        this.cost = cost;
    }
    @Override
    public int compareTo(Node o) {
        // 비용 기준 오름차순 정렬
        return this.cost - o.cost;
    }
}

public class Main {
    static BufferedReader br;
    static BufferedWriter bw;
    static StringBuilder sb;
    // ar: Union-Find를 위한 부모 배열
    // limit: 각 정점의 차수 제한
    // degree: 각 정점의 현재 차수
    // check: 백트래킹에서 간선 선택 여부를 체크하는 배열
    static int[] ar,limit,degree,check;
    static int n,m,sum=Integer.MAX_VALUE; // n: 정점 수, m: 간선 수, sum: 최소 비용
    static Queue<Node> nodes = new LinkedList<Node>(); // 최종 선택된 간선들을 저장
    static ArrayList<Node> edges = new ArrayList<Node>(); // 모든 간선 정보
    
    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));
        sb = new StringBuilder();
        StringTokenizer st = new StringTokenizer(br.readLine());
        n  = Integer.parseInt(st.nextToken()); // 정점의 개수
        m = Integer.parseInt(st.nextToken()); // 간선의 개수
        limit = new int[n+1]; // 각 정점의 차수 제한
        check = new int[m+1]; // 간선 선택 여부 체크 배열
        
        // 각 정점의 차수 제한 입력
        st = new StringTokenizer(br.readLine());
        for(int i=1;i<=n;i++){
            limit[i] = Integer.parseInt(st.nextToken());
        }
        
        // 간선 정보 입력 (시작점, 끝점, 비용)
        for(int i=0;i<m;i++){
            st = new StringTokenizer(br.readLine());
            edges.add(new Node(Integer.parseInt(st.nextToken()),Integer.parseInt(st.nextToken()),Integer.parseInt(st.nextToken())));
        }
        
        // 간선을 비용 기준으로 정렬 (백트래킹 효율성을 위해)
        Collections.sort(edges);
        
        // 백트래킹 시작: n-1개의 간선을 선택하여 스패닝 트리 구성
        backtrack(0,0);

        // 결과 출력
        // 스패닝 트리를 찾지 못한 경우
        if(nodes.isEmpty()){
            // 정점이 1개인 경우는 항상 가능, 그 외는 불가능
            sb.append(n==1?"YES":"NO");
        }
        else{
            // 스패닝 트리를 찾은 경우 YES와 선택된 간선들 출력
            sb.append("YES\n");
            while(!nodes.isEmpty()){
                Node node = nodes.poll();
                sb.append(node.start+" "+node.end+(nodes.isEmpty()?"":"\n"));
            }
        }
        bw.write(sb.toString());
        bw.flush();
        bw.close();
    }
    
    /**
     * 백트래킹을 사용하여 n-1개의 간선을 선택
     * @param index: 현재 고려할 간선의 인덱스
     * @param cnt: 현재까지 선택한 간선의 개수
     */
    private static void backtrack(int index, int cnt) {
        // n-1개의 간선을 선택했으면 스패닝 트리인지 확인
        if(cnt==n-1){
            boolean flag = true;
            int tsum = 0; // 현재 선택한 간선들의 총 비용
            
            // Union-Find 초기화
            ar = new int[n+1];
            Arrays.fill(ar,-1); // -1은 루트 노드를 의미
            degree = new int[n+1]; // 각 정점의 차수 초기화
            Queue<Node> temp = new LinkedList<Node>(); // 현재 선택한 간선들 임시 저장

            // 선택된 간선들을 사용하여 Union-Find 수행
            for(int i=0;i<m;i++){
                if(check[i]==0)continue; // 선택되지 않은 간선은 건너뜀
                Node node = edges.get(i);
                // 두 정점이 다른 집합에 속해있으면 (사이클이 없으면)
                if(find(node.start)!=find(node.end)){
                    union(node.start, node.end); // 두 집합을 합침
                    degree[node.start]++; // 두 정점의 차수 증가
                    degree[node.end]++;
                    temp.add(node); // 선택된 간선 저장
                    tsum+=node.cost; // 비용 누적
                }
            }

            // 모든 정점이 연결되어 있는지 확인 (스패닝 트리 조건)
            // 그리고 각 정점의 차수가 제한을 넘지 않는지 확인
            for(int i=1;i<=n;i++){
                // 이전 정점과 연결되어 있지 않거나, 차수가 제한을 초과하면 실패
                if((i>1&&find(i-1)!=find(i))||(degree[i]>limit[i])){
                    flag=false;
                    break;
                }
            }

            // 조건을 만족하는 스패닝 트리를 찾았고, 비용이 더 작으면 업데이트
            if(flag){
                if(sum>tsum){
                    sum=tsum;
                    nodes=new LinkedList<>(temp);
                }
            }

            return;
        }

        // 백트래킹: 간선을 선택하거나 선택하지 않음
        for(int i=index;i<m;i++){
            if(check[i]==1)continue; // 이미 선택된 간선은 건너뜀
            check[i]=1; // 간선 선택
            backtrack(i+1, cnt+1); // 다음 간선으로 재귀
            check[i]=0; // 백트래킹: 선택 취소
        }
    }
    /**
     * Union-Find: 두 집합을 합치는 함수
     * @param start: 첫 번째 정점
     * @param end: 두 번째 정점
     */
    private static void union(int start, int end) {
        int pa = find(start),pb=find(end); // 각 정점의 루트 찾기
        if(pa==pb)return; // 이미 같은 집합에 속해있으면 종료
        // pb의 부모를 pa로 설정하여 두 집합을 합침
        // ar[pa]+=ar[pb]; // 주석 처리된 부분은 랭크 기반 최적화
        ar[pb]=pa;
        return;
    }
    
    /**
     * Union-Find: 정점의 루트를 찾는 함수 (경로 압축 적용)
     * @param index: 찾을 정점
     * @return: 정점이 속한 집합의 루트
     */
    private static int find(int index) {
        // ar[index] < 0이면 루트 노드
        if(ar[index]<0)return index;
        // 경로 압축: 부모를 루트로 직접 연결하여 다음 조회 시 속도 향상
        return ar[index] = find(ar[index]);
    }
}



```
24:Te1e,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/18111)

<div className="text-center"><a href="https://www.acmicpc.net/problem/18111">https://www.acmicpc.net/problem/18111</a></div>

---

- 땅을 평평하게 하기 위해 파거나 쌓는 작업을 하는데 그 중 가장 높은 높이를 출력해야한다.
- 반복의 범위를 줄이기 위해 높이 최저,최고 값을 정해준다.
- 최저값부터 최고값까지 각 칸과의 거리를 구하여 음수가 나오면 파내는것이고 양수가 나오면 더해줘야하므로 가방에서 더해준다.
- 배열 탐색을 끝내고 가방에서 쓸 수 있는 블록 보다 더 쓸 경우는 넘어간다.
- 블록이 사용가능한 갯수면 최소 시간을 비교하여 대입한다.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

/**
 * 마인크래프트 문제 해결
 * 땅을 평평하게 만들기 위해 파거나 쌓는 작업의 최소 시간과 최대 높이를 구하는 문제
 * 브루트포스: 가능한 모든 높이에 대해 시간을 계산하여 최소값 찾기
 */
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        String[] input = br.readLine().split(" ");

        int n = Integer.parseInt(input[0]), m = Integer.parseInt(input[1]), b = Integer.parseInt(input[2]); // n: 세로, m: 가로, b: 인벤토리 블록 개수
        int min = 501, max = -1; // 최소 높이, 최대 높이
        int[][] land = new int[n][m];

        // 땅의 높이 입력 및 최소/최대 높이 찾기
        for (int i = 0; i < n; i++) {
            input = br.readLine().split(" ");
            for (int j = 0; j < m; j++) {
                int t = Integer.parseInt(input[j]);
                land[i][j] = t;
                if (t < min)
                    min = t;
                if (t > max)
                    max = t;
            }
        }

        int minTime = Integer.MAX_VALUE, height = 0;
        // 최소 높이부터 최대 높이까지 모든 경우를 확인
        for (int h = min; h <= max; h++) {
            int inven = b, time = 0; // 현재 인벤토리, 소요 시간
            for (int[] row : land) {
                for (int land_h : row) {
                    int gap = land_h - h; // 목표 높이와의 차이
                    if (gap > 0) {
                        // 블록을 제거해야 함 (2초 소요)
                        time += gap * 2;
                        inven += gap; // 제거한 블록을 인벤토리에 추가
                    } else if (gap < 0) {
                        // 블록을 쌓아야 함 (1초 소요)
                        time -= gap; // gap이 음수이므로 -를 붙여서 양수로
                        inven += gap; // 사용한 블록을 인벤토리에서 제거
                    }
                }
            }
            // 인벤토리에 블록이 부족하면 불가능
            if (inven < 0) {
                continue;
            }
            // 최소 시간이면 업데이트 (같은 시간이면 높이가 높은 것을 선택)
            if (minTime >= time) {
                minTime = time;
                height = h;
            }

        }

        bw.write(minTime + " " + height);
        bw.flush();
    }
}

```
25:T955,
[![프로그래머스](https://file.newswire.co.kr/data/datafile2/thumb_640/2021/06/1993996598_20210610150326_5364622170.jpg)](https://programmers.co.kr/learn/courses/30/lessons/17681)

<div className="text-center"><a href="https://programmers.co.kr/learn/courses/30/lessons/17681">https://programmers.co.kr/learn/courses/30/lessons/17681</a></div>

- 입력받은 숫자를 2진수로 변환하여 비교하는 문제다.
- 이진수 문장길이가 같지 않을 수 있으므로 거꾸로 받아서 비교하여 다시 역순으로 배출한다.

```java

/**
 * 비밀지도 문제 해결
 * 두 배열의 숫자를 이진수로 변환하여 OR 연산을 수행하는 문제
 * 1은 '#'으로, 0은 공백으로 변환하여 지도를 만듦
 */
class Solution {
    public String[] solution(int n, int[] arr1, int[] arr2) {
        String[] answer = new String[n];

        for (int i = 0; i < n; i++) {
            // 각 숫자를 이진수 문자열로 변환 (거꾸로 저장됨)
            char[] r1 = makeString(arr1[i]), r2 = makeString(arr2[i]);
            String result = "";
            int len1 = r1.length, len2 = r2.length;
            
            // 각 자리수를 비교하여 OR 연산 수행
            // 두 이진수 중 하나라도 1이면 '#'(벽), 둘 다 0이면 공백
            for (int j = 0; j < n; j++) {
                // j번째 자리가 범위 내에 있고 '#'인지 확인
                boolean bit1 = (j < len1 && r1[j] == '#');
                boolean bit2 = (j < len2 && r2[j] == '#');
                // OR 연산: 둘 중 하나라도 true면 '#', 아니면 공백
                // 결과를 앞에 추가하여 역순으로 저장 (나중에 올바른 순서가 됨)
                result = (bit1 || bit2 ? "#": " ") + result;
            }
            answer[i] = result;
        }
        return answer;
    }

    /**
     * 숫자를 이진수로 변환하여 '#'과 공백으로 표현
     * @param num: 변환할 숫자
     * @return: 이진수 표현 (거꾸로 저장됨, LSB부터)
     */
    public char[] makeString(int num) {
        String result = "";
        while (num > 0) {
            // 2로 나눈 나머지가 1이면 '#', 0이면 공백
            result += (num % 2 == 1 ? "#" : " ");
            num /= 2; // 다음 자리수로 이동
        }
        return result.toCharArray();
    }
}


```
26:T7b0,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/2745)

<div className="text-center"><a href="https://www.acmicpc.net/problem/2745">https://www.acmicpc.net/problem/2745</a></div>

---

- 입력받은 문자를 하나씩 떼어서 각 자리의 진법 배수 만큼 곱하여 더해준다.
- 숫자 범위에 걸릴까봐 Math.pow 대신 pow를 구현해서 썼다.

---

```java

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

/**
 * 진법 변환 문제 해결
 * B진법 수를 10진법으로 변환하는 문제
 * 각 자리수를 해당 진법의 거듭제곱과 곱하여 합산
 */
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        String[] input = br.readLine().split(" ");
        char[] text = input[0].toUpperCase().toCharArray(); // 대문자로 변환
        int b = Integer.parseInt(input[1]); // 진법
        long sum = 0;
        int len = text.length;
        
        // 오른쪽부터 왼쪽으로 (낮은 자리부터 높은 자리로)
        for (int i = len - 1; i >= 0; i--) {
            int t = text[i];
            // 숫자(0-9)면 48('0')을 빼고, 문자(A-Z)면 55('A'-10)를 빼서 10진수 값으로 변환
            t -= (t >= 48 && t <= 57) ? 48 : 55;
            // 각 자리수에 진법의 거듭제곱을 곱하여 합산
            sum += t * pow(b, len - 1 - i);
        }
        bw.write(sum + "");
        bw.flush();
    }

    /**
     * 거듭제곱 계산 (재귀)
     * @param a: 밑
     * @param b: 지수
     * @return: a^b
     */
    static long pow(int a, int b) {
        return b == 0 ? 1 : a * pow(a, b - 1);
    }

}

```
27:Tc7b,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/6603)

<div className="text-center"><a href="https://www.acmicpc.net/problem/6603">https://www.acmicpc.net/problem/6603</a></div>

---

- Queue에 숫자를 하나씩 넣고 다음 숫자들을 하나씩 끼워서 입력받은 길이 만큼 만들어보는 문제다.
- 받은 숫자 다음 꺼낸 숫자가 받은 숫자보다 커야 그 다음 숫자를 끼워본다.
- 재귀로 돌면서 끼워서 6개가 되면 출력한다.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

/**
 * 로또 문제 해결
 * 주어진 숫자들 중에서 6개를 선택하는 모든 조합을 출력하는 문제
 * 백트래킹을 사용하여 조합 생성
 */
public class Main {
    static BufferedReader br;
    static BufferedWriter bw;
    static int n; // 입력 길이
    static Queue<Integer> q; // 입력 받은 숫자들을 담는 큐
    
    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));
        String input = br.readLine();
        
        while(!input.equals("0")){ // 입력받은 문자열이 0이 아닐 때 반복
            StringTokenizer st = new StringTokenizer(input); // 띄어쓰기로 구분하여 하나씩 꺼내주는 StringTokenizer를 사용
            n = Integer.parseInt(st.nextToken());
            q = new LinkedList<Integer>(); // 큐 선언
            while(st.hasMoreTokens()){ // 큐에 입력받은 숫자들을 전부 집어 넣음
                q.add(Integer.parseInt(st.nextToken()));
            }
            // 조합 함수 실행, 빈 문자열과 마지막 받은 숫자를 0으로 넣음 (들어간 숫자가 없으므로 인덱스 개수도 0)
            permutation("",0,0);
            input = br.readLine();

            bw.newLine();
        }

        bw.flush();
    }

    /**
     * 조합 함수 (백트래킹)
     * @param num: 현재까지 선택한 숫자들을 문자열로 저장
     * @param lastNUM: 마지막으로 선택한 숫자
     * @param index: 현재까지 선택한 숫자의 개수
     */
    public static void permutation(String num, int lastNUM,int index) throws IOException{
        if(index==6){ // 6개의 조합일 경우 출력하고 함수를 종료
            bw.write(num+"\n");
            return;
        }
        for(int i=index;i<n;i++){ // 현재 인덱스 개수에서 입력 받은 개수-1까지 반복
            int next = q.poll(); // 큐에서 다음 숫자를 하나 꺼냄
            if(lastNUM<next){ // 마지막 숫자보다 다음 숫자가 클 경우 조합 함수를 실행 (오름차순 유지)
                permutation(num+(index==0?"":" ")+next,next,index+1);
            }
            q.add(next); // 사용한 숫자는 다시 큐의 뒤쪽에 넣어서 재사용할 수 있게 만듦
        }
    }
}
```
28:T6d7,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/5692)

<div className="text-center"><a href="https://www.acmicpc.net/problem/5692">https://www.acmicpc.net/problem/5692</a></div>

---

- 10진법이 123이 1*10^2+ 2*10^1 + 3\*10^3이 듯 한 글자씩 떼서 각 팩토리얼 자리 값을 곱해서 더해준다.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

/**
 * 팩토리얼 진법 문제 해결
 * 팩토리얼 진법 수를 10진법으로 변환하는 문제
 * 각 자리수에 해당하는 팩토리얼 값을 곱하여 합산
 */
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        // 팩토리얼 값들을 미리 계산 (0! = 1, 1! = 1, 2! = 2, ...)
        int[] ar = new int[10];
        for (int i = 0; i < 10; i++) {
            ar[i] = i < 2 ? 1 : ar[i - 1] * i;
        }

        while (true) {
            int n = Integer.parseInt(br.readLine()), result = 0;
            if (n == 0)
                break;
            
            // 각 자리수를 오른쪽부터 (낮은 자리부터) 확인
            // 1! 자리, 2! 자리, 3! 자리... 순서로 계산
            for (int i = 1; n > 0; i++, n /= 10) {
                int temp = n % 10; // 현재 자리수
                result += ar[i] * temp; // 팩토리얼 값과 곱하여 합산
            }
            bw.write(result + "\n");
        }
        bw.flush();
    }
}
```
29:T18d9,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/4949)

<div className="text-center"><a href="https://www.acmicpc.net/problem/4949">https://www.acmicpc.net/problem/4949</a></div>

---

- 소괄호와 대괄호가 대칭적으로 들어있는가에 대한 문제다.
- 처음 풀이는 스택에 ([을 넣고 )]이 나올때 스택의 마지막 값과 대칭하는지, 스택이 0보다 작은데 )]이 나오는게 아닌지 조건을 줘서 풀었다.

---

```java

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.Stack;

/**
 * 균형잡힌 세상 문제 해결 (방법 1 - Stack 사용)
 * 소괄호와 대괄호가 대칭적으로 들어있는지 확인하는 문제
 * 스택을 사용하여 괄호의 짝을 확인
 */
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        // 입력은 한번 먼저 받고 시작
        String input = br.readLine();
        Stack<Character> stack = null;
        while (true) {
            // 결과값 제어를 위한 flag, true면 yes를 false면 no를 출력하게 만듦
            boolean flag = true;
            stack = new Stack<Character>();
            // 빠른 탐색을 위해 char[]로 변경하여 반복
            for (char c : input.toCharArray()) {
                // stack에 여는 괄호만 넣음
                if ("([".contains(c + "")) {
                    stack.push(c);

                // 닫힌 괄호가 나왔을 때 스택의 마지막 값과 비교하여 맞지 않을 경우 또는
                // stack이 비어있는데 닫힌 괄호가 나온 경우 flag에 false를 넣음
                } else if (")]".contains(c + "")) {
                    if (stack.isEmpty()) {
                        flag = false;
                        break;
                    }
                    char last = stack.pop();
                    // 괄호의 짝이 맞지 않으면 false
                    if ((last == '(' && c == ']') || (last == '[' && c == ')')) {
                        flag = false;
                        break;
                    }
                }
            }
            // 반복문이 끝났지만 stack에 무언가 남아있다면 짝이 맞지 않으므로 flag에 false 대입
            if (!stack.isEmpty())
                flag = false;
            bw.write(flag ? "yes" : "no");
            input = br.readLine();

            if (input.equals("."))
                break;
            bw.write("\n");
        }
        bw.flush();
    }
}

```

---

- 훨씬 메모리와 속도에서 좋은 풀이가 있길래 따라해봤다.
- 아스키 코드에서 '(' 와 ')'는 1차이가 나고 '[' 와 ']'는 2차이가 난다
- 근데 결과는 별 차이가 안났다.

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

/**
 * 균형잡힌 세상 문제 해결 (방법 2 - String 사용)
 * 아스키 코드를 이용: '('와 ')'는 1 차이, '['와 ']'는 2 차이
 */
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        while (true) {
            String input = br.readLine();
            char[] ar = input.toCharArray();
            if (ar.length == 1 && ar[0] == '.')
                break;
            String stack = ""; // 스택 대신 String 사용
            for (char c : ar) {
                if ("()[]".contains(c + "")) {
                    // 아스키 코드 차이를 이용: '('와 ')'는 1 차이, '['와 ']'는 2 차이
                    // 짝이 맞으면 스택에서 제거
                    if (stack.length() != 0 && (c - stack.charAt(stack.length() - 1) == 2
                            || c - stack.charAt(stack.length() - 1) == 1)) {
                        stack = stack.substring(0, stack.length() - 1);
                    } else {
                        stack += c; // 짝이 맞지 않으면 스택에 추가
                    }
                }
            }
            bw.write((stack.length() == 0 ? "yes" : "no") + "\n");
        }
        bw.flush();
    }
}
```

---

- 결국 <a href='https://www.acmicpc.net/source/27698325'>참조한 코드</a>는 char[]를 사용했다.

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

/**
 * 균형잡힌 세상 문제 해결 (방법 3 - char 배열 사용, 최적화)
 * char 배열을 직접 사용하여 스택을 구현
 * 아스키 코드 차이를 이용하여 괄호 짝 확인
 */
public class Main {

    static char[] bracket = {'[', '(', ')', ']'}; // 괄호 배열

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder();

        while(true){
            String origin = br.readLine();
            char[] arr = origin.toCharArray();

            if(arr[0] == '.') break;

            int top = -1; // 스택의 top 인덱스
            char[] stack = new char[100]; // 스택 배열

            for(char c:arr)
                for(int a=0; a<4; a++)
                    if(c == bracket[a]) {
                        // 아스키 코드 차이를 이용: '('와 ')'는 1 차이, '['와 ']'는 2 차이
                        // 짝이 맞으면 스택에서 제거 (top 감소)
                        if (top != -1 && (c - stack[top] == 2 || c - stack[top] == 1))
                            --top;
                        else
                            stack[++top] = c; // 짝이 맞지 않으면 스택에 추가
                    }

            // top이 -1이면 모든 괄호가 짝이 맞음
            sb.append(top == -1? "yes":"no").append('\n');
        }
        System.out.println(sb);
    }
}

```
2a:T870,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/2869)

<div className="text-center"><a href="https://www.acmicpc.net/problem/2869">https://www.acmicpc.net/problem/2869</a></div>

---

- 아침에 a만큼 올라가고(+) 잘때 b만큼 미끄러지는(-) 상황에 v만큼 올라가는데 얼마나 걸리느냐 묻는 문제다.
- 올라간 위치가 v인 날이므로 앞으로 가야하는 거리(v)에서 하루동안 움직이는 거리(a-b)를 나눈다.
- 하지만 v/(a-b)만 계산할 경우 오전 동안 올라갔건 a가 빠져야하므로 v-a를 해준다.
- 그리고 나눈 값에 나머지가 존재할 경우 나머지 거리도 올라가야 하므로 1을 더해준다(나는 그냥 올림을 했다).
- 그리고 0일부터 시작했지만 세기는 1일부터 세므로 1을 더해준다.

---

```java

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

/**
 * 달팽이는 올라가고 싶다 문제 해결
 * 아침에 a만큼 올라가고 밤에 b만큼 미끄러질 때, v 높이에 도달하는데 걸리는 일수를 구하는 문제
 * 수학 공식을 사용하여 계산
 */
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        String[] input = br.readLine().split(" ");
        double a = Integer.parseInt(input[0]), b = Integer.parseInt(input[1]), v = Integer.parseInt(input[2]); // a: 올라가는 높이, b: 미끄러지는 높이, v: 목표 높이
        
        // 공식: (v - a) / (a - b) + 1
        // v-a: 마지막 날 아침에 올라가기 전까지 가야 하는 거리
        // (a-b): 하루에 실제로 올라가는 거리
        // +1: 마지막 날(아침에 올라가는 날)과 0일부터 시작하므로 1일 더함
        int r = (int) (Math.ceil((v - a) / (a - b)) + 1);
        bw.write(r + "");
        bw.flush();
    }
}

```
2b:Tb23,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/2805)

<div className="text-center"><a href="https://www.acmicpc.net/problem/2805">https://www.acmicpc.net/problem/2805</a></div>

---

- 최대한 필요한 만큼만 가져가도록 절단기 높이를 가장 높게 잡아줘야한다.
- 높이의 최소는 0 최대는 나무 중 가장 높은 나무의 높이를 넣는다.
- 최소 최대의 중간 값으로 잘라주고 자를 때 음수는 합하지 않는다.
- 그렇게 구해진 높이는 결과에 담고 구해진 높이가 기존 높이보다 낮으면 넣지 않는다.

---

```java

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.Arrays;

/**
 * 나무 자르기 문제 해결
 * 필요한 만큼의 나무를 가져가기 위한 최대 절단 높이를 구하는 문제
 * 이분 탐색을 사용하여 최적의 높이를 찾음
 */
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        String[] input = br.readLine().split(" ");
        int n = Integer.parseInt(input[0]); // 나무 개수
        long m = Integer.parseInt(input[1]); // 필요한 나무 길이
        long max = 0; // 가장 높은 나무의 높이
        long[] ar = new long[n];
        input = br.readLine().split(" ");
        
        // 나무 높이 입력 및 최대 높이 찾기
        for (int i = 0; i < n; i++) {
            long num = Long.parseLong(input[i]);
            ar[i] = num;
            if (num > max)
                max = num;
        }

        long sum = 0; // 잘린 나무의 총 길이
        long min = 0, mid = 0, answer = -1; // min: 최소 높이, mid: 중간 높이, answer: 최종 답
        
        // 이분 탐색
        while (min <= max) {
            sum = 0;
            mid = (max + min) / 2; // 중간 높이
            
            // 각 나무를 mid 높이로 자를 때 얻을 수 있는 나무 길이 계산
            for (long num : ar) {
                sum += num - mid > 0 ? num - mid : 0; // 음수는 합하지 않음
            }

            // 필요한 나무 길이 이상을 얻을 수 있으면 높이를 더 높일 수 있음
            if (sum >= m) {
                answer = mid > answer ? mid : answer; // 더 높은 높이로 업데이트
                min = mid + 1;
            } else {
                // 필요한 나무 길이보다 적으면 높이를 낮춰야 함
                max = mid - 1;
            }
        }
        bw.write(answer+"");
        bw.flush();
    }
}

```
2c:T808,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/2775)

<div className="text-center"><a href="https://www.acmicpc.net/problem/2775">https://www.acmicpc.net/problem/2775</a></div>

---

- 14 입력 범위 끝이니 배열로 미리 만들어두면 편하다.
- 각층 각호에 아랫층 같은호(ar[i-1][j])와 같은층 앞호(ar[i][j-1])을 합치면 현재 살아야하는 인원수가 나온다.
- 맨 밑층은 밑이 없으니 1.
- 0호는 층과 같다.

---

```java

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

/**
 * 부녀회장이 될테야 문제 해결
 * 아파트의 각 층, 각 호에 사는 사람 수를 구하는 문제
 * 다이나믹 프로그래밍을 사용하여 미리 계산
 * 각 층 각 호 = 아랫층 같은 호 + 같은 층 앞 호
 */
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int[][] ar = new int[15][15]; // ar[층][호] = 사람 수

        // 초기값 설정
        for (int i = 0; i < 15; i++) {
            ar[i][1] = 1; // 각 층의 1호는 1명
            ar[0][i] = i; // 0층의 i호는 i명
        }
        
        // 각 층, 각 호의 사람 수 계산
        for (int i = 1; i < 15; i++) {
            for (int j = 2; j < 15; j++) {
                // 각 층 각 호 = 아랫층 같은 호 + 같은 층 앞 호
                ar[i][j] = ar[i - 1][j] + ar[i][j - 1];
            }
        }
        
        int t = Integer.parseInt(br.readLine()); // 테스트 케이스 개수
        for (int i = 0; i < t; i++) {
            int k = Integer.parseInt(br.readLine()), n = Integer.parseInt(br.readLine()); // k: 층, n: 호
            bw.write(ar[k][n] + "\n");
        }

        bw.flush();
    }
}

```
2d:T5e7,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/2292)

<div className="text-center"><a href="https://www.acmicpc.net/problem/2292">https://www.acmicpc.net/problem/2292</a></div>

---

- 가운데 1개에서 7,19,37,61...
- 증가량이 6,12,18,24.... 6의 배수이다

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

/**
 * 벌집 문제 해결
 * 벌집의 중심에서 n번 방까지 최소 거리를 구하는 문제
 * 각 층의 방 개수가 6의 배수로 증가하는 패턴을 이용
 */
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int n = Integer.parseInt(br.readLine()); // 목표 방 번호

        // 벌집 구조: 1 -> 7(6개) -> 19(12개) -> 37(18개) -> 61(24개)...
        // 증가량: 6, 12, 18, 24... (6의 배수)
        // 1 6 12 18 24

        int count = 1, d = 0; // count: 현재까지의 방 개수, d: 거리
        for (int i = 0; count < n; i++) {
            count += (i * 6); // 각 층마다 6의 배수만큼 방이 증가
            d = i;
        }

        // 거리는 층수 + 1 (0층부터 시작하므로)
        bw.write((d + 1) + "\n");

        bw.flush();
    }
}
```
2e:Tace,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/2108)

<div className="text-center"><a href="https://www.acmicpc.net/problem/2108">https://www.acmicpc.net/problem/2108</a></div>

---

> 구해야하는 값이 4개(산술평균,중앙값,최빈값,범위)이다

- 산술평균 : 전체합을 갯수로 나눔
- 중앙값 : 주어진 값들을 정렬하여 가운데 위치하는 값, 카운트를 n/2번 한다.
- 최빈값 : 입력할때 최대 카운트를 찾고 그 값과 같은 값을 2번 이하로 찾는다.
- 범위 : 최댓값에서 최솟값을 뺀다.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

/**
 * 통계학 문제 해결
 * 산술평균, 중앙값, 최빈값, 범위를 구하는 문제
 * 카운팅 배열을 사용하여 효율적으로 계산
 */
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int n = Integer.parseInt(br.readLine()), sum = 0, min = 4000, max = -4000, max_count = 0, mode = 0, mid = 0;
        int[] ar = new int[8001]; // -4000 ~ 4000 범위를 0 ~ 8000으로 매핑
        
        // 숫자 입력 및 통계 계산
        for (int i = 0; i < n; i++) {
            int num = Integer.parseInt(br.readLine());
            ar[num + 4000]++; // 카운팅 (음수를 양수로 변환)
            sum += num; // 합계
            if (min > num)
                min = num; // 최솟값
            if (max < num)
                max = num; // 최댓값
            if (max_count < ar[num + 4000])
                max_count = ar[num + 4000]; // 최빈값의 개수
        }

        // 중앙값과 최빈값 계산
        for (int i = 0, count = 0, mode_count = 0; i < 8001; i++) {
            if (ar[i] > 0) {
                // 중앙값: n/2번째 값
                if (count < (n + 1) / 2) {
                    count += ar[i];
                    mid = i - 4000; // 원래 값으로 변환
                }

                // 최빈값: 가장 많이 나타난 값 (같은 개수가 여러 개면 두 번째로 작은 값)
                if (ar[i] == max_count && mode_count < 2) {
                    mode = i - 4000; // 원래 값으로 변환
                    mode_count++;
                }
            }
        }

        // 산술평균, 중앙값, 최빈값, 범위 출력
        bw.write((int) Math.round((double) sum / n) + "\n" + mid + "\n" + mode + "\n" + (max - min));
        bw.flush();
    }
}
```
2f:Te6a,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1978)

<div className="text-center"><a href="https://www.acmicpc.net/problem/1978">https://www.acmicpc.net/problem/1978</a></div>

---

- 1과 자기 자신 외에 나눠지지 않는 소수를 찾는 문제이다.
- 처음 생각한 코드는 2부터 주어진 수의 제곱근까지 반복시켜 소수를 판별했다.

---

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

/**
 * 소수 찾기 문제 해결 (방법 1)
 * 각 수를 제곱근까지 나누어 소수인지 판별하는 방법
 */
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine()), count = 0; // 숫자 개수, 소수 개수
        StringTokenizer st = new StringTokenizer(br.readLine());
        
        for (int i = 0; i < n; i++) {
            int num = Integer.parseInt(st.nextToken());
            if (num == 1) // 1은 소수가 아니므로 건너뜀
                continue;
            
            boolean flag = true; // 소수 여부 플래그
            // 2부터 제곱근까지 나누어 떨어지는지 확인
            // 제곱근까지만 확인하면 충분 (약수는 대칭적이므로)
            for (int j = 2; j <= Math.sqrt(num); j++) {
                if (num % j == 0) {
                    flag = false; // 나누어 떨어지면 소수가 아님
                    break;
                }
            }
            if (flag)
                count++; // 소수이면 개수 증가
        }
        System.out.println(count);
    }
}
```

---

- 하지만 걸린 시간과 메로리가 더 짧은 방법이 있었다.
- 최대 1000까지 입력이므로 불린형 배열에 true false로 소수 판별을 미리 만들어 놓고 인덱스로 찾아가서 true면 출력.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.StringTokenizer;

/**
 * 소수 찾기 문제 해결 (방법 2 - 에라토스테네스의 체)
 * 최대 1000까지이므로 에라토스테네스의 체를 사용하여 미리 소수를 계산
 * 더 빠르고 메모리 효율적인 방법
 */
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        
        // 입력된 숫자들을 표시할 배열 (true면 입력된 숫자)
        boolean[] ar = new boolean[1001];
        int n = Integer.parseInt(br.readLine());
        int count = 0;

        StringTokenizer st = new StringTokenizer(br.readLine());

        // 입력된 숫자들을 배열에 표시
        for (int i = 0; i < n; i++) {
            ar[Integer.parseInt(st.nextToken())] = true;
        }

        // 에라토스테네스의 체: 2부터 1000까지 순회
        for (int i = 2; i <= 1000; i++) {
            if (ar[i]) // 입력된 숫자이면 소수 개수 증가
                count++;
            
            // i의 배수들을 모두 제거 (소수가 아님을 표시)
            for (int j = 2;; j++) {
                if (i * j > 1000)
                    break;
                ar[i * j] = false; // i의 배수는 소수가 아님
            }
        }
        bw.write(count + "");
        bw.flush();
    }
}
```
30:T76c,
[![프로그래머스](https://file.newswire.co.kr/data/datafile2/thumb_640/2021/06/1993996598_20210610150326_5364622170.jpg)](https://programmers.co.kr/learn/courses/30/lessons/43165)

<div className="text-center"><a href="https://programmers.co.kr/learn/courses/30/lessons/43165">https://programmers.co.kr/learn/courses/30/lessons/43165</a></div>

---

- 깊이 우선 탐색을 이용하여 파고 내려가면서 결과를 도출하게 만든다.
- 첫번째 값부터 +,- 로 갈라져 내려가게 만든다.
- 덧셈이 먼저 나오고 그 다음 +,-로 가른 다음 다시 +으로 인덱스만큼 반복.
- 반복이 끝날때 목표값과 같은지 확인.

---

```java
/**
 * 타겟 넘버 문제 해결
 * 숫자 배열에 + 또는 -를 붙여서 타겟 넘버를 만드는 방법의 개수를 구하는 문제
 * DFS를 사용하여 모든 경우의 수를 탐색
 */
class Solution {
    int answer = 0; // 타겟 넘버를 만드는 방법의 개수

    public int solution(int[] numbers, int target) {
        // DFS 시작: 현재 합 0, 인덱스 0부터 시작
        dfs(numbers, target, 0, 0);
        return answer;
    }

    /**
     * DFS를 사용하여 모든 경우의 수를 탐색
     * @param numbers: 숫자 배열
     * @param target: 목표 값
     * @param sum: 현재까지의 합
     * @param index: 현재 처리할 인덱스
     */
    public void dfs(int[] numbers, int target, int sum, int index) {
        // 모든 숫자를 처리했으면
        if (index >= numbers.length) {
            if (sum == target) // 합이 타겟과 같으면
                answer++; // 방법 개수 증가
            return;
        }

        // 현재 숫자를 더하는 경우
        dfs(numbers, target, sum + numbers[index], index + 1);
        // 현재 숫자를 빼는 경우
        dfs(numbers, target, sum - numbers[index], index + 1);
    }
}
```
31:T936,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/2606)

<div className="text-center"><a href="https://www.acmicpc.net/problem/2606">https://www.acmicpc.net/problem/2606</a></div>

---

- 탐색을 해서 풀어보라고 그림으로 그려져있다.
- 이어지는 노드를 카운트 하는 문제 같아서 DFS로 풀었다.
- DFS에 대한 자세한 설명은 <a href="https://devuna.tistory.com/32">이 블로그 글</a>을 추천한다.
- count가 -1인 이유는 본인은 제외해야한다.

---

```java

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 * 바이러스 문제 해결
 * 1번 컴퓨터와 연결된 모든 컴퓨터의 개수를 구하는 문제
 * DFS를 사용하여 연결된 모든 노드를 탐색
 */
public class Main {
    static int count = -1, n, m; // count: 감염된 컴퓨터 개수 (본인 제외하므로 -1로 시작)
    static int[][] ar; // 인접 행렬
    static boolean[] visit; // 방문 여부

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        n = Integer.parseInt(br.readLine()); // 컴퓨터 개수
        m = Integer.parseInt(br.readLine()); // 연결 개수
        ar = new int[n + 1][n + 1];
        visit = new boolean[n + 1];

        // 연결 정보 입력 (무방향 그래프)
        for (int i = 0; i < m; i++) {
            String[] input = br.readLine().split(" ");
            int x = Integer.parseInt(input[0]), y = Integer.parseInt(input[1]);
            ar[y][x] = ar[x][y] = 1; // 양방향 연결
        }

        dfs(1); // 1번 컴퓨터부터 탐색 시작
        System.out.println(count);
    }

    /**
     * DFS를 사용하여 연결된 모든 컴퓨터를 탐색
     * @param v: 현재 탐색할 컴퓨터 번호
     */
    public static void dfs(int v) {
        count++; // 감염된 컴퓨터 개수 증가
        visit[v] = true; // 방문 표시
        
        // 연결된 모든 컴퓨터 탐색
        for (int i = 1; i <= n; i++) {
            if (visit[i] || ar[v][i] == 0) { // 이미 방문했거나 연결되지 않았으면 건너뜀
                continue;
            }
            dfs(i); // 재귀적으로 탐색
        }
    }
}

```
32:Td05,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1260)

<div className="text-center"><a href="https://www.acmicpc.net/problem/1260">https://www.acmicpc.net/problem/1260</a></div>

---

- 깊이 우선 탐색(DFS)과 너비 우선 탐색(BFS)을 구현하는 문제이다.
- 깊이 우선 탐색은 연결된 노드가 없을때까지 내려가면서 탐색, 너비 우선 탐색은 직접 연결된 노드들을 다 훑고 내려가는 탐색 방식이다.
- 자세한 설명은 <a href="https://devuna.tistory.com/32">이 블로그 글</a>을 추천한다.

---

```java

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.Queue;

/**
 * DFS와 BFS 문제 해결
 * 그래프를 깊이 우선 탐색(DFS)과 너비 우선 탐색(BFS)으로 탐색하는 문제
 */
public class Main {
    static boolean[] visit; // 방문 여부 배열
    static int n, m, v; // n: 정점 개수, m: 간선 개수, v: 시작 정점
    static int[][] ar; // 인접 행렬

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] input = br.readLine().split(" ");
        n = Integer.parseInt(input[0]);
        m = Integer.parseInt(input[1]);
        v = Integer.parseInt(input[2]);
        ar = new int[1001][1001];
        visit = new boolean[1001];

        // 간선 정보 입력 (무방향 그래프)
        for (int i = 0; i < m; i++) {
            input = br.readLine().split(" ");
            int x = Integer.parseInt(input[0]), y = Integer.parseInt(input[1]);
            ar[y][x] = 1;
            ar[x][y] = 1; // 무방향이므로 양방향으로 연결
        }

        // DFS 수행
        new Main().dfs(v);
        System.out.println();
        // BFS 수행
        new Main().bfs(v);
    }

    /**
     * 깊이 우선 탐색 (DFS)
     * 연결된 노드를 끝까지 탐색한 후 돌아옴
     * @param v: 현재 탐색할 정점
     */
    public void dfs(int v) {
        System.out.print(v + " ");
        visit[v] = true; // 방문 표시
        
        // 작은 번호부터 탐색
        for (int i = 1; i <= n; i++) {
            if (visit[i] || ar[v][i] == 0) // 이미 방문했거나 연결되지 않았으면 건너뜀
                continue;
            dfs(i); // 재귀적으로 탐색
        }
    }

    /**
     * 너비 우선 탐색 (BFS)
     * 같은 레벨의 노드를 모두 탐색한 후 다음 레벨로 이동
     * @param v: 시작 정점
     */
    public void bfs(int v) {
        Queue<Integer> q = new LinkedList<Integer>();
        q.add(v);
        visit[v] = false; // DFS에서 true로 설정했으므로 false로 변경 (재사용)

        while (!q.isEmpty()) {
            v = q.peek();
            System.out.print(q.peek() + " ");
            q.poll();
            
            // 연결된 모든 노드를 큐에 추가
            for (int i = 1; i <= n; i++) {
                if (!visit[i] || ar[v][i] == 0) // 이미 방문했거나 연결되지 않았으면 건너뜀
                    continue;
                q.add(i);
                visit[i] = false; // 방문 표시
            }
        }
    }
}

```
33:T1140,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1874)

<div className="text-center"><a href="https://www.acmicpc.net/problem/1874">https://www.acmicpc.net/problem/1874</a></div>

---

- 1부터 N까지 수열이 쌓여 있고 거기서 하나씩 넣고 꺼내는 방식이다.
- 예제에 따라 1부터 8까지 있다고 할때 처음 모양은 이러하다.

  | input | stack |
  | ----- | :---: |
  | 1     |       |
  | 2     |       |
  | 3     |       |
  | 4     |       |
  | 5     |       |
  | 6     |       |
  | 7     |       |
  | 8     |       |

- 처음 꺼내야하는 값이 4이므로 1부터 4까지를 stack에 넣고 +를 출력해줄때 상황

  | input | stack |
  | ----- | :---: |
  |       |       |
  |       |       |
  |       |       |
  |       |       |
  | 5     |   4   |
  | 6     |   3   |
  | 7     |   2   |
  | 8     |   1   |

    <h3>output: + + + +</h3>

- 그리고 4를 출력에 넣고 -를 출력한다.

  | input | stack |
  | ----- | :---: |
  |       |       |
  |       |       |
  |       |       |
  |       |       |
  | 5     |       |
  | 6     |   3   |
  | 7     |   2   |
  | 8     |   1   |

    <h3>output: + + + + -</h3>

- 그 다음 스택의 맨위의 값이 요구는 숫자 3과 같으므로 꺼낸다.

  | input | stack |
  | ----- | :---: |
  |       |       |
  |       |       |
  |       |       |
  |       |       |
  | 5     |       |
  | 6     |       |
  | 7     |   2   |
  | 8     |   1   |

    <h3>output: + + + + - -</h3>

- 다음 숫자는 6이니 6까지 숫자를 넣어준다.

  | input | stack |
  | ----- | :---: |
  |       |       |
  |       |       |
  |       |       |
  |       |   6   |
  |       |   5   |
  |       |   3   |
  | 7     |   2   |
  | 8     |   1   |

    <h3>output: + + + + - - + +</h3>

- stack의 맨 위가 6이 되었으므로 출력

  | input | stack |
  | ----- | :---: |
  |       |       |
  |       |       |
  |       |       |
  |       |       |
  |       |   5   |
  |       |   3   |
  | 7     |   2   |
  | 8     |   1   |

    <h3>output: + + + + - - + + -</h3>

- 위와 같은 동작을 반복한다.
- 만약 목표값이 현재 수열의 맨 위의 값보다 작은데 같지 않은 경우는 접근할 방법이 없으므로 NO를 출력한다.

---

```java

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.Stack;

/**
 * 스택 수열 문제 해결
 * 1부터 n까지의 수를 스택에 넣고 빼서 주어진 수열을 만들 수 있는지 확인하는 문제
 * 스택을 사용하여 시뮬레이션
 */
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int n = Integer.parseInt(br.readLine()); // 수열의 길이
        Stack<Integer> stack = new Stack<Integer>();
        StringBuilder sb = new StringBuilder(); // 연산 결과 저장

        int num = 0; // 현재까지 스택에 넣은 최대 숫자
        for (int i = 0; i < n; i++) {
            int goal = Integer.parseInt(br.readLine()); // 목표 숫자

            // 목표가 현재 숫자보다 큰 경우: 목표까지 숫자를 스택에 넣어야 함
            if (goal > num) {
                // num이 목표와 같아질 때까지 반복
                while (num < goal) {
                    // num을 늘려주면서 stack에 입력
                    num++;
                    stack.push(num);
                    sb.append("+\n");
                }
            }

            // 목표가 현재 숫자와 같거나 큰 상황에 스택 최상위 값과 같지 않을 경우
            // 아래 숫자로 접근할 수 없으므로 NO를 출력
            else if (stack.peek() != goal) {
                bw.write("NO");
                bw.flush();
                return;
            }

            // 목표가 현재 숫자와 같은 경우
            // 스택에서 맨 위의 값을 꺼내고 -를 출력
            stack.pop();
            sb.append("-\n");
        }

        bw.write(sb.toString());
        bw.flush();

        br.close();
        bw.close();
    }
}
```
34:T1032,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1157)

<div className="text-center"><a href="https://www.acmicpc.net/problem/1157">https://www.acmicpc.net/problem/1157</a></div>

---

- 첫번째 생각으로 HashMap에 넣고 Value로 정렬하기를 해보았다
- 코드가 너무 길긴하지만 범위를 정하기 어려울때는 쓰기 좋을것 같다.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

/**
 * 단어 공부 문제 해결 (방법 1 - HashMap 사용)
 * 가장 많이 사용된 알파벳을 찾는 문제
 * HashMap을 사용하여 각 알파벳의 개수를 세고 정렬
 */
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        char[] input = br.readLine().toCharArray();
        HashMap<Character, Integer> map = new HashMap<Character, Integer>();
        
        // 각 알파벳의 개수를 HashMap에 저장 (대소문자 구분 없음)
        for (int i = 0; i < input.length; i++) {
            char c = Character.toUpperCase(input[i]);
            map.put(c, (map.get(c) != null ? map.get(c) + 1 : 1));
        }

        // HashMap의 엔트리를 리스트로 변환하여 값 기준으로 정렬
        List<Map.Entry<Character, Integer>> entries = new ArrayList<>(map.entrySet());
        Collections.sort(entries, new Comparator<Map.Entry<Character, Integer>>() {
            @Override
            public int compare(Entry<Character, Integer> o1, Entry<Character, Integer> o2) {
                return o2.getValue() - o1.getValue(); // 내림차순 정렬
            }
        });

        // 가장 많이 사용된 알파벳이 여러 개면 "?" 출력, 아니면 해당 알파벳 출력
        bw.write((entries.size() > 1 && entries.get(0).getValue().equals(entries.get(1).getValue()) ? "?"
                : entries.get(0).getKey()) + "");
        bw.flush();

        br.close();
        bw.close();
    }
}
```

---

- 문제의 정석처럼 풀어지는 코드는 A~Z를 아스키코드 int형으로 배열을 맞춰서 카운트 해주는 방법

---

```java

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

/**
 * 단어 공부 문제 해결 (방법 2 - 배열 사용, 더 효율적)
 * 가장 많이 사용된 알파벳을 찾는 문제
 * 아스키 코드를 이용하여 배열 인덱스로 직접 접근
 */
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int[] counts = new int[26]; // A~Z까지의 개수를 저장하는 배열
        char[] input = br.readLine().toCharArray();

        // 각 알파벳의 개수를 배열에 저장
        for (char c : input) {
            int index = Character.toUpperCase(c) - 'A'; // A를 0으로 하는 인덱스 계산
            counts[index]++;
        }

        // 가장 많이 사용된 알파벳 찾기
        int max = 0;
        char c = ' ';
        for (int i = 0; i <= 'Z' - 'A'; i++) {
            if (max < counts[i]) {
                // 더 많이 사용된 알파벳을 찾으면 업데이트
                c = (char) (i + 65); // 'A'는 65
                max = counts[i];
            } else if (max == counts[i]) {
                // 같은 개수가 있으면 "?" 출력
                c = '?';
                break;
            }
        }

        bw.write(c + "");

        bw.flush();
        bw.close();
    }
}

```
35:Ta9c,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1654)

<div className="text-center"><a href="https://www.acmicpc.net/problem/1654">https://www.acmicpc.net/problem/1654</a></div>

---

- 랜선을 얼마나 자를 수 있는가에 대해 묻는 문제이다.
- 랜선길이를 보아하니 long 써야한다.
- 그냥 탐색을 돌리면 시간초과에 걸리니 이분 탐색을 사용한다.
- 이분 탐색에 대한 설명은 <a href="https://wootool.tistory.com/62">이 블로그 글</a>을 추천한다.
- 이분 탐색에 대한 설명에 맞춰 코드를 짠다.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.Arrays;

/**
 * 랜선 자르기 문제 해결
 * K개의 랜선을 잘라서 N개의 랜선을 만들 때, 만들 수 있는 최대 길이를 구하는 문제
 * 이분 탐색을 사용하여 최적의 길이를 찾음
 */
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        String[] input = br.readLine().split(" ");
        int k = Integer.parseInt(input[0]), n = Integer.parseInt(input[1]); // k: 가지고 있는 랜선 개수, n: 필요한 랜선 개수
        long[] ar = new long[k];

        // 랜선 길이 입력
        for (int i = 0; i < k; i++) {
            ar[i] = Long.parseLong(br.readLine());
        }
        br.close();
        Arrays.sort(ar); // 정렬

        long count = 0; // 만들 수 있는 랜선 개수
        long mid = 0; // 중간값
        long min = 1; // 최소 길이
        long len = ar[k - 1]; // 최대 길이 (가장 긴 랜선)
        
        // 이분 탐색
        while (len >= min) {
            mid = (len + min) / 2; // 중간 길이
            count = 0;
            
            // 각 랜선을 mid 길이로 자를 때 만들 수 있는 개수 계산
            for (long i : ar) {
                count += i / mid;
            }
            
            // 만들 수 있는 개수가 n 이상이면 더 긴 길이도 가능하므로 min 증가
            if (count >= n)
                min = mid + 1;
            // 만들 수 있는 개수가 n보다 작으면 길이를 줄여야 하므로 len 감소
            else if (count < n)
                len = mid - 1;
        }
        
        // 최종적으로 len이 최대 길이가 됨
        bw.write(len + "");
        bw.flush();
        bw.close();
    }
}

```
36:T624,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1436)

<div className="text-center"><a href="https://www.acmicpc.net/problem/1436">https://www.acmicpc.net/problem/1436</a></div>

---

- 666이 들어가는 숫자로 제목을 만드는것이다.
- 1666,2666,3666.....16661,....
- 숫자를 늘려서 문자열로 바꿔 666이 들어가는지 확인하여 몇번째인지 카운트한다.

---

```java

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

/**
 * 영화감독 숌 문제 해결
 * 666이 포함된 숫자 중 n번째 숫자를 찾는 문제
 * 브루트포스 알고리즘을 사용하여 666부터 시작하여 순차적으로 확인
 */
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int n = Integer.parseInt(br.readLine()); // n번째 666이 포함된 숫자
        int count = 0; // 찾은 개수
        String result = "";
        
        // 666부터 시작하여 "666"이 포함된 숫자를 찾음
        for (int i = 666; count < n; i++) {
            if ((i + "").contains("666")) {
                result = i + "";
                count++;
            }
        }

        bw.write(result);
        bw.flush();

        br.close();
        bw.close();
    }
}


```
37:T837,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/10816)

<div className="text-center"><a href="https://www.acmicpc.net/problem/10816">https://www.acmicpc.net/problem/10816</a></div>

---

- 숫자 카드가 몇번 나왔는가 카운트 해주면 된다.
- Map에 카드 숫자를 키로, 나온 횟수를 값으로 넣어줬다.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.HashMap;

/**
 * 숫자카드 2 문제 해결
 * 각 숫자 카드가 몇 개 있는지 세는 문제
 * HashMap을 사용하여 각 숫자의 개수를 저장
 */
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        
        // 숫자 카드를 키로, 개수를 값으로 저장하는 HashMap
        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
        
        int n = Integer.parseInt(br.readLine()); // 가지고 있는 숫자 카드 개수
        String[] input = br.readLine().split(" ");
        
        // 각 숫자 카드의 개수를 HashMap에 저장
        for (int i = 0; i < n; i++) {
            int key = Integer.parseInt(input[i]);
            // 이미 존재하면 개수 증가, 없으면 1로 초기화
            map.put(key, map.get(key) == null ? 1 : map.get(key) + 1);
        }

        int m = Integer.parseInt(br.readLine()); // 찾을 숫자 카드 개수
        input = br.readLine().split(" ");
        
        // 각 숫자 카드의 개수를 출력
        for (int i = 0; i < m; i++) {
            int key = Integer.parseInt(input[i]);
            // HashMap에 있으면 개수 출력, 없으면 0 출력
            bw.write((map.get(key) != null ? map.get(key) : 0) + " ");
        }
        bw.flush();

        br.close();
        bw.close();
    }
}
```
38:Tea0,
[![프로그래머스](https://file.newswire.co.kr/data/datafile2/thumb_640/2021/06/1993996598_20210610150326_5364622170.jpg)](https://programmers.co.kr/learn/courses/30/lessons/42839)

<div className="text-center"><a href="https://programmers.co.kr/learn/courses/30/lessons/42839">https://programmers.co.kr/learn/courses/30/lessons/42839</a></div>

- 입력받은 문자열을 문자하나씩 조개서 배열에 넣는다.
- 작성한 순열 생성 함수에서 한칸씩 진행한다.
- 문자 하나를 결과물에 넣고 순열 생성을 한글자 빼고 다시 문자배열에 넣기.
- 순열 생성 함수는 붙여야할 글자가 없을때까지 문자열을 붙여서 만든다. 단 0으로 시작하는건 제외.
- 문자열을 숫자로 만들어서 검사용 Set에 있는지 확인한다.
- 없다면 소수인지 확인하여 맞을 경우 count ++.

```java
import java.util.TreeSet;
import java.util.ArrayList;

/**
 * 소수 찾기 문제 해결
 * 주어진 숫자들로 만들 수 있는 소수의 개수를 구하는 문제
 * 순열을 생성하여 모든 숫자 조합을 만들고 소수인지 확인
 */
class Solution {
    TreeSet<Integer> set = new TreeSet<Integer>(); // 중복 제거를 위한 Set
    int count=0; // 소수 개수

    public int solution(String numbers) {
        ArrayList<Character> chars = new ArrayList<Character>();
        ArrayList<Character> results = new ArrayList<Character>();

        int num_len = numbers.length();
        // 입력받은 문자열을 문자 하나씩 배열에 넣음
        for(int i=0;i<num_len;i++) chars.add(numbers.charAt(i));

        // 1자리부터 num_len자리까지 모든 순열 생성
        for(int i=0;i<num_len;i++)
            permutation(chars,results,num_len,i+1);

        return count;
    }

    /**
     * 순열 생성 함수 (백트래킹)
     * @param chars: 사용 가능한 문자들
     * @param result: 현재까지 선택한 문자들
     * @param n: 남은 문자 개수
     * @param r: 선택해야 할 문자 개수
     */
    private void permutation(ArrayList<Character> chars, ArrayList<Character> result, int n, int r) {
        if (r == 0) {
            // 0으로 시작하는 숫자는 제외
            if (result.get(0) != '0') {
                String str = "";
                int len = result.size();
                // 선택한 문자들을 문자열로 합침
                for (int i = 0; i < len; i++) {
                    str += result.get(i);
                }

                int num = Integer.parseInt(str);
                // 중복 체크: 이미 확인한 숫자는 건너뜀
                if (!set.contains(num)) {
                    set.add(num);
                    // 소수인지 확인
                    if (isPrime(num)) {
                        count++;
                    }
                }
                return;
            }

        }
        // 백트래킹: 문자를 하나씩 선택하여 순열 생성
        for (int i = 0; i < n; i++) {
            result.add(chars.remove(i)); // 문자 선택
            permutation(chars, result, n - 1, r - 1); // 재귀 호출
            chars.add(i, result.remove(result.size() - 1)); // 백트래킹: 원상복구
        }
    }

    /**
     * 소수 판별 함수
     * @param num: 판별할 숫자
     * @return: 소수이면 true, 아니면 false
     */
    private boolean isPrime(int num) {
        if (num == 2)
            return true;
        if (num == 1 || num % 2 == 0)
            return false;
        // 3부터 제곱근까지 홀수만 확인
        for (int i = 3; i <= (int) Math.sqrt(num); i += 2)
            if (num % i == 0)
                return false;
        return true;
    }
}
```
39:T63b,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1697)

<div className="text-center"><a href="https://www.acmicpc.net/problem/1697">https://www.acmicpc.net/problem/1697</a></div>

---

- 수빈의 위치(N)에서 동생의 위치(K)로 가기 위해 몇 번 걸리는가 묻고 있다.
- 방문 기록을 세우고 거기에 카운트를 쓴다.
- 큐에 순서를 넣고 맨 앞을 꺼내면서 체크한다.

---

```python
import sys

/**
 * 숨바꼭질 문제 해결
 * 수빈의 위치(N)에서 동생의 위치(K)로 가는 최소 시간을 구하는 문제
 * BFS를 사용하여 최단 경로 탐색
 */

sys.setrecursionlimit(10000000)

n,k = (int(i) for i in sys.stdin.readline().split()) # n: 수빈 위치, k: 동생 위치
visit = [0]*100001 # 방문 기록과 시간을 저장하는 배열
q = [n] # BFS를 위한 큐

while(q.count!=0):
    pos = q.pop(0) # 현재 위치

    # 동생의 위치에 도달했으면 시간 출력하고 종료
    if(pos==k): print(visit[pos]); break

    # +1 이동: 범위 내이고 방문하지 않았으면
    if(pos+1<=100000 and visit[pos+1]==0):
        q.append(pos+1)
        visit[pos+1] = visit[pos]+1 # 시간 증가

    # -1 이동: 범위 내이고 방문하지 않았으면
    if(pos-1>=0 and visit[pos-1]==0):
        q.append(pos-1)
        visit[pos-1] = visit[pos]+1 # 시간 증가

    # *2 이동: 범위 내이고 방문하지 않았으면
    if(pos*2<=100000 and visit[pos*2] ==0 ):
        q.append(pos*2)
        visit[pos*2] = visit[pos]+1 # 시간 증가

```
3a:T900,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/11866)

<div className="text-center"><a href="https://www.acmicpc.net/problem/11866">https://www.acmicpc.net/problem/11866</a></div>

---

- 1부터 N까지 수열을 놓고 K번째 숫자를 하나씩 빼서 출력해줘야 한다.
- 스택에 숫자를 넣어놓고 인덱스를 K씩 더해줘서 빼낼거다.
- 시작 인덱스는 K가 N보다 크지 않으니 K를 넣되 인덱스는 0부터 니까 1을 뺀다.
- 그 다음 스택의 길이보다 크거나 같으면 스택의 인덱스보다 커지므로 나머지를 이용하여 빼준다.
- 반복

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.ArrayList;

/**
 * 요세푸스 문제 0 해결
 * 1부터 N까지의 수열에서 K번째 숫자를 제거하는 과정을 반복하는 문제
 * ArrayList를 사용하여 인덱스로 접근
 */
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        String[] input = br.readLine().split(" ");
        int n = Integer.parseInt(input[0]), k = Integer.parseInt(input[1]); // n: 사람 수, k: 제거할 간격
        ArrayList<Integer> list = new ArrayList<Integer>();
        
        // 1부터 n까지 리스트에 추가
        for (int i = 1; i <= n; i++)
            list.add(i);

        bw.write("<");

        // 시작 인덱스는 k-1 (0부터 시작하므로)
        for (int i = k - 1; !list.isEmpty(); i += k) {
            // 인덱스가 리스트 크기를 넘어가면 나머지 연산으로 조정
            if (i >= list.size())
                i %= list.size();
            
            // 해당 인덱스의 원소를 제거하고 출력
            bw.write(list.remove(i) + "");

            if (!list.isEmpty())
                bw.write(", ");
            i--; // 원소를 제거했으므로 인덱스 조정
        }
        bw.write(">");
        bw.flush();

        br.close();
        bw.close();

    }
}


```
3b:T7c7,
[![프로그래머스](https://file.newswire.co.kr/data/datafile2/thumb_640/2021/06/1993996598_20210610150326_5364622170.jpg)](https://programmers.co.kr/learn/courses/30/lessons/42840)

<div className="text-center"><a href="https://programmers.co.kr/learn/courses/30/lessons/42840">https://programmers.co.kr/learn/courses/30/lessons/42840</a></div>

- 수포자 셋의 패턴을 배열로 바꾼다.
- 맞은 갯수를 배열에 저장하고 제일 큰 값을 표시한다.
- 가변 배열을 위해 ArrayList를 써서 제일 큰 값과 같은 수포자를 넣고 배열을 반환한다.

```java
import java.util.ArrayList;

/**
 * 모의고사 문제 해결
 * 세 수포자의 찍기 패턴과 정답을 비교하여 가장 많이 맞춘 사람을 찾는 문제
 */
class Solution {
    public int[] solution(int[] answers) {
        int[] counter = new int[3]; // 각 수포자가 맞춘 개수
        // 수포자 셋의 패턴을 배열로 저장
        int[][] pattern = { { 1, 2, 3, 4, 5 }, { 2, 1, 2, 3, 2, 4, 2, 5 }, { 3, 3, 1, 1, 2, 2, 4, 4, 5, 5 } };
        int[] lens = { 5, 8, 10 }; // 각 패턴의 길이
        int max = 0; // 최대 맞춘 개수
        
        // 각 수포자의 정답 개수 계산
        for (int i = 0; i < 3; i++) {
            int count = 0;
            for (int j = 0; j < answers.length; j++) {
                // 패턴이 반복되므로 나머지 연산 사용
                if (pattern[i][(j % lens[i])] == answers[j]) {
                    count++;
                }
            }
            if (max < count)
                max = count;
            counter[i] = count;
        }
        
        // 가장 많이 맞춘 수포자들을 리스트에 추가
        ArrayList<Integer> list = new ArrayList<Integer>();
        for (int i = 0; i < 3; i++)
            if (counter[i] == max)
                list.add(i + 1); // 수포자 번호는 1부터 시작

        return list.stream().mapToInt(i -> i).toArray();
    }
}
```
3c:Tad1,
[![프로그래머스](https://file.newswire.co.kr/data/datafile2/thumb_640/2021/06/1993996598_20210610150326_5364622170.jpg)](https://programmers.co.kr/learn/courses/30/lessons/42583)

<div className="text-center"><a href="https://programmers.co.kr/learn/courses/30/lessons/42583">https://programmers.co.kr/learn/courses/30/lessons/42583</a></div>

- 대기중인 트럭에서 한대씩 꺼낸다.
- 다리의 현재하중(bridge_weight)를 체크하여 견딜 수 있을 경우 트럭을 올린다(bridge_weight+트럭무게,큐에 트럭삽입).
- 견디지 못할 경우 큐에 0을 집어 넣는다.
- 걸리는 시간에 올라가는 시간을 무게한도 만큼 1씩 더해주고 마지막 트럭이 나가는 다리의 길이 만큼의 시간을 더해준다.

```java
import java.util.Queue;
import java.util.LinkedList;

/**
 * 다리를 지나는 트럭 문제 해결
 * 트럭이 다리를 건너는데 걸리는 시간을 구하는 문제
 * 큐를 사용하여 다리 위의 트럭을 관리
 */
class Solution {
    public int solution(int bridge_length, int weight, int[] truck_weights) {
        // 결과 시간(time)과 현재 다리의 하중(bridge_weight)를 선언
        int time = 0, bridge_weight = 0;
        // 다리 위의 상황을 Queue로 선언
        Queue<Integer> on_bridge = new LinkedList<Integer>();
        
        // 나가야하는 트럭 개수만큼 반복
        for (int i = 0; i < truck_weights.length;) {
            // 현재 다리의 하중이 견딜 수 있는 무게보다 적고 아직 나가야하는 트럭이 남아있다면 반복
            while (bridge_weight < weight && i < truck_weights.length) {
                // 올라갈 때 시간 추가
                time++;
                // 현재 다리 하중에 트럭의 무게를 더함
                bridge_weight += truck_weights[i];
                // 다리 상태 큐에 트럭의 무게를 기록
                on_bridge.add(truck_weights[i]);
                i++;
            }

            // 위 조건에서 무게가 초과하여 while문이 끝날 경우
            if (bridge_weight > weight) {
                // 다리 위 트럭이 나갈 때까지 기다리는 시간을 더함 (다리 길이만큼)
                time += bridge_length;
                // 트럭이 나갔으니 Queue를 비움
                while (!on_bridge.isEmpty()) {
                    bridge_weight -= on_bridge.poll();
                }
            }
        }
        // 무게는 초과하지 않았지만 다리에 남아있는 트럭이 있는 경우
        if (!on_bridge.isEmpty())
            // 마지막 트럭이 나가는 시간을 더해줌 (다리 길이만큼)
            time += bridge_length;
        return time;
    }
}
```
3d:T90e,
[![프로그래머스](https://file.newswire.co.kr/data/datafile2/thumb_640/2021/06/1993996598_20210610150326_5364622170.jpg)](https://programmers.co.kr/learn/courses/30/lessons/42586)

<div className="text-center"><a href="https://programmers.co.kr/learn/courses/30/lessons/42586">https://programmers.co.kr/learn/courses/30/lessons/42586</a></div>

- 기능별로 필요한 기간을 배열로 만들어줍니다.
- 기능별로 비교하는데 앞의 기간이 뒤의 기간보다 클경우 계속 한번에 배포해야하는 양이 커지므로 complete라는 변수를 키웁니다.
- 그렇게 키운 complete가 뒤의 기간이 더 클 경우 break문으로 나와서 배열에 넣어줍니다.

```java
import java.util.ArrayList;

/**
 * 기능개발 문제 해결
 * 각 기능의 개발 속도에 따라 배포되는 기능의 개수를 구하는 문제
 * 앞의 기능이 완료되어야 뒤의 기능도 배포 가능
 */
class Solution {
    public int[] solution(int[] progresses, int[] speeds) {
        int[] answer = {};
        ArrayList<Integer> list = new ArrayList<Integer>();
        int[] ar = new int[progresses.length];
        
        // 각 기능이 완료되는데 필요한 일수 계산
        for(int i=0;i<progresses.length;i++){
            // 남은 작업량을 속도로 나눔 (나머지가 있으면 +1일)
            ar[i]=(100-progresses[i])/speeds[i]+((100-progresses[i])%speeds[i]>0?1:0);
        }
        
        // 각 배포마다 배포되는 기능 개수 계산
        for(int i=0;i<ar.length;i++){
            int complete=1; // 현재 기능 포함
            // 뒤의 기능들 중 현재 기능보다 일찍 또는 같이 완료되는 것들 확인
            for(int j=i+1;j<ar.length;j++){
                // 뒤의 기능이 더 늦게 완료되면 중단
                if(ar[i]<ar[j]){
                    i=j-1; // 다음 배포 시작 위치
                    break;
                }else if(j==ar.length-1){
                    i=j; // 마지막까지 확인
                }
                complete++; // 같이 배포되는 기능 개수 증가
            }
            list.add(complete);
        }

        answer = new int[list.size()];
        for(int i=0;i<list.size();i++)answer[i]=list.get(i);
        return answer;
    }
}
```
3e:T544,
[![프로그래머스](https://file.newswire.co.kr/data/datafile2/thumb_640/2021/06/1993996598_20210610150326_5364622170.jpg)](https://programmers.co.kr/learn/courses/30/lessons/42584)

<div className="text-center"><a href="https://programmers.co.kr/learn/courses/30/lessons/42584">https://programmers.co.kr/learn/courses/30/lessons/42584</a></div>

- 시간별로 하나씩 꺼낸다.
- 시간이 흐를때 꺼낸 값보다 더 작은 값일 경우 answer 배열의 값을 1씩 늘려준다.
- 더 큰값이 나올 경우 break;

```java
/**
 * 주식가격 문제 해결
 * 각 시점의 주식 가격이 떨어지지 않은 기간을 구하는 문제
 * 이중 반복문을 사용하여 각 시점부터 가격이 떨어질 때까지의 시간 계산
 */
class Solution {
    public int[] solution(int[] prices) {
        int[] answer = new int[prices.length];
        int len = prices.length;
        
        // 각 시점에서 가격이 떨어지지 않은 기간 계산
        for(int i=0;i<len;i++){
            // 현재 시점 이후의 가격들을 확인
            for(int j=i+1;j<len;j++){
                answer[i]++; // 시간 증가
                // 가격이 떨어지면 중단
                if(prices[i]>prices[j]){
                    break;
                }
            }
        }
        return answer;
    }
}
```
3f:T747,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/10250)

<div className="text-center"><a href="https://www.acmicpc.net/problem/10250">https://www.acmicpc.net/problem/10250</a></div>

---

- 호텔을 높이로 잘라서 반복하면 끝

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

/**
 * ACM 호텔 문제 해결
 * 호텔 방 번호를 구하는 문제
 * 방 배정 순서: 1층부터 H층까지 순서대로, 같은 층에서는 1호부터 W호까지
 */
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        int t = Integer.parseInt(br.readLine()); // 테스트 케이스 개수

        for (int a = 0; a < t; a++) {
            // 입력: H(층 수), W(각 층의 방 수), N(N번째 손님)
            String[] input = br.readLine().split(" ");
            int h = Integer.parseInt(input[0]), w = Integer.parseInt(input[1]), n = Integer.parseInt(input[2]);
            
            // front: 층 수 (나머지 연산으로 구함)
            // back: 호 수 (몫 연산으로 구함)
            int front = n % h, back = n / h;

            // 방 번호 계산: YXX 형태 (Y는 층, XX는 호)
            // n % h == 0인 경우: 마지막 층에 배정되므로 h층
            // 그 외: n % h 층에 배정
            // 호 수는 n % h == 0이면 back, 아니면 back + 1
            bw.write((front == 0 ? h : front) * 100 + (front == 0 ? back : back + 1) + "\n");
            bw.flush();
        }
        br.close();
        bw.close();
    }
}
```
40:T1938,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1197)

<div className="text-center"><a href="https://www.acmicpc.net/problem/1197">https://www.acmicpc.net/problem/1197</a></div>

---

- '최소 스패닝 트리'에 대한 설명이 적혀있는데 잘 모르겠다.

  - 검색해보니 크루스칼 알고리즘을 쓰라는데 그렇다면 크루스칼 알고리즘은 또 무엇인가?
    ![](/media/ac1197/1.jpg)
  - 위와 같은 노드와 노드를 잇는 가중치가 주어질때 최소값으로 정렬 후 '순환하지 않게' 모두 이어준다.
  - 가중치 정렬표

  | B-C | A-B | D-E | B-D | C-E | A-D | A-E | C-D |
  | --- | --- | --- | --- | --- | --- | --- | --- |
  | 1   | 3   | 3   | 4   | 4   | 5   | 7   | 8   |

  - 이제 저기서 최소값부터 하나씩 이어준다.
    ![](/media/ac1197/2.jpg)
    이렇게 잇기 시작해서
    ![](/media/ac1197/3.jpg)
    하나씩 연결해주는데 저렇게 모든 점들이 연결되고 C-E도 4이긴 하지만 연결시 순환되므로 생략한다.
    https://yabmoons.tistory.com/186를 참조했습니다.

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.stream.IntStream;

/**
 * 최소 스패닝 트리 문제 해결 (방법 1)
 * 크루스칼 알고리즘을 사용하여 최소 스패닝 트리를 구함
 * Union-Find를 사용하여 사이클을 방지
 */
public class Main {
    static int[] parent; // Union-Find를 위한 부모 배열

    /**
     * Union-Find: 정점의 루트를 찾는 함수 (경로 압축 적용)
     */
    public static int find(int x) {
        if (parent[x] == x) {
            return x; // 루트 노드
        }
        // 경로 압축: 부모를 루트로 직접 연결
        return parent[x] = find(parent[x]);
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] input = reader.readLine().split(" ");
        int v = Integer.parseInt(input[0]), e = Integer.parseInt(input[1]); // 정점 수, 간선 수
        ArrayList<int[]> ar = new ArrayList<int[]>(); // 간선 리스트 [시작, 끝, 가중치]
        parent = IntStream.range(0, v + 1).toArray(); // Union-Find 초기화
        int sum = 0; // 최소 스패닝 트리의 총 가중치

        // 간선 정보 입력
        for (int i = 0; i < e; i++) {
            input = reader.readLine().split(" ");
            int[] temp = new int[3];
            for (int j = 0; j < 3; j++)
                temp[j] = Integer.parseInt(input[j]);
            ar.add(temp);
        }

        // 간선을 가중치 기준으로 오름차순 정렬
        ar.sort(Comparator.comparing(o -> o[2]));

        // 크루스칼 알고리즘: 가중치가 작은 간선부터 선택
        for (int[] x : ar) {
            int a = find(x[0]), b = find(x[1]); // 두 정점의 루트 찾기
            if (a != b) { // 다른 집합에 속해있으면 (사이클이 없으면)
                sum += x[2]; // 가중치 추가
                parent[b] = a; // 두 집합을 합침
            }
        }

        System.out.println(sum);
    }
}
```

- 일단 답은 맞췄는데 메모리가 범람했다. 메모리계의 을지문덕이 되었다.
  ![](/media/ac1197/4.jpg)

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.PriorityQueue;
import java.util.StringTokenizer;
import java.util.stream.IntStream;

/**
 * 최소 스패닝 트리 문제 해결 (방법 2 - 메모리 최적화)
 * PriorityQueue를 사용하여 정렬 대신 우선순위 큐 활용
 * 커스텀 클래스를 사용하여 메모리 사용량 감소
 */
public class Main {
    /**
     * 간선을 나타내는 클래스
     * a: 시작 정점, b: 끝 정점, c: 가중치
     */
    static class Node implements Comparable<Node> {
        int a, b, c;

        Node(int a, int b, int c) {
            this.a = a;
            this.b = b;
            this.c = c;
        }

        @Override
        public int compareTo(Node arg0) {
            // 가중치 기준 오름차순 정렬
            return arg0.c >= this.c ? -1 : 1;
        }
    }

    static int[] parent; // Union-Find를 위한 부모 배열

    /**
     * Union-Find: 정점의 루트를 찾는 함수 (경로 압축 적용)
     */
    public static int find(int x) {
        if (parent[x] == x) {
            return x; // 루트 노드
        }
        // 경로 압축: 부모를 루트로 직접 연결
        return parent[x] = find(parent[x]);
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer input = new StringTokenizer(reader.readLine());
        int v = Integer.parseInt(input.nextToken()), e = Integer.parseInt(input.nextToken()); // 정점 수, 간선 수
        PriorityQueue<Node> ar = new PriorityQueue<Node>(); // 우선순위 큐 (가중치가 작은 것부터)
        parent = IntStream.range(0, v + 1).toArray(); // Union-Find 초기화
        int sum = 0; // 최소 스패닝 트리의 총 가중치

        // 간선 정보를 우선순위 큐에 추가
        for (int i = 0; i < e; i++) {
            input = new StringTokenizer(reader.readLine());
            ar.add(new Node(Integer.parseInt(input.nextToken()), Integer.parseInt(input.nextToken()),
                    Integer.parseInt(input.nextToken())));
        }
        input = null;
        reader.close();

        // 크루스칼 알고리즘: 가중치가 작은 간선부터 선택
        while (!ar.isEmpty()) {
            Node x = ar.poll(); // 가장 가중치가 작은 간선
            int a = find(x.a), b = find(x.b); // 두 정점의 루트 찾기
            if (a != b) { // 다른 집합에 속해있으면 (사이클이 없으면)
                sum += x.c; // 가중치 추가
                parent[b] = a; // 두 집합을 합침
            }
        }

        System.out.println(sum);
    }
}
```

- 커스텀 클래스로 만들어서 Comparable를 받아서 만들어주니 메모리가 많이 줄었다.
- 정렬을 커스텀으로 하는게 메모리를 많이 먹나보다.
  ![](/media/ac1197/5.jpg)
41:Tb80,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1149)

<div className="text-center"><a href="https://www.acmicpc.net/problem/1149">https://www.acmicpc.net/problem/1149</a></div>

---

> i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.

- 이 문장을 읽으면 순간 복잡하게 생각이 들었지만 따지고 보면 그냥 앞집의 색과 다르면 그만이다
- 도색에 드는 비용이 들어있는 배열(ar) | 여태까지 겹치지 않고 최소값으로 도배를 해온 비용으로 나누어 배열(dp)을 만들어 채운다.
- 최소도색비용 배열(dp)을 채울때 위에서 색을 정하고(dp[i-1][0])
- 이전 줄(dp[i-1])의 겹치지 않는 색의 최소도배비용을 비교하여 더 작은값(dp[i-1][1] < dp[i-1][2]?)과 현재 집에 선택한 색의 도색비용을 더해준다(+ar[i][0]).

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

/**
 * RGB거리 문제 해결
 * 인접한 집은 같은 색으로 칠할 수 없을 때, 모든 집을 칠하는 최소 비용을 구하는 문제
 * 다이나믹 프로그래밍을 사용하여 각 집을 각 색으로 칠할 때의 최소 비용을 계산
 */
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(reader.readLine()); // 집의 개수
        int[][] ar = new int[n][3], dp = new int[n][3]; // ar: 각 집의 RGB 비용, dp: 최소 비용

        // 각 집의 RGB 비용 입력
        for (int i = 0; i < n; i++) {
            ar[i] = Arrays.stream(reader.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
        }

        // 첫 번째 집은 그대로 초기화
        dp[0] = ar[0];
        
        // 두 번째 집부터: 이전 집과 다른 색을 선택하여 최소 비용 계산
        for (int i = 1; i < n; i++) {
            // i번째 집을 빨강(0)으로 칠할 때: 이전 집은 초록 또는 파랑 중 최소 비용 선택
            dp[i][0] = (dp[i - 1][1] < dp[i - 1][2] ? dp[i - 1][1] : dp[i - 1][2]) + ar[i][0];
            // i번째 집을 초록(1)으로 칠할 때: 이전 집은 빨강 또는 파랑 중 최소 비용 선택
            dp[i][1] = (dp[i - 1][0] < dp[i - 1][2] ? dp[i - 1][0] : dp[i - 1][2]) + ar[i][1];
            // i번째 집을 파랑(2)으로 칠할 때: 이전 집은 빨강 또는 초록 중 최소 비용 선택
            dp[i][2] = (dp[i - 1][0] < dp[i - 1][1] ? dp[i - 1][0] : dp[i - 1][1]) + ar[i][2];
        }

        // 마지막 집의 세 가지 색 중 최소 비용 선택
        int min = dp[n - 1][0] < dp[n - 1][1] ? dp[n - 1][0] : dp[n - 1][1];
        System.out.println(min < dp[n - 1][2] ? min : dp[n - 1][2]);
    }
}

```
42:T62b,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1013)

<div className="text-center"><a href="https://www.acmicpc.net/problem/1013">https://www.acmicpc.net/problem/1013</a></div>

---

> “무한히 넓은 저 우주에 인류만이 홀로 존재한다면, 그건 정말 슬픈 일이 아닐까요”

- 이걸 풀고 난 후에 나는 혼자 있고 싶어졌다.

- 문제에서 표기법의 규칙에 대해 설명해준 뒤
- (100+1+ | 01)+ 에 맞는 지 확인하여 YES와 NO를 출력하라고 했다

- 정규식을 쓰면 손쉽다. 그렇다 처음엔 생각 못해서 안쉬웠다.

```java

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 * Contact 문제 해결
 * 주어진 문자열이 특정 패턴 (100+1+ | 01)+ 에 맞는지 확인하는 문제
 * 정규식을 사용하여 간단하게 해결
 */
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(reader.readLine()); // 테스트 케이스 개수

        for (int i = 0; i < n; i++) {
            String input = reader.readLine();
            // 정규식 패턴: (100+1+ | 01)+
            // 100+1+: "1" 다음에 "0"이 1개 이상, 그 다음 "1"이 1개 이상
            // 01: "01" 패턴
            // +: 위 패턴이 1번 이상 반복
            System.out.println(input.matches("(100+1+|01)+") ? "YES" : "NO");
        }
    }
}

```
43:Td85,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1008)

<div className="text-center"><a href="https://www.acmicpc.net/problem/1008">https://www.acmicpc.net/problem/1008</a></div>

---

- 가로 m 세로 n의 배추밭에 배추를 심고 배추 보호를 위해 순찰도는 배추흰지렁이를 밭에 풀려고 한다. 비용절감을 위해 필요한 만큼만 풀어야 한다.
- 배추흰지렁이는 인접한 배추들로 이동할 수 있으므로 지렁이가 배추가 보이면 한마리 놓고 붙어있는 배추들을 지도에서 지워주자
- 인접했다는 말은 배추의 위치를 2차원 좌표로 (x,y) 라고 할때

  |         |         |       |
  | ------- | ------- | ----- |
  |         | (x,y+1) |       |
  | (x-1,y) | (x,y)   | (x+1) |
  |         | (x,y-1) |       |

- 재귀를 이용해서 근처를 전부 탐색하고 지도 밖으로 나가거나 배추가 없을 경우 멈추는 함수를 만든다.

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

/**
 * 유기농 배추 문제 해결
 * 배추밭에서 인접한 배추 그룹의 개수를 구하는 문제
 * DFS를 사용하여 연결된 배추들을 탐색
 */
public class Main {
    static int[][] ar; // 배추밭 지도

    /**
     * DFS를 사용하여 인접한 배추들을 모두 탐색하고 제거
     * @param x: 현재 x 좌표
     * @param y: 현재 y 좌표
     * @param m: 배추밭 가로 길이
     * @param n: 배추밭 세로 길이
     */
    public static void finder(int x, int y, int m, int n) {
        // 범위를 벗어나거나 배추가 없으면 종료
        if (x >= m || y >= n || x < 0 || y < 0 || ar[y][x] == 0)
            return;
        
        // 현재 위치의 배추를 제거 (방문 표시)
        ar[y][x] = 0;
        
        // 상하좌우 4방향으로 재귀 탐색
        finder(x + 1, y, m, n); // 오른쪽
        finder(x, y + 1, m, n); // 아래
        finder(x - 1, y, m, n); // 왼쪽
        finder(x, y - 1, m, n); // 위
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine()); // 테스트 케이스 개수
        
        for (int i = 0; i < n; i++) {
            // 입력: 가로(m), 세로(n), 배추 개수(k)
            int[] data = Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
            ar = new int[data[1]][data[0]]; // 배추밭 초기화
            
            // 배추 위치 입력
            for (int j = 0; j < data[2]; j++) {
                int[] pos = Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
                ar[pos[1]][pos[0]] = 1; // 배추 위치 표시
            }

            // 연결된 배추 그룹의 개수 세기
            int count = 0;
            for (int y = 0; y < data[1]; y++) {
                for (int x = 0; x < data[0]; x++) {
                    if (ar[y][x] == 1) {
                        count++; // 새로운 그룹 발견
                        finder(x, y, data[0], data[1]); // 연결된 모든 배추 탐색 및 제거
                    }
                }
            }
            System.out.println(count); // 필요한 지렁이 개수 출력
        }
    }
}
```
44:T9bd,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1003)

<div className="text-center"><a href="https://www.acmicpc.net/problem/1003">https://www.acmicpc.net/problem/1003</a></div>

---

- 피보나치 함수에서 0과 1이 몇번 출력 되는지 묻는다.
  > 0과 1이 몇번 나오는 지 세보자

| n   | 0이 나오는 횟수 | 1이 나오는 횟수 |
| --- | :-------------: | :-------------: |
| 0   |        1        |        0        |
| 1   |        0        |        1        |
| 2   |        1        |        1        |
| 3   |        1        |        2        |
| 4   |        2        |        3        |
| 5   |        3        |        5        |
| 6   |        5        |        8        |
| 7   |        8        |       13        |
| 8   |       13        |       21        |
| 9   |       21        |       34        |

- 0이 나오는 횟수는 n이 1부터, 1이 나오는 횟수 n이 0부터 수열이 시작된다.
- 다행히 문제가 n이 40까지로 제한되어 있다.
- 0일 경우를 예외처리하고 그 다음부터는 수열 값을 출력해주면 된다.

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 * 피보나치 함수 문제 해결
 * 피보나치 함수에서 0과 1이 출력되는 횟수를 구하는 문제
 * 다이나믹 프로그래밍을 사용하여 미리 계산
 */
public class Main {

    public static void main(String[] args) throws IOException {
        // 피보나치 수열을 미리 계산 (n은 최대 40)
        int[] ar = new int[41];
        ar[0] = 0; // 피보나치(0) = 0
        ar[1] = 1; // 피보나치(1) = 1
        ar[2] = 1; // 피보나치(2) = 1

        // 피보나치 수열 계산: F(n) = F(n-2) + F(n-1)
        for (int i = 3; i < 41; i++)
            ar[i] = ar[i - 2] + ar[i - 1];

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String in = reader.readLine();
        int testCases = Integer.parseInt(in);
        
        for (int i = 0; i < testCases; i++) {
            int n = Integer.parseInt(reader.readLine());
            // n=0일 때: 0이 1번, 1이 0번 출력
            // n=1일 때: 0이 0번, 1이 1번 출력
            // n>=2일 때: 0이 나오는 횟수 = ar[n-1], 1이 나오는 횟수 = ar[n]
            System.out.println((n == 0 ? "1 0" : n == 1 ? "0 1" : ar[n - 1] + " " + ar[n]));
        }
    }
}
```
45:T93f,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/15649)

<div className="text-center"><a href="https://www.acmicpc.net/problem/15649">https://www.acmicpc.net/problem/15649</a></div>

---

- 자연수 수열을 만드는 문제다.
- 갯수의 카운트를 올라가며 만들어놓은 배열에 넣으면서 방문목록을 체크한다.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.StringTokenizer;

/**
 * N과 M(1) 문제 해결
 * 1부터 N까지의 자연수 중에서 중복 없이 M개를 고른 수열을 모두 구하는 문제
 * 백트래킹을 사용하여 순열을 생성
 */
class Main {
    static BufferedReader br;
    static BufferedWriter bw;
    static int[] ar; // 현재까지 선택한 수열
    static boolean[] visited; // 방문 여부 체크
    static int m, n; // n: 자연수 범위, m: 선택할 개수

    public static void main(String[] args) throws java.lang.Exception {
        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st = new StringTokenizer(br.readLine());
        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        ar = new int[m + 1];
        visited = new boolean[n + 1];
        func(0); // 백트래킹 시작
        bw.flush();
    }

    /**
     * 백트래킹을 사용하여 순열 생성
     * @param cnt: 현재까지 선택한 숫자의 개수
     */
    public static void func(int cnt) throws IOException {
        // m개를 모두 선택했으면 수열 출력
        if (cnt == m) {
            for (int i = 0; i < m; i++)
                bw.write(ar[i] + " ");
            bw.write("\n");
            return;
        }
        
        // 1부터 n까지의 숫자를 순회
        for (int i = 1; i <= n; i++) {
            if (!visited[i]) { // 아직 사용하지 않은 숫자면
                visited[i] = true; // 방문 표시
                ar[cnt] = i; // 수열에 추가
                func(cnt + 1); // 다음 숫자 선택
                visited[i] = false; // 백트래킹: 방문 표시 해제
            }
        }
    }
}
```
46:T7c0,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/11650)

<div className="text-center"><a href="https://www.acmicpc.net/problem/11650">https://www.acmicpc.net/problem/11650</a></div>

---

- 간단한 정렬문제다.
- Array.stream에서 comparing을 쓰는 것보다 클래스를 만들어서 Comparable을 쓰는게 빠르다.

---

```java

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.Arrays;

/**
 * 좌표 정렬하기 문제 해결
 * 좌표를 x좌표 오름차순, x좌표가 같으면 y좌표 오름차순으로 정렬
 */

/**
 * 좌표를 나타내는 클래스
 */
class Node implements Comparable<Node> {
    public int x, y; // x좌표, y좌표

    public Node(int x, int y) {
        this.x = x;
        this.y = y;
    }

    /**
     * 정렬 기준: x좌표 오름차순, x좌표가 같으면 y좌표 오름차순
     */
    @Override
    public int compareTo(Node o) {
        return this.x == o.x ? this.y - o.y : this.x - o.x;
    }

}

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int n = Integer.parseInt(br.readLine()); // 좌표 개수
        Node[] ar = new Node[n];
        
        // 좌표 입력
        for (int i = 0; i < n; i++) {
            String[] input = br.readLine().split(" ");
            ar[i] = new Node(Integer.parseInt(input[0]), Integer.parseInt(input[1]));
        }
        
        // 정렬 수행
        Arrays.sort(ar);
        
        // 정렬된 결과 출력
        for (Node o : ar) {
            bw.write(o.x + " " + o.y + "\n");
            bw.flush();
        }
        br.close();
        bw.close();
    }
}


```
47:Te0b,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1002)

<div className="text-center"><a href="https://www.acmicpc.net/problem/1002">https://www.acmicpc.net/problem/1002</a></div>

---

- 백승환과 조규현에게 류재명과의 거리를 구해 류재명이 있을 수 있는 위치를 구하는 좌표를 구하라고 한다.
- 백승환과 조규현의 위치는 좌표점으로 제공된다.
- 두 점에서 목표까지의 거리가 나와 있고 두 점간의 거리를 구해서 가장 큰 값과 세 거리의 합(sum)에서 가장 큰 값(max)을 뺀 값을 구한다.
- 원의 방정식을 사용할것이다.
- 백승환과 류재명의 거리 r1 , 조규현과 류재명의 거리 r2 , 백승환과 조규현의 거리 r3 라고 할때 조건을 따라가보자

  - r1과 r2가 같고 r3가 0이다 => r1과r2가 같은 위치 => 원이 완벽하게 겹쳐서 무수하게 많은 수 => -1

  - r1 + r2 == r3 => r1로 그린 원과 r2로 그린 원의 중점의 거리가 r3일때 두 원은 한점에서 만나게 된다 => 1
    ![](/media/ac1002/2.jpg)
  - r1+r2+r3-max = max => r3로 그린 원과 r1 또는 r2로 그린 원 하나가 내접 => 1
    ![](/media/ac1002/4.jpg)
  - max>sum => 두 원의 지름보다 합의 거리가 더 기므로 원이 만나지 않음 => 0
    ![](/media/ac1002/1.jpg)
  - 앞의 조건을 다 피할 경우=> 두 원이 두 군데에서 겹치게 된다 => 2
    ![](/media/ac1002/3.jpg)

---

```java

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;

/**
 * 터렛 문제 해결
 * 두 원의 교점 개수를 구하는 문제
 * 원의 방정식을 사용하여 두 원의 위치 관계를 판단
 */
public class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine()); // 테스트 케이스 개수
        
        for (int i = 0; i < n; i++) {
            // 입력: x1, y1, r1, x2, y2, r2
            // (x1, y1): 첫 번째 점의 좌표, r1: 첫 번째 점에서 목표까지의 거리
            // (x2, y2): 두 번째 점의 좌표, r2: 두 번째 점에서 목표까지의 거리
            int[] in = Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::valueOf).toArray();
            
            // 두 점 사이의 거리 계산 (유클리드 거리)
            double distance = Math.sqrt(Math.pow(in[3] - in[0], 2) + Math.pow(in[1] - in[4], 2));
            
            // 세 거리(r1, r2, 두 점 사이 거리) 중 최댓값
            double max = Arrays.stream(new double[] { in[2], in[5], distance }).max().getAsDouble();
            
            // 세 거리의 합에서 최댓값을 뺀 값 (나머지 두 거리의 합)
            double sum = in[2] + in[5] + distance - max;
            
            // 두 원의 교점 개수 판단
            // -1: 두 원이 완전히 겹침 (무수히 많은 교점)
            // 0: 두 원이 만나지 않음
            // 1: 두 원이 한 점에서 만남 (외접 또는 내접)
            // 2: 두 원이 두 점에서 만남
            int x = (in[2] == in[5] && distance == 0) ? -1 : // 반지름이 같고 중심이 같음
                    (distance == in[2] + in[5] || sum == max) ? 1 : // 외접 또는 내접
                    (max > sum) ? 0 : // 두 원이 만나지 않음
                    2; // 두 원이 두 점에서 만남
            System.out.println(x);
        }
    }
}

```
48:Ta0a,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1018)

<div className="text-center"><a href="https://www.acmicpc.net/problem/1018">https://www.acmicpc.net/problem/1018</a></div>

---

- M _ N 크기의 보드에서 8 _ 8의 체스판을 만드는 문제이다.<br />
- 자칫하면 처음칸의 색에서 고정으로 생각하기 쉬우나 무슨 색으로 칠하건 횟수가 적은 경우의 수를 출력하는 것이다.<br />
  그래서 첫칸이 W일 경우의 수와 B일 경우의 수로 나누어 카운트를 해준다.<br />
- 카운트 할 경우
  - 첫칸(0,0)이 W일 경우 -> 행렬 숫자의 합이 짝수&& B , 행렬 숫자의 합이 홀수 && W 이면 카운트1 ++<br />
  - 첫칸(0,0)이 B일 경우 -> 행렬 숫자의 합이 짝수&& W , 행렬 숫자의 합이 홀수 && B 이면 카운트2 ++

```python
import sys

/**
 * 체스판 다시 칠하기 문제 해결
 * M x N 크기의 보드에서 8 x 8 체스판을 만들기 위해 다시 칠해야 하는 최소 칸 수를 구하는 문제
 * 첫 번째 칸이 W인 경우와 B인 경우를 모두 고려하여 최소값을 찾음
 */

N,M=map(int,sys.stdin.readline().split()) # 보드의 세로, 가로 크기
board=list()
for _ in range(N):
    board.append(list(sys.stdin.readline())) # 보드 입력

min = 64 # 최대 변경 횟수 (8x8 = 64)

# 8x8 크기의 체스판을 만들 수 있는 모든 시작 위치 탐색
for r_sub in range(0,N-7): # 세로 시작 위치
    for c_sub in range(0,M-7): # 가로 시작 위치
        count1,count2=0,0 # 첫 칸이 W일 때와 B일 때의 변경 횟수
        start = board[0+r_sub][0+c_sub] # 시작 칸의 색상
        flag = bool((0+r_sub+0+c_sub)%2) # 시작 칸의 위치가 짝수인지 홀수인지
        
        # 8x8 영역을 순회하며 체스판 패턴과 비교
        for row in range(0+r_sub,8+r_sub):
            for col in range(0+c_sub,8+c_sub):
                # 체스판 패턴: (row+col)이 짝수/홀수에 따라 색상이 결정됨
                # 패턴과 실제 색상이 다르면 count1 증가, 같으면 count2 증가
                if ((row+col)%2==flag) != (board[row][col]==start):
                    count1+=1 # 첫 칸이 start 색일 때 변경 필요
                else:
                    count2+=1 # 첫 칸이 다른 색일 때 변경 필요

        # 두 경우 중 더 작은 값으로 최소값 업데이트
        if min>count1:min=count1
        if min>count2:min=count2

print(min) # 최소 변경 횟수 출력

```
49:Td6c,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1158)

<div className="text-center"><a href="https://www.acmicpc.net/problem/1158">https://www.acmicpc.net/problem/1158</a></div>

---

- prev와 next란 배열을 서로 인덱스로 교차하며 배열을 출력한다.

- n이 7이고 m이 3일 경우 처음 모양은 이러하다.

|      |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |
| :--: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| prev | -1  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |
| next |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |

- prev의 1번째에는 n을 넣고 next의 n번째에는 1을 넣는다.

|      |  0  |    1     |  2  |  3  |  4  |  5  |  6  |    7     |
| :--: | :-: | :------: | :-: | :-: | :-: | :-: | :-: | :------: |
| prev | -1  | <b>7</b> |  1  |  2  |  3  |  4  |  5  |    6     |
| next |  1  |    2     |  3  |  4  |  5  |  6  |  7  | <b>1</b> |

<br />

- i에 next[i]를 넣으면서 탐색을 나가는데 0부터 시작하여 m번 반복한다.<br />
  i = (next[0] => next[1] => next[2]) =>3<br />
  i = 3<br />

- i 값을 출력해주고 next에 이전 값이 담긴 자리에 다음 위치의 값을 넣는다.<br />
  next[prev[i]] = next[i];<br />
  next[prev[3]] = next[3];<br />
  next[2] = next[3];<br />

|      |  0  |  1  |    2    |  3  |  4  |  5  |  6  |  7  |
| :--: | :-: | :-: | :-----: | :-: | :-: | :-: | :-: | :-: |
| prev | -1  |  7  |    1    |  2  |  3  |  4  |  5  |  6  |
| next |  1  |  2  | <b>4</b> |  4  |  5  |  6  |  7  |  1  |

<br />

- 그리고 prev 배열에는 출력된 값의 자리에 그 이전 값을 넣는다.<br />
  prev[next[i]] = prev[i];<br />
  prev[next[3]] = prev[3];<br />
  prev[4] = prev[3];<br />

|      |  0  |  1  |  2  |  3  |    4     |  5  |  6  |  7  |
| :--: | :-: | :-: | :-: | :-: | :------: | :-: | :-: | :-: |
| prev | -1  |  7  |  1  |  2  | <b>2</b> |  4  |  5  |  6  |
| next |  1  |  2  |  4  |  4  |    5     |  6  |  7  |  1  |

<br />

- 위 과정을 반복한다.

- 2년전에 푼 문제인데 내가 풀었다기엔 어떻게 이렇게 푼건지 모르겠고 어디서 봤다기엔 검색을 해도 안나오고 한번에 맞췄다.

---

```C
#include <stdio.h>

/**
 * 요세푸스 문제 해결
 * 원형 연결 리스트를 배열로 구현하여 K번째 사람을 제거하는 문제
 * prev와 next 배열을 사용하여 원형 구조를 표현
 */
int main() {
    int n, m, i, j; // n: 사람 수, m: 제거할 간격, i: 현재 위치, j: 반복 변수

    scanf("%d %d", &n, &m);
	int prev[n+1], next[n+1]; // prev: 이전 노드, next: 다음 노드

    // 원형 연결 리스트 초기화
    for (i = 0; i <= n;++i) {
        prev[i] = i - 1;
        next[i] = i + 1;
    }
    // 원형 구조 만들기: 첫 번째와 마지막 연결
    prev[1] = n;
    next[n] = 1;

    printf("<");
    i = 0; // 시작 위치
    for (;--n;) { // n-1번 반복 (마지막 하나 남을 때까지)
        // m번째 사람까지 이동
        for (j = 0;j < m;++j)
            i = next[i];
        printf("%d, ", i);
        // i번째 노드를 리스트에서 제거
        next[prev[i]] = next[i]; // 이전 노드의 next를 다음 노드로 연결
        prev[next[i]] = prev[i]; // 다음 노드의 prev를 이전 노드로 연결
    }
    printf("%d>", next[i]); // 마지막 남은 사람 출력

    return 0;
}
```
4a:T8d0,
[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/9095)

<div className="text-center"><a href="https://www.acmicpc.net/problem/9095">https://www.acmicpc.net/problem/9095</a></div>

- T개 주어지는 정수 n에 대해 1,2,3의 합으로 표현하는 방법의 갯수를 세는 문제이다
- 경우는 앞의 숫자를 고정하고 나머지 값을 가변시켜보는 방식으로 카운트하게 만들면 된다.

| 정수 n | 표현 방법                                                                                         | 가지 수 |
| ------ | ------------------------------------------------------------------------------------------------- | ------- |
| 1      | 1                                                                                                 | 1       |
| 2      | 2, 1+1                                                                                            | 2       |
| 3      | 3, 2+1, 1+2, 1+1+1                                                                                | 4       |
| 4      | 3+1, 2+2, 2+1+1, 1+3, 1+2+1, 1+1+2, 1+1+1+1                                                       | 7       |
| 5      | 3+2, 3+1+1, 1+3+1, 1+1+3, 2+3, 2+2+1, 2+1+2, 1+2+2, 2+1+1+1, 1+2+1+1, 1+1+2+1, 1+1+1+2, 1+1+1+1+1 | 13      |

- 1,2,3의 경우는 각자 값을 가지고 이상의 n은 n-1,n-2,n-3의 합과 같다.

```C
#include <stdio.h>

/**
 * 1, 2, 3 더하기 문제 해결
 * 정수 n을 1, 2, 3의 합으로 나타내는 방법의 개수를 구하는 문제
 * 다이나믹 프로그래밍: n = (n-1) + (n-2) + (n-3)
 */

int m(int in);

int main(void) {
	int n;
	scanf("%d",&n);
	if(n>11)return 0;
	for(int i=0;i<n;i++){
		int s;
		scanf("%d",&s);
		printf("%d\n",m(s));
	}
	return 0;
}

/**
 * 재귀 함수: n을 1, 2, 3의 합으로 나타내는 방법의 개수
 * @param in: 정수 n
 * @return: 방법의 개수
 */
int m(int in){
	// 초기값 설정
	if(in==0)return 0;
	else if(in==1)return 1; // 1
	else if(in==2)return 2; // 2, 1+1
	else if(in==3)return 4; // 3, 2+1, 1+2, 1+1+1
	// n = (n-1) + (n-2) + (n-3)
	// n-1에 1을 더하거나, n-2에 2를 더하거나, n-3에 3을 더하는 방법
	return m(in-1)+m(in-2)+m(in-3);
}
```
0:["vicXI5GcatXf95Mh6ZPn7",[[["",{"children":["posts",{"children":["__PAGE__",{}]}]},"$undefined","$undefined",true],["",{"children":["posts",{"children":["__PAGE__",{},[["$L1",["$","$L2",null,{"allPosts":[{"slug":"programmers72412","title":"순위 검색","date":"2021-10-07T15:13:37.121Z","description":"프로그래머스 큐 연습문제, KAKAO BLIND RECRUITMENT","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$3"},{"slug":"ac1922","title":"네트워크 연결","date":"2021-07-12T12:18:37.121Z","description":"백준 1922번 최소 스패닝 트리 그래프이론 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$4"},{"slug":"ac1939","title":"중량제한","date":"2021-07-07T23:55:37.121Z","description":"백준 1939번 유니온 파인드 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$5"},{"slug":"ac1976","title":"여행 가자","date":"2021-07-05T01:31:37.121Z","description":"백준 1976번 유니온 파인드 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$6"},{"slug":"ac1717","title":"집합의 표현","date":"2021-07-03T15:53:37.121Z","description":"백준 1717번 유니온 파인드 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$7"},{"slug":"ac1826","title":"연료 채우기","date":"2021-06-30T23:29:37.121Z","description":"백준 1827번 그리디 우선순위 큐 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$8"},{"slug":"ac11000","title":"강의실 배정","date":"2021-06-27T17:30:37.121Z","description":"백준 11000번 정렬 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$9"},{"slug":"ac11286","title":"절댓값 힙","date":"2021-06-27T03:37:37.121Z","description":"백준 11286번 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$a"},{"slug":"ac11279","title":"최대 힙","date":"2021-06-27T02:20:37.121Z","description":"백준 11279번 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$b"},{"slug":"ac13305","title":"주유소","date":"2021-06-21T20:11:37.121Z","description":"백준 13305번 그리디 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$c"},{"slug":"ac1931","title":"회의실 배정","date":"2021-06-21T16:12:37.121Z","description":"백준 1931번 그리디 정렬 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$d"},{"slug":"ac13460","title":"구슬 탈출 2","date":"2021-06-18T15:16:37.121Z","description":"백준 13460번 그래프이론 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$e"},{"slug":"ac7562","title":"나이트의 이동","date":"2021-06-14T10:18:37.121Z","description":"백준 7562번 그래프 탐색 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$f"},{"slug":"ac11724","title":"연결 요소의 개수","date":"2021-06-06T21:08:37.121Z","description":"백준 11724번 그래프 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$10"},{"slug":"ac14888","title":"연산자 끼워넣기","date":"2021-05-31T18:32:37.121Z","description":"백준 14888번 브루트포스 백트레킹 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$11"},{"slug":"ac5430","title":"AC","date":"2021-05-31T00:54:37.121Z","description":"백준 5430번 파싱 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$12"},{"slug":"programmers42585","title":"N으로 표현","date":"2021-05-30T01:46:37.121Z","description":"프로그래머스 큐 연습문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$13"},{"slug":"programmers43105","title":"정수 삼각형","date":"2021-05-27T02:20:37.121Z","description":"프로그래머스 큐 연습문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$14"},{"slug":"ac11729","title":"하노이 탑 이동 순서","date":"2021-05-24T02:43:37.121Z","description":"백준 11729번 재귀 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$15"},{"slug":"ac2579","title":"계단오르기","date":"2021-05-15T00:06:37.121Z","description":"백준 2579번 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$16"},{"slug":"programmers60058","title":"괄호 변환","date":"2021-05-13T15:13:37.121Z","description":"프로그래머스 큐 연습문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$17"},{"slug":"ac1927","title":"최소 힙","date":"2021-05-12T12:56:37.121Z","description":"백준 1927번 우선순위 큐 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$18"},{"slug":"ac12015","title":"가장 긴 증가하는 부분 수열","date":"2021-05-12T02:43:37.121Z","description":"백준 12015번 이분탐색 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$19"},{"slug":"ac10872","title":"팩토리얼","date":"2021-05-03T23:59:37.121Z","description":"백준 10872번 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/10872)\n\n<div className=\"text-center\"><a href=\"https://www.acmicpc.net/problem/10872\">https://www.acmicpc.net/problem/10872</a></div>\n\n---\n\n- 정수 N에 반복적으로 곱해준다.\n\n---\n\n```cpp\n#include <iostream>\nusing namespace std;\n\n/**\n * 팩토리얼 문제 해결\n * n!을 계산하는 문제\n * 1부터 n까지의 모든 수를 곱함\n */\nint main() {\n\tint n,sum=1; // n: 입력값, sum: 팩토리얼 결과 (1로 초기화)\n\tcin>>n;\n\t\n\t// 1부터 n까지 반복하여 곱함\n\tfor(int i=1;i<=n;i++){\n\t\tsum*=i; // i를 곱함\n\t}\n\tcout<<sum;\n\treturn 0;\n}\n```\n"},{"slug":"ac10829","title":"이진수 변환","date":"2021-05-03T23:44:37.121Z","description":"백준 10829번 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/10829)\n\n<div className=\"text-center\"><a href=\"https://www.acmicpc.net/problem/10829\">https://www.acmicpc.net/problem/10829</a></div>\n\n---\n\n- n을 2나눈 나머지를 출력하고 n에 2를 나눈다.\n- n/2가 0이면 2보다 작아졌다는 말이므로 멈춘다.\n\n---\n\n```java\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/**\n * 이진수 변환 문제 해결\n * 10진수를 2진수로 변환하는 문제\n * 2로 나눈 나머지를 역순으로 모으면 2진수가 됨\n */\nclass Main\n{\n\tpublic static void main (String[] args) throws IOException\n\t{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tBufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\tString result=\"\"; // 2진수 결과 문자열\n\t\tlong n = Long.parseLong(br.readLine());\n\t\t\n\t\t// 2로 나눈 나머지를 앞에 추가하고, n을 2로 나눔\n\t\t// n이 0이 될 때까지 반복\n\t\twhile(n!=0){\n\t\t\tresult = (n%2)+result; // 나머지를 앞에 추가 (역순으로 저장)\n\t\t\tn/=2; // 2로 나눔\n\t\t}\n\t\tbw.write(result);\n\t\tbw.flush();\n\t}\n}\n```\n"},{"slug":"ac3055","title":"탈출","date":"2021-05-02T19:21:37.121Z","description":"백준 3055번 그래프 탐색 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$1a"},{"slug":"ac9012","title":"괄호","date":"2021-04-30T11:17:37.121Z","description":"백준 9012번 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$1b"},{"slug":"ac1620","title":"나는야 포켓몬 마스터 이다솜","date":"2021-04-29T23:56:37.121Z","description":"백준 1620번 해시를 사용한 집합과 맵 문자열 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$1c"},{"slug":"programmers42577","title":"전화번호 목록","date":"2021-04-27T19:44:37.121Z","description":"프로그래머스 큐 연습문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"\n[![프로그래머스](https://file.newswire.co.kr/data/datafile2/thumb_640/2021/06/1993996598_20210610150326_5364622170.jpg)](https://programmers.co.kr/learn/courses/30/lessons/42577)\n\n<div className=\"text-center\"><a href=\"https://programmers.co.kr/learn/courses/30/lessons/42577\">https://programmers.co.kr/learn/courses/30/lessons/42577</a></div>\n\n---\n\n- String의 매치를 이용하여 배열내를 탐색해 문자열이 다른 문자열 앞에 오는지 확인한다.\n\n```java\n/**\n * 전화번호 목록 문제 해결\n * 전화번호 배열에서 한 번호가 다른 번호의 접두사인지 확인하는 문제\n * 정규식을 사용하여 문자열 매칭\n */\nclass Solution {\n    public boolean solution(String[] phone_book) {\n        boolean answer = true;\n        \n        // 모든 전화번호 쌍을 비교\n        for(int i=0;i<phone_book.length;i++){\n            for(int j=0;j<phone_book.length;j++){\n                if(i==j)continue; // 같은 번호는 건너뜀\n                // phone_book[i]가 phone_book[j]로 시작하는지 확인\n                // ^는 시작, .*$는 뒤에 아무 문자나 올 수 있음을 의미\n                if(phone_book[i].matches(\"^\"+phone_book[j]+\".*$\"))return false;\n            }\n        }\n        return answer;\n    }\n}\n```\n"},{"slug":"programmers42576","title":"완주하지 못한 선수","date":"2021-04-27T00:46:37.121Z","description":"프로그래머스 큐 연습문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"\n[![프로그래머스](https://file.newswire.co.kr/data/datafile2/thumb_640/2021/06/1993996598_20210610150326_5364622170.jpg)](https://programmers.co.kr/learn/courses/30/lessons/42576)\n\n<div className=\"text-center\"><a href=\"https://programmers.co.kr/learn/courses/30/lessons/42576\">https://programmers.co.kr/learn/courses/30/lessons/42576</a></div>\n\n---\n\n- 받은 이름을 정렬하여 이름이 다르면 바로 뽑는다.\n\n```java\nimport java.util.*;\n\n/**\n * 완주하지 못한 선수 문제 해결\n * 참가자 배열과 완주자 배열을 비교하여 완주하지 못한 선수를 찾는 문제\n * 정렬을 사용하여 두 배열을 비교\n */\nclass Solution {\n    public String solution(String[] participant, String[] completion) {\n        // 두 배열을 정렬하여 순서대로 비교\n        Arrays.sort(participant);\n        Arrays.sort(completion);\n        int i=0;\n        \n        // 완주자 배열과 비교하여 다른 이름을 찾음\n        for(i=0;i<completion.length;i++){\n            if(!participant[i].equals(completion[i]))\n                return participant[i]; // 다른 이름이면 완주하지 못한 선수\n        }\n        // 모든 완주자와 일치하면 마지막 참가자가 완주하지 못한 선수\n        return participant[i];\n    }\n}\n```\n"},{"slug":"ac15829","title":"Hashing","date":"2021-04-27T00:43:37.121Z","description":"백준 15829번 해싱 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$1d"},{"slug":"ac1107","title":"리모컨","date":"2021-04-26T11:45:37.121Z","description":"백준 1107번 브루트포스 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$1e"},{"slug":"ac1463","title":"1로 만들기","date":"2021-04-25T16:12:37.121Z","description":"백준 1463번 다이나믹 프로그래밍 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$1f"},{"slug":"ac1259","title":"펠린드롬수","date":"2021-04-24T17:11:37.121Z","description":"백준 1259번 문자열 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$20"},{"slug":"ac1012","title":"소수 찾기","date":"2021-04-23T11:40:37.121Z","description":"백준 1012 DFS 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$21"},{"slug":"ac10989","title":"수 정렬하기3","date":"2021-04-22T10:11:37.121Z","description":"백준 10989번 정렬 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$22"},{"slug":"ac20927","title":"Degree Bounded Minimum Spanning Tree","date":"2021-04-21T10:10:37.121Z","description":"백준 20927번 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$23"},{"slug":"ac18111","title":"마인크래프트","date":"2021-04-21T10:10:37.121Z","description":"백준 18111번 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$24"},{"slug":"programmers17681","title":"비밀지도","date":"2021-04-20T18:38:37.121Z","description":"카카오 블라인드","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$25"},{"slug":"ac2745","title":"진법변환","date":"2021-04-19T22:39:37.121Z","description":"백준 2745번 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$26"},{"slug":"ac6603","title":"로또","date":"2021-04-16T20:55:37.121Z","description":"백준 6603번 조합론 백트래킹 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$27"},{"slug":"ac5692","title":"팩토리얼 진법","date":"2021-04-16T20:55:37.121Z","description":"백준 5692번 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$28"},{"slug":"ac4949","title":"균형잡힌 세상","date":"2021-04-15T20:30:37.121Z","description":"백준 4949번 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$29"},{"slug":"ac2869","title":"달팽이는 올라가고 싶다","date":"2021-04-14T20:30:37.121Z","description":"백준 2869번 수학 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$2a"},{"slug":"ac2805","title":"나무 자르기","date":"2021-04-13T20:30:37.121Z","description":"백준 2805번 이분탐색 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$2b"},{"slug":"ac2775","title":"부녀회장이 될테야","date":"2021-04-13T18:15:37.121Z","description":"백준 2775번 조합론 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$2c"},{"slug":"ac2292","title":"벌집","date":"2021-04-12T20:26:37.121Z","description":"백준 2292번 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$2d"},{"slug":"ac2108","title":"통계학","date":"2021-04-11T15:24:37.121Z","description":"백준 2108번 정렬 구현 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$2e"},{"slug":"ac1978","title":"소수 찾기","date":"2021-04-10T20:17:37.121Z","description":"백준 1978번 정수론 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$2f"},{"slug":"programmers43165","title":"타겟 넘버","date":"2021-04-09T16:19:37.121Z","description":"프로그래머스 DFS/BFS 연습문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$30"},{"slug":"ac2606","title":"바이러스","date":"2021-04-08T22:39:37.121Z","description":"백준 2606번 DFS 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$31"},{"slug":"ac1260","title":"DFS와 BFS","date":"2021-04-08T17:11:37.121Z","description":"백준 1260번 BFS DFS 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$32"},{"slug":"ac1874","title":"스택 수열","date":"2021-04-08T16:22:37.121Z","description":"백준 1874번 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$33"},{"slug":"ac1157","title":"단어공부","date":"2021-04-07T19:32:37.121Z","description":"백준 1157번 문자열 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$34"},{"slug":"ac1654","title":"랜선자르기","date":"2021-04-05T16:12:37.121Z","description":"백준 1654번 이분탐색 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$35"},{"slug":"ac1436","title":"영화감독 숌","date":"2021-04-04T23:47:37.121Z","description":"백준 1436번 브루트포스 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$36"},{"slug":"ac10816","title":"숫자카드 2","date":"2021-04-02T10:52:37.121Z","description":"백준 10816번 이분탐색 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$37"},{"slug":"programmers42839","title":"소수찾기","date":"2021-04-01T23:38:37.121Z","description":"프로그래머스 큐 연습문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$38"},{"slug":"ac1697","title":"술래잡기","date":"2021-03-31T23:32:37.121Z","description":"백준 1697번 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$39"},{"slug":"ac11866","title":"요세푸스 문제0","date":"2021-03-26T15:21:37.121Z","description":"백준 11866번 스택 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$3a"},{"slug":"programmers42840","title":"모의고사","date":"2021-03-25T15:25:37.121Z","description":"프로그래머스 큐 연습문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$3b"},{"slug":"programmers42583","title":"다리를 지나는 트럭","date":"2021-03-25T15:25:37.121Z","description":"프로그래머스 큐 연습문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$3c"},{"slug":"programmers42586","title":"기능개발","date":"2021-03-24T14:22:37.121Z","description":"프로그래머스 큐 연습문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$3d"},{"slug":"programmers42584","title":"주식가격","date":"2021-03-24T02:05:37.121Z","description":"프로그래머스 큐 연습문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$3e"},{"slug":"ac10250","title":"ACM 호텔","date":"2021-03-18T23:08:37.121Z","description":"백준 10250번 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$3f"},{"slug":"ac1197","title":"최소 스패닝 트리","date":"2021-03-09T11:31:37.121Z","description":"백준 1197번 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$40"},{"slug":"ac1149","title":"RGB거리","date":"2021-03-05T01:15:37.121Z","description":"백준 1149번 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$41"},{"slug":"ac1013","title":"Contact","date":"2021-03-05T01:15:37.121Z","description":"백준 1013번 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$42"},{"slug":"ac1008","title":"유기농 배추","date":"2021-03-02T23:21:37.121Z","description":"백준 1008번 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$43"},{"slug":"ac1003","title":"피보나치 수열","date":"2021-03-01T23:32:37.121Z","description":"백준 1003번 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$44"},{"slug":"ac15649","title":"N과 M(1)","date":"2021-02-26T03:38:37.121Z","description":"백준 15649번 백트래킹 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$45"},{"slug":"ac11650","title":"좌표 정렬하기","date":"2021-02-26T03:38:37.121Z","description":"백준 11650번 정렬 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$46"},{"slug":"ac1002","title":"터렛","date":"2021-02-24T23:32:37.121Z","description":"백준 1002번 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$47"},{"slug":"ac1018","title":"체스판 다시 칠하기","date":"2021-02-21T23:32:37.121Z","description":"백준 1018번 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$48"},{"slug":"ac1158","title":"요세푸스 문제","date":"2019-05-31T15:23:37.121Z","description":"백준 1158번 큐 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$49"},{"slug":"ac9095","title":"1,2,3 더하기","date":"2019-05-11T02:05:37.121Z","description":"백준 9095번 문제","categories":["알고리즘"],"tags":["알고리즘"],"emoji":"🧢","content":"$4a"}],"tags":["알고리즘"]}],null],null],null]},[null,["$","$L4b",null,{"parallelRouterKey":"children","segmentPath":["children","posts","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4c",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/328a36cb386d2c2a.css","precedence":"next","crossOrigin":"$undefined"}]],["$","html",null,{"lang":"ko","suppressHydrationWarning":true,"children":[["$","head",null,{"children":[["$","meta",null,{"charSet":"utf-8"}],["$","meta",null,{"name":"viewport","content":"width=device-width, initial-scale=1"}]]}],["$","body",null,{"children":["$","div",null,{"className":"page-wrapper","children":[["$","$L4d",null,{}],["$","main",null,{"className":"page-content","children":["$","$L4b",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4c",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","div",null,{"className":"not-found","children":[["$","h1",null,{"children":"404: Not Found"}],["$","p",null,{"children":"존재하지 않는 페이지입니다."}],["$","$L4e",null,{"href":"/","className":"back-link","children":"홈으로 돌아가기"}]]}],"notFoundStyles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/e9d52e2af3c65930.css","precedence":"next","crossOrigin":"$undefined"}]]}]}],["$","footer",null,{"className":"page-footer-wrapper","children":["$","p",null,{"className":"page-footer","children":["© ",2026," ",["$","a",null,{"href":"https://github.com/BlueTi","children":"이재호"}]," powered by"," ",["$","a",null,{"href":"https://nextjs.org/","children":"Next.js"}]]}]}],["$","$L4f",null,{}]]}]}]]}]],null],null],["$L50",null]]]]
50:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"blueti.github.io"}],["$","meta","3",{"name":"description","content":"재호의 개발일기"}],["$","meta","4",{"name":"author","content":"이재호"}]]
1:null
