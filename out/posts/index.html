<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/328a36cb386d2c2a.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-104edc9623986ae6.js"/><script src="/_next/static/chunks/fd9d1056-1aae0987937804d3.js" async=""></script><script src="/_next/static/chunks/117-f62757ca3cf4275f.js" async=""></script><script src="/_next/static/chunks/main-app-9dadb2eca32fcdb1.js" async=""></script><script src="/_next/static/chunks/972-6576aeaf1f991e3d.js" async=""></script><script src="/_next/static/chunks/app/posts/page-5987fd68959a3c37.js" async=""></script><script src="/_next/static/chunks/app/layout-2b57208f03ac30e3.js" async=""></script><script src="/_next/static/chunks/app/page-515b9a9216b60d52.js" async=""></script><title>blueti.github.io</title><meta name="description" content="재호의 개발일기"/><meta name="author" content="이재호"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><div class="page-wrapper"><header class="jsx-5778ffc518c0bd76 page-header-wrapper"><div class="jsx-5778ffc518c0bd76 page-header"><div class="jsx-5778ffc518c0bd76 front-section"><a class="link" href="/">blueti.github.io</a></div><div class="jsx-5778ffc518c0bd76 trailing-section"><button aria-label="검색" class="jsx-5778ffc518c0bd76 search-button"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="jsx-5778ffc518c0bd76"><circle cx="11" cy="11" r="8" class="jsx-5778ffc518c0bd76"></circle><path d="m21 21-4.35-4.35" class="jsx-5778ffc518c0bd76"></path></svg></button><a class="link " href="/posts/">posts</a></div></div></header><main class="page-content"><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><div class="category-page-header-wrapper"><div class="category-page-title">로딩 중...</div></div><!--/$--></main><footer class="page-footer-wrapper"><p class="page-footer">© <!-- -->2026<!-- --> <a href="https://github.com/BlueTi">이재호</a> powered by<!-- --> <a href="https://nextjs.org/">Next.js</a></p></footer><div class="dark-mode-button-wrapper"><button class="dark-mode-button" aria-label="다크 모드 토글"><svg class="dark-mode-icon" viewBox="0 0 24 24" fill="currentColor" width="24" height="24"><path d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9 9-4.03 9-9c0-.46-.04-.92-.1-1.36-.98 1.37-2.58 2.26-4.4 2.26-2.98 0-5.4-2.42-5.4-5.4 0-1.81.89-3.42 2.26-4.4-.44-.06-.9-.1-1.36-.1z"></path></svg></button></div></div><script src="/_next/static/chunks/webpack-104edc9623986ae6.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/328a36cb386d2c2a.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[2846,[],\"\"]\n4:I[9201,[\"972\",\"static/chunks/972-6576aeaf1f991e3d.js\",\"991\",\"static/chunks/app/posts/page-5987fd68959a3c37.js\"],\"default\"]\n4d:I[4707,[],\"\"]\n4e:I[6423,[],\"\"]\n4f:I[4058,[\"972\",\"static/chunks/972-6576aeaf1f991e3d.js\",\"185\",\"static/chunks/app/layout-2b57208f03ac30e3.js\"],\"default\"]\n50:I[2972,[\"972\",\"static/chunks/972-6576aeaf1f991e3d.js\",\"931\",\"static/chunks/app/page-515b9a9216b60d52.js\"],\"\"]\n51:I[9922,[\"972\",\"static/chunks/972-6576aeaf1f991e3d.js\",\"185\",\"static/chunks/app/layout-2b57208f03ac30e3.js\"],\"default\"]\n53:I[1060,[],\"\"]\n5:Teac,"])</script><script>self.__next_f.push([1,"\n[![프로그래머스](https://file.newswire.co.kr/data/datafile2/thumb_640/2021/06/1993996598_20210610150326_5364622170.jpg)](https://programmers.co.kr/learn/courses/30/lessons/72412)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://programmers.co.kr/learn/courses/30/lessons/60058\"\u003ehttps://programmers.co.kr/learn/courses/30/lessons/72412\u003c/a\u003e\u003c/div\u003e\n\n- Map안에 List를 넣어 관리한다\n- 검색가능한 쿼리 키를 미리 만들어 목록을 작성한다\n- 조건맞을 맞춘 목록에서 이분 탐색으로 속도를 구해야한다\n\n```java\nimport java.util.*;\n\n/**\n * 순위 검색 문제 해결\n * 지원자 정보를 조건별로 분류하고, 쿼리에 맞는 지원자 수를 구하는 문제\n * Map을 사용하여 조건별로 점수를 저장하고, 이분 탐색으로 효율적으로 검색\n */\nclass Solution {\n    Map\u003cString, List\u003cInteger\u003e\u003e allInfo; // 조건별 점수 리스트를 저장하는 Map\n    List\u003cInteger\u003e scores;\n\n    public int[] solution(String[] info, String[] query) {\n        int[] answer = new int[query.length];\n        allInfo = new HashMap\u003cString, List\u003cInteger\u003e\u003e(); // 모든 데이터를 담기 위한 Map\n        \n        // 지원자 정보를 모든 가능한 조건 조합으로 저장\n        for (String infoDetail : info) {\n            saveData(0, \"\", infoDetail.split(\" \"));\n        }\n        \n        // 저장해둔 리스트들을 모두 정렬 (이분 탐색을 위해)\n        for (String key : allInfo.keySet()) {\n            allInfo.get(key).sort(Comparator.naturalOrder());\n        }\n\n        // 각 쿼리에 대해 검색\n        for (int i = 0; i \u003c query.length; i++) {\n            String[] columns = query[i].replace(\" and \", \"\").split(\" \");\n            answer[i] = search(columns[0], Integer.parseInt(columns[1])); // 조건 검색\n        }\n\n        return answer;\n    }\n\n    /**\n     * 지원자 정보를 모든 가능한 조건 조합으로 저장\n     * \"-\"는 해당 조건을 무시하는 것을 의미\n     * @param depth: 현재 처리할 조건의 인덱스 (0~3)\n     * @param key: 현재까지 만든 조건 키\n     * @param details: 지원자 정보 배열\n     */\n    public void saveData(int depth, String key, String[] details) {\n        // 쿼리 내 변수 4개를 다 채웠을 경우 키에 대한 값을 추가\n        if (depth == 4) {\n            if (!allInfo.containsKey(key)) {\n                scores = new ArrayList\u003cInteger\u003e();\n                scores.add(Integer.parseInt(details[4]));\n                allInfo.put(key, scores);\n            } else {\n                allInfo.get(key).add(Integer.parseInt(details[4]));\n            }\n            return;\n        }\n        // 해당 조건에 대한 키 생성: \"-\" (조건 무시) 또는 실제 값\n        saveData(depth + 1, key + \"-\", details);\n        saveData(depth + 1, key + details[depth], details);\n    }\n\n    /**\n     * 조건에 맞는 지원자 수를 이분 탐색으로 찾음\n     * @param query: 검색 조건 키\n     * @param score: 최소 점수\n     * @return: 조건에 맞는 지원자 수\n     */\n    public int search(String query, int score) {\n        if (!allInfo.containsKey(query)) // 포함된 조건 키가 없을 경우 0 반환\n            return 0;\n        List\u003cInteger\u003e list = allInfo.get(query); // 조건 키가 있을 경우 이분 탐색\n        int left = 0, right = list.size() - 1;\n        \n        // 이분 탐색: score 이상인 점수의 개수를 찾음\n        while (left \u003c= right) {\n            int mid = (left + right) / 2;\n            if (list.get(mid) \u003c score)\n                left = mid + 1;\n            else\n                right = mid - 1;\n        }\n        // left부터 끝까지가 score 이상인 점수들\n        return list.size() - left;\n    }\n}\n```\n"])</script><script>self.__next_f.push([1,"6:Te4c,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1922)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/1922\"\u003ehttps://www.acmicpc.net/problem/1922\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- \u003ca href='https://m.blog.naver.com/kks227/220799105543'\u003e최소 스패닝 트리\u003c/a\u003e에 대한 문제이다.\n- 연결 비용을 오름차순으로 정렬 후 연결 목록을 꺼내 부모노드가 다를때 같아지게 만들고, 같다면 넘겨서 모두를 잇는다.\n- 유니온 파인드에 이어서 보면 매우 편하다.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\nimport java.util.stream.IntStream;\n\n/**\n * 네트워크 연결 문제 해결\n * 최소 스패닝 트리를 구하는 문제\n * 크루스칼 알고리즘과 Union-Find를 사용\n */\n\n/**\n * 간선을 나타내는 클래스\n */\nclass Node implements Comparable\u003cNode\u003e{\n    int start,end,cost; // 시작점, 도착점, 비용\n    public Node(int start,int end, int cost){\n        this.start = start;\n        this.end = end;\n        this.cost = cost;\n    }\n\n    /**\n     * 비용 오름차순으로 정렬하고 같을 경우 낮은 시작점을 앞으로 함\n     */\n    @Override\n    public int compareTo(Node o) {\n        if(this.cost == o.cost)\n            return this.start-o.start;\n        return this.cost-o.cost;\n    }\n}\n\n\npublic class Main {\n    static BufferedReader br;\n    static BufferedWriter bw;\n    static StringBuilder sb;\n    static int[] ar; // Union-Find를 위한 부모 배열\n\n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        StringTokenizer st = null;\n        int n = Integer.parseInt(br.readLine()),m = Integer.parseInt(br.readLine()),allCost=0; // n: 컴퓨터 개수, m: 연결 개수\n        // 부모 노드 표기 자리에 본인 위치로 초기화\n        ar = IntStream.range(0, n+1).toArray();\n        PriorityQueue\u003cNode\u003e q = new PriorityQueue\u003cNode\u003e(); // 비용이 작은 간선부터 선택\n        \n        // 간선 정보 입력\n        for(int i = 0; i \u003c m; i++){\n            st = new StringTokenizer(br.readLine());\n            q.add(new Node(Integer.parseInt(st.nextToken()),Integer.parseInt(st.nextToken()),Integer.parseInt(st.nextToken())));\n        }\n\n        // 크루스칼 알고리즘: 비용이 작은 간선부터 선택\n        while(!q.isEmpty()){\n            Node node = q.poll();\n            // 부모 노드가 같은지 확인하고 다르면 합친 뒤 필요한 비용에 더해줌\n            if(find(node.start)!=find(node.end)){\n                union(node.start,node.end);\n                allCost+=node.cost;\n            }\n        }\n        bw.write(allCost+\"\");\n        bw.flush();\n    }\n\n    /**\n     * 시작점의 부모와 도착점의 부모를 잇는다 (Union)\n     */\n    private static void union(int start, int end) {\n        ar[find(start)] = find(end);\n    }\n\n    /**\n     * 부모 노드를 찾는 함수 (경로 압축 적용)\n     * 부모 노드 위치에 본인 값이 들어있다면 본인이 최고 부모이므로 값을 반환\n     * 그렇지 않을 경우 거슬러 올라가면서 부모값을 대입\n     */\n    private static int find(int index) {\n        if(ar[index]==index)return index;\n        // 경로 압축: 부모를 루트로 직접 연결\n        return ar[index]=find(ar[index]);\n    }\n}\n```\n"])</script><script>self.__next_f.push([1,"7:T1094,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1939)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/1939\"\u003ehttps://www.acmicpc.net/problem/1939\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 가능한 다리의 무게를 무거운 순서로 정렬하여 꺼내면서 부모 노드를 합쳐준다.\n- 합쳐준 부모 노드 기록을 참조하여 합치기가 끝날때 시작점과 끝이 같아졌는지 확인한다.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\n\n/**\n * 중량제한 문제 해결\n * 시작점에서 끝점까지 이동할 수 있는 최대 중량을 구하는 문제\n * Union-Find와 그리디 알고리즘을 사용: 무게가 큰 다리부터 연결\n */\n\n/**\n * 다리를 나타내는 클래스\n */\nclass Node implements Comparable\u003cNode\u003e {\n    public int start, end, weight; // 시작점, 도착점, 가능한 무게\n\n    public Node(int start, int end, int weight) {\n        this.start = start;\n        this.end = end;\n        this.weight = weight;\n    }\n\n    /**\n     * 역순으로 정렬 (무게가 큰 것부터)\n     */\n    @Override\n    public int compareTo(Node o) {\n        return o.weight - this.weight;\n    }\n}\n\npublic class Main {\n    static BufferedReader br;\n    static BufferedWriter bw;\n    static StringBuilder sb;\n\n    // 부모 노드 기록을 위한 배열\n    static int[] ar;\n\n    /**\n     * 두 집합을 합치는 함수 (Union)\n     * 합칠 때 한쪽 값을 다른쪽에 더하고 한쪽에는 노드 인덱스를 기록하여 부모는 음수의 값을 가짐\n     */\n    private static void merge(int cur_start, int cur_end) {\n        int pa = findRoot(cur_start), pb = findRoot(cur_end);\n        if (pa == pb)\n            return;\n        ar[pa] += ar[pb];\n        ar[pb] = pa;\n        return;\n    }\n\n    /**\n     * 부모 노드를 찾는 함수 (경로 압축 적용)\n     * 부모 노드는 음수의 정수를 가지고 있으므로 배열 안의 값이 0보다 작을 경우 부모\n     */\n    private static int findRoot(int index) {\n        if (ar[index] \u003c 0)\n            return index;\n        return ar[index] = findRoot(ar[index]);\n    }\n\n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken()), m = Integer.parseInt(st.nextToken()), ans = Integer.MAX_VALUE; // n: 섬 개수, m: 다리 개수\n        PriorityQueue\u003cNode\u003e q = new PriorityQueue\u003cNode\u003e(); // 무게가 큰 다리부터 선택\n        ar = new int[n + 1];\n        // 부모 노드 기록을 -1로 채움\n        Arrays.fill(ar, -1);\n        \n        // 다리 정보 입력\n        for (int i = 0; i \u003c m; i++) {\n            st = new StringTokenizer(br.readLine());\n            q.add(new Node(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken()),\n                    Integer.parseInt(st.nextToken())));\n        }\n        st = new StringTokenizer(br.readLine());\n        int start = Integer.parseInt(st.nextToken()), end = Integer.parseInt(st.nextToken()); // 시작점, 끝점\n        \n        // 큐에서 꺼내서 확인: 무게가 큰 다리부터 연결\n        while (!q.isEmpty()) {\n            Node node = q.poll();\n            int cur_start = node.start, cur_end = node.end, cur_weight = node.weight;\n            // 이미 연결되어 있으면 건너뜀\n            if (findRoot(cur_start) == findRoot(cur_end))\n                continue;\n            // 무게는 정수 최대값에서 점차 내림차순이므로 더 작은 값을 집어 넣음\n            ans = Math.min(ans, cur_weight);\n            merge(cur_start, cur_end);\n            // 시작점과 끝점이 연결되었으면 종료\n            if (findRoot(start) == findRoot(end))\n                break;\n        }\n        bw.write(\"\" + ans);\n        bw.flush();\n    }\n}\n```\n"])</script><script>self.__next_f.push([1,"8:Td83,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1976)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/1976\"\u003ehttps://www.acmicpc.net/problem/1976\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 여행지의 각 위치를 숫자로 표기한다.\n- 입력 배열에서 1이 들어올 경우 i,j 위치를 이어준다(각 값을 비교하여 루트를 넣어준다).\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.StringTokenizer;\n\n/**\n * 여행 가자 문제 해결\n * 여행 계획의 모든 도시가 연결되어 있는지 확인하는 문제\n * Union-Find를 사용하여 도시들의 연결 관계를 관리\n */\npublic class Main {\n    static BufferedReader br;\n    static BufferedWriter bw;\n\n    // 연결 위치가 기록될 배열 (Union-Find)\n    static int[] ar;\n\n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        StringTokenizer st = null;\n        int n = Integer.parseInt(br.readLine()), m = Integer.parseInt(br.readLine()); // n: 도시 개수, m: 여행 계획 도시 개수\n        ar = new int[n + 1];\n        // 각 노드의 루트를 자신으로 초기화\n        for (int i = 1; i \u003c= n; i++) {\n            ar[i] = i;\n        }\n\n        // 도시 간 연결 정보 입력\n        for (int i = 1; i \u003c= n; i++) {\n            st = new StringTokenizer(br.readLine());\n            for (int j = 1; j \u003c= n; j++) {\n                int cmd = Integer.parseInt(st.nextToken());\n\n                // 1이 입력될 경우 배열 i,j를 이어줌 (연결됨)\n                if (cmd == 1) {\n                    union(i, j);\n                }\n            }\n        }\n\n        // 여행 계획을 입력받음\n        st = new StringTokenizer(br.readLine());\n        // 여행을 시작할 위치의 루트 노드를 찾음\n        int startRoot = findROOT(Integer.parseInt(st.nextToken()));\n        // 결과 값을 확인할 boolean 값 정의\n        boolean can = true;\n        \n        // 나머지 여행 계획 도시들이 시작 도시와 연결되어 있는지 확인\n        for (int i = 1; i \u003c m; i++) {\n            // 다음 여행갈 목적지를 입력 받고 시작 위치와 이어져 있는지 확인\n            int next = Integer.parseInt(st.nextToken());\n            // 시작 위치에서 갈 수 없는 경우 boolean 값에 false를 넣고 반복문을 종료\n            if (startRoot != findROOT(next)) {\n                can = false;\n                break;\n            }\n        }\n        // 모든 목적지에 갈 수 있을 경우 YES : 불가능 할 경우 NO\n        bw.write(can ? \"YES\" : \"NO\");\n        bw.flush();\n    }\n\n    /**\n     * 루트 노드를 찾는 함수 (경로 압축 적용)\n     */\n    private static int findROOT(int index) {\n        if (ar[index] == index)\n            return index;\n        return ar[index] = findROOT(ar[index]);\n    }\n\n    /**\n     * 두 집합을 합치는 함수 (Union)\n     * 작은 번호를 부모로 설정\n     */\n    private static void union(int i, int j) {\n        i = findROOT(i);\n        j = findROOT(j);\n\n        if (i \u003c j) {\n            ar[j] = i;\n        } else if (i \u003e j) {\n            ar[i] = j;\n        }\n    }\n}\n```\n"])</script><script>self.__next_f.push([1,"9:Tb6e,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1717)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/1717\"\u003ehttps://www.acmicpc.net/problem/1717\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 연결된 숫자들을 찾는 배열을 선언합니다.\n- 부모노드를 숫자가 더 작은 쪽으로 몰아 넣어준다.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.StringTokenizer;\n\n/**\n * 집합의 표현 문제 해결\n * Union-Find를 사용하여 두 원소가 같은 집합에 속해있는지 확인하는 문제\n * 부모 노드를 숫자가 더 작은 쪽으로 통일\n */\npublic class Main {\n    static BufferedReader br;\n    static BufferedWriter bw;\n    static StringBuilder sb;\n\n    static int[] ar; // Union-Find를 위한 부모 배열\n\n    /**\n     * 부모를 찾는 함수 (경로 압축 적용)\n     * @param index: 찾을 원소\n     * @return: 루트 노드\n     */\n    public static int findROOT(int index) {\n        // 부모 노드는 위가 없으므로 자기 자신을 찾았다면 반환\n        if (ar[index] == index) {\n            return index;\n        }\n        // 현재 인덱스 값에 부모 노드 값을 넣으면서 반환 (경로 압축)\n        return ar[index] = findROOT(ar[index]);\n    }\n\n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        sb = new StringBuilder();\n\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken()), m = Integer.parseInt(st.nextToken()); // n: 원소 개수, m: 연산 개수\n        ar = new int[n + 1];\n        // 각 노드 위치에 자기 값을 넣음 (초기화)\n        for (int i = 0; i \u003c= n; i++)\n            ar[i] = i;\n\n        for (int i = 0; i \u003c m; i++) {\n            st = new StringTokenizer(br.readLine());\n            int c = Integer.parseInt(st.nextToken()), a = Integer.parseInt(st.nextToken()),\n                    b = Integer.parseInt(st.nextToken());\n            // c가 0일 경우 두 집합을 합침 (Union)\n            if (c == 0) {\n                a = findROOT(a);\n                b = findROOT(b);\n                // b가 더 작을 경우 a의 부모에 b를 입력\n                if (a \u003e b)\n                    ar[a] = b;\n                // a가 더 작을 경우 b의 부모에 a를 입력\n                else if (a \u003c b)\n                    ar[b] = a;\n            } else if (c == 1) { // c가 1일 경우 같은 집합에 속해있는지 확인 (Find)\n                sb.append((findROOT(a) == findROOT(b) ? \"YES\" : \"NO\") + \"\\n\");\n            }\n        }\n        bw.write(sb.toString());\n        bw.flush();\n    }\n}\n```\n"])</script><script>self.__next_f.push([1,"a:Te4a,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1827)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/1827\"\u003ehttps://www.acmicpc.net/problem/1827\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 주유소를 거리가 짧은 순으로 정렬하여 현재 연료로 접근할 수 있는 주유소로 접근한다.\n- 넣을 수 있는 기름의 양이 큰 순서로 접근한 주유소 목록 정렬하여 큰 양을 넣는다.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\n\n/**\n * 연료 채우기 문제 해결\n * 목적지까지 가기 위해 필요한 최소 주유소 방문 횟수를 구하는 문제\n * 그리디 알고리즘: 현재 연료로 접근 가능한 주유소 중 연료를 가장 많이 주는 곳을 선택\n */\n\n/**\n * 주유소 정보를 담는 클래스\n */\nclass Node {\n    int dist, fuel; // 거리, 연료량\n\n    public Node(int dist, int fuel) {\n        this.dist = dist;\n        this.fuel = fuel;\n    }\n}\n\npublic class Main {\n    static BufferedReader br;\n    static BufferedWriter bw;\n    static StringBuilder sb;\n\n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        int N = Integer.parseInt(br.readLine()); // 주유소 개수\n        \n        // 정렬을 새로 정의하여 거리가 가까운 순서로 주유소를 입력받아 정렬\n        PriorityQueue\u003cNode\u003e stations = new PriorityQueue\u003cNode\u003e(new Comparator\u003cNode\u003e() {\n            @Override\n            public int compare(Node o1, Node o2) {\n                return o1.dist - o2.dist; // 거리 오름차순\n            }\n        });\n        \n        // 앞으로 들어올 방문한 주유소 목록을 넣을 수 있는 가스가 큰 순서로 정렬\n        PriorityQueue\u003cNode\u003e gas = new PriorityQueue\u003cNode\u003e(new Comparator\u003cNode\u003e() {\n            @Override\n            public int compare(Node o1, Node o2) {\n                return o2.fuel - o1.fuel; // 연료량 내림차순\n            }\n        });\n        \n        StringTokenizer st;\n        // 주유소 정보 입력\n        for (int i = 0; i \u003c N; i++) {\n            st = new StringTokenizer(br.readLine());\n            stations.add(new Node(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken())));\n        }\n        st = new StringTokenizer(br.readLine());\n        int L = Integer.parseInt(st.nextToken()), P = Integer.parseInt(st.nextToken()); // L: 목적지 거리, P: 현재 연료\n\n        int count = 0; // 주유소 방문 횟수\n        // P가 현재 연료이므로 연료량이 L이 넘거나 같을 때까지 반복\n        while (P \u003c L) {\n            // 현재 연료로 접근 가능한 주유소 목록에 주유소를 추가\n            while (!stations.isEmpty() \u0026\u0026 stations.peek().dist \u003c= P) {\n                Node n = stations.poll();\n                gas.add(n);\n            }\n            // 연료(P)로 목표점(L)까지 가지 못했는데 접근 가능한 주유소가 없을 경우 도착할 수 없으므로 -1 출력\n            if (gas.isEmpty()) {\n                count = -1;\n                break;\n            }\n            // 현재 연료량에 접근 가능한 주유소 중 가장 많은 양의 기름을 넣어줌\n            P += gas.poll().fuel;\n            count++;\n        }\n        bw.write(count + \"\");\n        bw.flush();\n    }\n}\n```\n"])</script><script>self.__next_f.push([1,"b:Td23,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/11000)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/11000\"\u003ehttps://www.acmicpc.net/problem/11000\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 강의 시간을 정렬하여 넣는데 빠른 강의가 앞에 오도록 넣는다.\n- 시간표 큐의 가장 앞 강의가 넣으려는 시간보다 늦다면 끝났다는 의미이므로 빼버리고 그렇지 않다면 강의중이므로 새 강의를 넣어 큐의 크기(강의실)을 늘린다.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\n\n/**\n * 강의실 배정 문제 해결\n * 모든 강의를 진행하기 위해 필요한 최소 강의실 개수를 구하는 문제\n * 그리디 알고리즘과 우선순위 큐를 사용\n */\n\n/**\n * 강의를 나타내는 클래스\n * 시작 시간과 종료 시간을 저장\n */\nclass Node implements Comparable\u003cNode\u003e {\n    int start, end; // 수업의 시작시간과 끝시간\n\n    public Node(int start, int end) {\n        this.start = start;\n        this.end = end;\n    }\n\n    /**\n     * 정렬 기준: 시작 시간이 빠른 순서, 같으면 종료 시간이 빠른 순서\n     */\n    @Override\n    public int compareTo(Node o) {\n        // 시작 시간이 같을 경우 종료 시간이 짧은 강의가 앞에 오도록 함\n        if (this.start == o.start)\n            return this.end - o.end;\n        // 시작 시간이 빠른 강의가 앞으로 오도록 설정\n        return this.start - o.start;\n    }\n}\n\npublic class Main {\n    static BufferedReader br;\n    static BufferedWriter bw;\n\n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        int N = Integer.parseInt(br.readLine());\n        // 강의 예정 시간표 큐 (시작 시간 순으로 정렬)\n        PriorityQueue\u003cNode\u003e q = new PriorityQueue\u003cNode\u003e();\n        // 강의실 현재 시간표 큐 (각 강의실의 마지막 강의 종료 시간 저장)\n        PriorityQueue\u003cInteger\u003e time = new PriorityQueue\u003cInteger\u003e();\n        StringTokenizer st;\n        \n        // 강의 정보 입력\n        for (int i = 0; i \u003c N; i++) {\n            st = new StringTokenizer(br.readLine());\n            q.add(new Node(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken())));\n        }\n\n        // 첫 수업을 강의실에 배정 (종료 시간 저장)\n        time.add(q.poll().end);\n\n        while (!q.isEmpty()) {\n            // 다음 수업을 꺼내 비교\n            Node n = q.poll();\n            // 시간표의 가장 앞 시간(가장 빨리 끝나는 강의)이 현재 강의 시작 시간보다 이전이면\n            // 그 강의실을 재사용할 수 있으므로 큐에서 제거\n            if (time.peek() \u003c= n.start)\n                time.poll();\n            // 현재 강의를 강의실에 배정 (종료 시간 추가)\n            time.add(n.end);\n        }\n        // 강의 시간표 큐의 사이즈가 필요한 강의실의 개수가 됨\n        bw.write(time.size() + \"\");\n        bw.flush();\n    }\n}\n\n\n```\n"])</script><script>self.__next_f.push([1,"c:T8ea,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/11286)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/11286\"\u003ehttps://www.acmicpc.net/problem/11286\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- N개의 숫자를 입력받고 숫자가 0일 경우 절댓값이 가장 작은 값을 출력한다.\n- PriorityQueue에서 절대값이 작은경우 앞으로 가도록 하고 나중에 입력받은 값이 뒤로 가도록 정렬한다.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\n\n/**\n * 절댓값 힙 문제 해결\n * 절댓값이 가장 작은 값을 출력하는 힙 구현\n * 절댓값이 같으면 실제 값이 작은 것을 우선\n */\npublic class Main {\n    static BufferedReader br;\n    static BufferedWriter bw;\n    static StringBuilder sb;\n\n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        int N = Integer.parseInt(br.readLine()); // 연산 개수\n        \n        // 커스텀 정렬을 사용하는 우선순위 큐\n        PriorityQueue\u003cInteger\u003e queue = new PriorityQueue\u003cInteger\u003e(new Comparator\u003cInteger\u003e() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                // 절댓값이 같은 경우 실제 값이 작은 것이 앞으로 (음수가 우선)\n                if (Math.abs(o1) == Math.abs(o2)) {\n                    return o1 - o2; // 실제 값 비교\n                }\n                // 절댓값이 더 작은 것이 앞으로\n                return Math.abs(o1) - Math.abs(o2);\n            }\n        });\n        \n        for (int i = 0; i \u003c N; i++) {\n            int t = Integer.parseInt(br.readLine());\n            if (t == 0) {\n                // 0이면 절댓값이 가장 작은 값 출력\n                Integer max = queue.poll();\n                bw.write((max == null ? 0 : max) + \"\\n\");\n            } else\n                queue.add(t); // 0이 아니면 큐에 추가\n        }\n        bw.flush();\n    }\n}\n\n```\n"])</script><script>self.__next_f.push([1,"d:T76c,\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/11279)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/11279\"\u003ehttps://www.acmicpc.net/problem/11279\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- N개 숫자를 받고 0일 경우 가장 큰 값을 출력한다.\n- 자바의 PriorityQueue를 역정렬 시켜서 나오게 만든다.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Collections;\nimport java.util.PriorityQueue;\n\n/**\n * 최대 힙 문제 해결\n * 최대 힙을 구현하는 문제\n * PriorityQueue를 역순으로 정렬하여 최대값이 먼저 나오도록 함\n */\npublic class Main {\n    static BufferedReader br;\n    static BufferedWriter bw;\n    static StringBuilder sb;\n\n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        int N = Integer.parseInt(br.readLine()); // 연산 개수\n        \n        // PriorityQueue를 역순으로 정렬하여 가장 큰 수가 앞으로 오도록 설정\n        PriorityQueue\u003cInteger\u003e queue = new PriorityQueue\u003cInteger\u003e(Collections.reverseOrder());\n        \n        for (int i = 0; i \u003c N; i++) {\n            int t = Integer.parseInt(br.readLine());\n            // 입력받은 값이 0일 경우 Queue에서 가장 큰 값을 출력\n            if (t == 0) {\n                Integer max = queue.poll(); // 최대값 제거 및 반환\n                // 큐가 비어있으면 0 출력, 아니면 최대값 출력\n                bw.write((max == null ? 0 : max) + \"\\n\");\n            } else\n                queue.add(t); // 0이 아니면 큐에 추가\n        }\n        bw.flush();\n    }\n\n}\n\n\n```\ne:Ta13,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/13305)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/13305\"\u003ehttps://www.acmicpc.net/problem/13305\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 어쨋거나 도착할 수 있다.\n- 기름을 넣어서 이동하는게 아니라 기름을 꿔서 움직인다고 생각하자.\n- 일단 이동을 하고 이전 주유소의 가격이 더 쌀 경우 그 가격으로 사는거다.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.StringTokenizer;\n\n/**\n * 주유소 문제 해결\n * 각 도시의 주유소 가격이 다를 때, 목적지까지 가는 최소 비용을 구하는 문제\n * 그리디 알고리즘: 지금까지 지나온 주유소 중 가장 저렴한 가격으로 기름을 구매\n */\npublic class Main {\n    static BufferedReader br;\n    static BufferedWriter bw;\n    static StringBuilder sb;\n\n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        \n        // 주유소 개수\n        int N = Integer.parseInt(br.readLine());\n        // 주유소 간의 거리 distance, 각 주유소의 비용을 cost로 선언\n        long[] distance = new long[N - 1], cost = new long[N];\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        // 도시 간 거리 입력\n        for (int i = 0; i \u003c N - 1; i++) {\n            distance[i] = Long.parseLong(st.nextToken());\n        }\n        \n        // 각 도시의 주유소 가격 입력\n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i \u003c N; i++) {\n            cost[i] = Long.parseLong(st.nextToken());\n        }\n\n        // 총비용 sum, 지금까지 지나온 주유소 중 최소 비용을 min_cost로 선언\n        // 처음에는 출발지의 주유소 가격을 사용\n        long sum = 0, min_cost = cost[0];\n\n        for (int i = 0; i \u003c N - 1; i++) {\n            // 주유소 간 비용을 비교하여 더 쌀 경우 min_cost 업데이트\n            if (cost[i] \u003c min_cost)\n                min_cost = cost[i];\n            // 최소 비용으로 다음 도시까지 가는 거리만큼 기름 구매\n            sum += min_cost * distance[i];\n        }\n\n        bw.write(sum + \"\");\n        bw.flush();\n    }\n\n}\n```\n"])</script><script>self.__next_f.push([1,"f:Tdf0,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1931)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/1931\"\u003ehttps://www.acmicpc.net/problem/1931\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 회의 끝나는 시간을 기준으로 정렬한다.\n- 끝나는 시간이 같을 경우 더 늦게 시작하여 회의시간이 짧은 경우를 넣는다.\n- 그림으로 다른분께서 보기 좋게 정리해주셨다.(https://st-lab.tistory.com/145)\n  ![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcewRBZ%2FbtqJ92Ggx03%2F1lekgEQnnITL75Kcls4M0k%2Fimg.png)\n- 처음 입력된 회의 시간 목록이다.\n  ![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FkWMC8%2FbtqJ3iJ7hIS%2FGteyzJuATQuqKajK9Qj0Qk%2Fimg.png)\n- 위의 조건으로 정렬한 그림이다. 여기서 앞에 회의시간을 넣고 앞 시간의 끝시간과 다음 시간의 시작시간이 겹치지 않는것을 이어준다.\n  ![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FculRjv%2FbtqKfp2amld%2FfRbwvDQgtpsTrYejNECQk1%2Fimg.png)\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.StringTokenizer;\n\n/**\n * 회의실 배정 문제 해결\n * 회의실을 사용할 수 있는 최대 회의 개수를 구하는 문제\n * 그리디 알고리즘: 끝나는 시간이 빠른 회의부터 선택\n */\npublic class Main {\n    static BufferedReader br;\n    static BufferedWriter bw;\n    static StringBuilder sb;\n\n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        \n        // 회의실 시간 개수 t와 횟수 count 선언\n        int t = Integer.parseInt(br.readLine()), count = 0;\n        // 요청 시간표를 입력하는 ar 선언\n        int[][] ar = new int[t][];\n        \n        // 회의 시간 입력\n        for (int i = 0; i \u003c t; i++) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int a = Integer.parseInt(st.nextToken()), b = Integer.parseInt(st.nextToken());\n            ar[i] = new int[] { a, b }; // [시작 시간, 끝 시간]\n        }\n        \n        // 요청 시간표를 끝 시간으로 오름차순 정렬하고 같을 경우는 시작 시간이 늦은 것으로 정렬\n        Arrays.sort(ar, new Comparator\u003cint[]\u003e() {\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                if (o1[1] == o2[1]) {\n                    return o1[0] - o2[0]; // 끝 시간이 같으면 시작 시간 오름차순\n                }\n                return o1[1] - o2[1]; // 끝 시간 오름차순\n            }\n        });\n\n        // 직전 시간을 기록해줄 변수 prev_time 시작 시간은 0부터 시작\n        int prev_time = 0;\n\n        for (int i = 0; i \u003c t; i++) {\n            // 꺼낸 시간이 이전 타임 끝 시간과 같거나 늦을 경우 (겹치지 않음)\n            if (prev_time \u003c= ar[i][0]) {\n                // 다음 타임 끝 시간을 넣어주고 카운트를 증가시킴\n                prev_time = ar[i][1];\n                count++;\n            }\n        }\n        bw.write(count + \"\");\n        bw.flush();\n    }\n\n}\n```\n"])</script><script>self.__next_f.push([1,"10:T1d6e,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/13460)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/13460\"\u003ehttps://www.acmicpc.net/problem/13460\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 구슬이 어딘가 부딛힐때까지 움직인다.\n- 빨간 구슬과 파란 구슬은 겹쳐지지 않는다.\n- 파란 구슬과 빨간 구슬이 같은 방향으로 동시에 빠질 경우 실패.\n- 파란 구슬이 먼저 빠져도 안된다.\n- 10번 이내 해야하고 그러지 못 할 경우 -1을 출력.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\n/**\n * 구슬 탈출 2 문제 해결\n * BFS를 사용하여 최소 이동 횟수를 찾는 문제\n * 빨간 구슬만 구멍에 빠뜨리는 최소 횟수를 구함\n */\npublic class Main {\n    static BufferedReader br;\n    static BufferedWriter bw;\n\n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken()), m = Integer.parseInt(st.nextToken());\n        char[][] map = new char[n][m];\n        \n        // 상태를 담아서 전달할 배열 status\n        // 0,1 = 빨간 구슬 y,x 좌표 | 2,3 = 파란 구슬 y,x 좌표 | 4 = 이동횟수\n        int[] status = new int[5];\n        \n        // 빨간구슬위치[][] 파란구슬위치[][]에 온적이 있는지 체크할 목록\n        // 4차원 배열로 두 구슬의 위치 조합을 모두 체크\n        boolean[][][][] visited = new boolean[n][m][n][m];\n        // 맵 정보를 입력받고 구슬의 초기 위치를 저장\n        for (int i = 0; i \u003c n; i++) {\n            char[] input = br.readLine().toCharArray();\n            for (int j = 0; j \u003c m; j++) {\n                char c = input[j];\n                map[i][j] = c;\n                // 구슬의 위치는 따로 저장해놓고 지도 상에는 .으로 표기\n                // (구슬은 이동하므로 맵에는 표시하지 않음)\n                if (c == 'R') {\n                    status[0] = i;\n                    status[1] = j;\n                    map[i][j] = '.';\n                } else if (c == 'B') {\n                    status[2] = i;\n                    status[3] = j;\n                    map[i][j] = '.';\n                }\n            }\n        }\n\n        // BFS를 위한 큐 초기화 및 시작 상태 추가\n        Queue\u003cint[]\u003e queue = new LinkedList\u003cint[]\u003e();\n        queue.add(status);\n\n        // 상하좌우 4방향 이동 좌표 (아래, 위, 오른쪽, 왼쪽)\n        int[][] directions = new int[][] { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };\n        \n        // BFS 탐색: 큐가 빌 때까지 반복\n        while (!queue.isEmpty()) {\n            status = queue.remove();\n\n            // 10번 이상 움직일 경우 -1 출력을 위해 status[4]에 -1을 대입하고 while종료\n            if (status[4] \u003e 10) {\n                status[4] = -1;\n                break;\n            }\n\n            // 파란구슬이 빠진 경우 (파란구슬이 먼저 빠짐, 파란구슬과 빨간구슬이 동시에 빠짐)\n            // 이 경우는 실패이므로 큐에 더 넣지 않고 생략\n            if (map[status[2]][status[3]] == 'O')\n                continue;\n            // 빨간 구슬만 빠진 경우 성공이므로 while 종료\n            else if (map[status[0]][status[1]] == 'O')\n                break;\n\n\n            // 4방향 탐색 (상하좌우)\n            for (int j = 0; j \u003c 4; j++) {\n                int[] dir = directions[j];\n                \n                // 빨간 구슬을 현재 방향으로 굴리기\n                // 구슬의 현재 위치를 복사\n                int[] cur_red = new int[] { status[0], status[1] };\n                // 구슬이 구멍에 빠지거나 벽에 부딪힐 때까지 이동\n                while (true) {\n                    cur_red[0] += dir[0];\n                    cur_red[1] += dir[1];\n                    if (map[cur_red[0]][cur_red[1]] == 'O' || map[cur_red[0]][cur_red[1]] == '#')\n                        break;\n                }\n                // 벽 위치로 간 경우 한 칸 뒤로 되돌림 (벽 앞에 멈춤)\n                if (map[cur_red[0]][cur_red[1]] == '#') {\n                    cur_red[0] -= dir[0];\n                    cur_red[1] -= dir[1];\n                }\n                \n                // 파란 구슬도 같은 방향으로 굴리기\n                int[] cur_blue = new int[] { status[2], status[3] };\n                while (true) {\n                    int next_y = cur_blue[0] + dir[0], next_x = cur_blue[1] + dir[1];\n                    cur_blue[0] = next_y;\n                    cur_blue[1] = next_x;\n                    if (map[next_y][next_x] == 'O' || map[next_y][next_x] == '#')\n                        break;\n                }\n                // 벽에 부딪힌 경우 한 칸 뒤로 되돌림\n                if (map[cur_blue[0]][cur_blue[1]] == '#') {\n                    cur_blue[0] -= dir[0];\n                    cur_blue[1] -= dir[1];\n                }\n\n                // 빨간 구슬과 파란 구슬이 같은 위치에 도달하였으나 구멍이 아닌 경우\n                // 두 구슬은 겹칠 수 없으므로, 더 멀리서 온 구슬을 한 칸 뒤로 이동시킴\n                if (cur_blue[0] == cur_red[0] \u0026\u0026 cur_blue[1] == cur_red[1] \u0026\u0026 map[cur_red[0]][cur_red[1]] != 'O') {\n                    // 두 구슬이 이동한 거리를 계산하여 더 멀리서 온 구슬이 나중에 온 것이므로 그 전 칸으로 조정\n                    int red_dis = Math.abs(status[0] - cur_red[0]) + Math.abs(status[1] - cur_red[1]);\n                    int blue_dis = Math.abs(status[2] - cur_blue[0]) + Math.abs(status[3] - cur_blue[1]);\n                    if (red_dis \u003e blue_dis) {\n                        // 빨간 구슬이 더 멀리서 왔으므로 한 칸 뒤로\n                        cur_red[0] -= dir[0];\n                        cur_red[1] -= dir[1];\n                    } else {\n                        // 파란 구슬이 더 멀리서 왔으므로 한 칸 뒤로\n                        cur_blue[0] -= dir[0];\n                        cur_blue[1] -= dir[1];\n                    }\n                }\n                \n                // 현재 구슬들의 위치 조합이 방문한 적이 있는지 확인\n                // 이미 탐색한 경우 중복 탐색을 방지하기 위해 큐에 추가하지 않음\n                if (!visited[cur_red[0]][cur_red[1]][cur_blue[0]][cur_blue[1]]) {\n                    visited[cur_red[0]][cur_red[1]][cur_blue[0]][cur_blue[1]] = true;\n                    // 이동 횟수를 1 증가시켜서 큐에 추가\n                    queue.add(new int[] { cur_red[0], cur_red[1], cur_blue[0], cur_blue[1], status[4] + 1 });\n                }\n            }\n        }\n\n        // 탐색을 마쳤는데 빨간 구슬만 빠진 경우 이동 횟수 출력, 그 외의 경우 -1 출력\n        // (파란 구슬이 빠지지 않았고 빨간 구슬만 빠진 경우 성공)\n        bw.write((map[status[2]][status[3]] != 'O' \u0026\u0026 map[status[0]][status[1]] == 'O'? status[4]:-1) + \"\");\n        bw.flush();\n    }\n}\n```\n"])</script><script>self.__next_f.push([1,"11:Tea2,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/7562)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/7562\"\u003ehttps://www.acmicpc.net/problem/7562\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 큐를 이용해 탐색할 작업을 돈다.\n- 처음 도착한 값이 최소 값이므로 break.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\n/**\n * 나이트의 이동 문제 해결\n * 체스판에서 나이트가 시작 위치에서 목표 위치까지 가는 최소 이동 횟수를 구하는 문제\n * BFS를 사용하여 최단 경로 탐색\n */\nclass Main {\n    static BufferedReader br;\n    static BufferedWriter bw;\n\n    // 이동 가능한 방위 좌표를 정함 (나이트는 8방향으로 이동 가능)\n    static int[][] direction = new int[][] { { -2, 1 }, { -1, 2 }, { 1, 2 }, { 2, 1 }, { 2, -1 }, { 1, -2 }, { -1, -2 },\n            { -2, -1 } };\n\n    public static void main(String[] args) throws java.lang.Exception {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        // 테스트케이스 개수\n        int t = Integer.parseInt(br.readLine());\n        while (t-- \u003e 0) {\n            // 테스트케이스마다 초기화\n            Queue\u003cint[]\u003e q = new LinkedList\u003cint[]\u003e();\n            // 체스판 한 변의 길이\n            int l = Integer.parseInt(br.readLine());\n            // 접근 숫자를 저장해줄 int 배열 (이동 횟수 저장)\n            int[][] count = new int[l][l];\n            // 시작위치 pos, 도착위치 dest, 현재위치 cur를 선언\n            int[] pos = Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray(),\n                    dest = Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray(),\n                    cur = new int[2];\n\n            // -1일 경우는 방문하지 않았다는 의미를 줌\n            for (int i = 0; i \u003c l; i++) {\n                Arrays.fill(count[i], -1);\n            }\n\n            // 시작위치는 0부터 시작\n            count[pos[0]][pos[1]] = 0;\n            // 탐색 작업을 위해 큐에 넣어줌\n            q.add(pos);\n\n            // 더 이상 탐색할 일이 없을 때까지 반복\n            while (!q.isEmpty()) {\n                // 탐색할 현재 위치를 꺼내서 cur에 대입\n                cur = q.remove();\n                // 목적지에 도착했다면 break (BFS이므로 처음 도착한 것이 최단 경로)\n                if (cur[0] == dest[0] \u0026\u0026 cur[1] == dest[1])\n                    break;\n\n                // 각 방향을 하나씩 꺼내서 확인\n                for (int[] dir : direction) {\n                    int x = cur[0] + dir[0], y = cur[1] + dir[1];\n                    // x,y가 체스판을 벗어나지 않는 범위 내에서 실행\n                    if (x \u003e= 0 \u0026\u0026 x \u003c l \u0026\u0026 y \u003e= 0 \u0026\u0026 y \u003c l) {\n                        // 방문한 적 없는 위치라면\n                        if (count[x][y] == -1) {\n                            // 이전 위치 값에서 1을 늘려 입력하고\n                            count[x][y] = count[cur[0]][cur[1]] + 1;\n                            // 큐에 다음 탐색할 위치로 저장\n                            q.add(new int[] { x, y });\n                        }\n                    }\n                }\n            }\n            // 도착한 위치의 카운트 값 출력\n            bw.write(count[cur[0]][cur[1]] + (t == 0 ? \"\" : \"\\n\"));\n        }\n        bw.flush();\n    }\n}\n```\n"])</script><script>self.__next_f.push([1,"12:Tb67,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/11724)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/11724\"\u003ehttps://www.acmicpc.net/problem/11724\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 방향이 없는 서로 연결된 노드 덩어리의 갯수를 세는 문제다.\n- 방문한 적이 없는 자식 노드까지 탐색을 돌면 된다.\n\n---\n\n```java\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.StringTokenizer;\n\n/**\n * 연결 요소의 개수 문제 해결\n * 무방향 그래프에서 연결된 노드 그룹의 개수를 구하는 문제\n * DFS를 사용하여 각 연결 요소를 탐색\n */\nclass Main {\n    static BufferedReader br;\n    static BufferedWriter bw;\n\n    static boolean[] visited; // 방문 기록을 위한 변수\n    static boolean[][] node; // 인접 행렬: node[i][j]가 true면 i와 j가 연결됨\n    static int n, m; // 정점의 개수 n, 간선의 개수 m\n\n    public static void main(String[] args) throws java.lang.Exception {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        // 값 입력\n        n = Integer.parseInt(st.nextToken());\n        m = Integer.parseInt(st.nextToken());\n        int count = 0; // 연결 요소의 개수\n        node = new boolean[n + 1][n + 1];\n        visited = new boolean[n + 1];\n        \n        // 간선 정보 입력 (무방향 그래프)\n        for (int i = 0; i \u003c m; i++) {\n            st = new StringTokenizer(br.readLine());\n            int parent = Integer.parseInt(st.nextToken()), child = Integer.parseInt(st.nextToken());\n            node[parent][child] = true;\n            node[child][parent] = true; // 무방향이므로 양방향으로 연결\n        }\n\n        // 방문 기록을 1부터 탐색 시작\n        for (int i = 1; i \u003c= n; i++) {\n            if (!visited[i]) {\n                dfs(i); // 연결된 모든 노드 탐색\n                count++; // 새로운 연결 요소 발견\n            }\n        }\n        bw.write(count+\"\");\n        bw.flush();\n    }\n\n    /**\n     * DFS를 사용하여 연결된 모든 노드를 탐색\n     * @param num: 현재 탐색할 정점 번호\n     */\n    public static void dfs(int num) {\n        // 받아온 숫자가 방문한 적이 있다면 종료\n        if (visited[num])\n            return;\n\n        // 방문한 적이 없다면 기록을 남김\n        visited[num] = true;\n        \n        // 현재 노드와 연결된 모든 노드를 탐색\n        for (int i = 1; i \u003c= n; i++) {\n            // 현재 숫자와 연결된 노드를 방문한 적이 있는지 탐색\n            if (node[num][i])\n                dfs(i);\n        }\n    }\n}\n\n```\n"])</script><script>self.__next_f.push([1,"13:T1056,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/14888)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/14888\"\u003ehttps://www.acmicpc.net/problem/14888\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 연산자의 갯수가 주어지고 주어진 숫자 배열에 끼워 넣어 만든 값의 최대,최소 값을 출력하는 문제\n- 연산자 하나 끼워서 계산해보고 다시 빼서 다른거 끼워보며 연산을 하는 과정으로 생각하면 편하다.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.StringTokenizer;\n\n/**\n * 연산자 끼워넣기 문제 해결\n * 주어진 숫자 배열에 연산자를 끼워넣어 만들 수 있는 최대값과 최소값을 구하는 문제\n * 백트래킹을 사용하여 모든 경우의 수를 탐색\n */\nclass Main {\n    static BufferedReader br;\n    static BufferedWriter bw;\n    // DFS를 쓰기 위해 크기(n), 최소값(min), 최대값(max)를 전역 변수로 선언\n    // max는 비교하여 넣기 위해 int의 최소값을, min은 비교하여 최소 값이 들어가야하므로 최대값을 미리 넣어놓음\n    static int n, min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\n    // 숫자배열(numbers), 연산자(oper)는 +,-,*,/ 순서로 개수가 주어지므로 길이가 4인 배열을 선언\n    static int[] numbers, oper = new int[4];\n\n    public static void main(String[] args) throws java.lang.Exception {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        n = Integer.parseInt(br.readLine());\n        // 숫자 배열을 문자열 한 줄로 입력 받아 띄어쓰기로 분리해주는 StringTokenizer에 담아 하나씩 꺼내씀\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        numbers = new int[n];\n        for (int i = 0; i \u003c n; i++)\n            numbers[i] = Integer.parseInt(st.nextToken());\n\n        // 연산자도 위와 같은 방법을 사용\n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i \u003c 4; i++)\n            oper[i] = Integer.parseInt(st.nextToken());\n\n        // 첫 번째 숫자와 숫자 하나를 사용했으므로 다음 값을 찾기 위해 인덱스를 하나 늘려서 1로 전달\n        dfs(numbers[0], 1);\n        System.out.println(max + \"\\n\" + min);\n    }\n\n    /**\n     * 백트래킹을 사용하여 모든 연산자 조합을 탐색\n     * @param num: 현재까지 계산된 값\n     * @param index: 다음에 사용할 숫자의 인덱스\n     */\n    public static void dfs(int num, int index) {\n        // 전달 받은 인덱스값이 n과 같다는 것은 배열의 범위보다 1 크므로 모든 배열을 탐색했다는 의미\n        // 연산이 끝났으므로 값을 최소 최대를 비교하여 넣고 함수를 끝냄\n        if (index == n) {\n            min = min \u003e num ? num : min;\n            max = max \u003c num ? num : max;\n            return;\n        }\n\n        // 연산자 4개 반복 (+,-,*,/)\n        for (int i = 0; i \u003c 4; i++) {\n            // 주어진 연산자 개수가 있다면\n            if (oper[i] \u003e 0) {\n                // 꺼내쓰므로 -1 함\n                oper[i]--;\n                // 연산자에 따라 탐색을 달리하고 다음 숫자를 꺼내기 위해 index+1을 함\n                switch (i) {\n                    case 0: // 덧셈\n                        dfs(num + numbers[index], index + 1);\n                        break;\n                    case 1: // 뺄셈\n                        dfs(num - numbers[index], index + 1);\n                        break;\n                    case 2: // 곱셈\n                        dfs(num * numbers[index], index + 1);\n                        break;\n                    case 3: // 나눗셈\n                        dfs(num / numbers[index], index + 1);\n                        break;\n                }\n                // 위의 연산이 끝났다면 사용한 연산자를 돌려줌 (백트래킹)\n                oper[i]++;\n            }\n        }\n\n    }\n\n}\n```\n"])</script><script>self.__next_f.push([1,"14:T1b60,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/5430)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/5430\"\u003ehttps://www.acmicpc.net/problem/5430\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 문제 자체는 단순하다. 명령대로 R일 경우 순서를 뒤집고, D일 경우 앞에서 하나를 빼준다.\n- 하지만 일일히 뒤집으면 시간이 오래 걸리므로 인덱스 left,right를 선언하여 한칸씩 움직여봤다.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\n\n/**\n * AC 문제 해결 (방법 1 - 인덱스 사용)\n * R(뒤집기)과 D(삭제) 명령을 처리하는 문제\n * 실제로 배열을 뒤집지 않고 인덱스로 처리하여 효율성 향상\n */\nclass Main {\n    static BufferedReader br;\n    static BufferedWriter bw;\n    static int target, n, min = Integer.MAX_VALUE;\n\n    public static void main(String[] args) throws java.lang.Exception {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        // 결과를 위한 StringBuilder\n        StringBuilder sb = new StringBuilder();\n        // TestCase\n        int T = Integer.parseInt(br.readLine());\n\n        for (int i = 0; i \u003c T; i++) {\n            // String.charAt() 보다 char[] 탐색이 빨라서 변경\n            char[] cmds = br.readLine().toCharArray();\n            // 배열의 길이\n            int len = Integer.parseInt(br.readLine());\n            // 오른쪽 인덱스는 배열의 길이보다 하나 작게\n            int right = len - 1;\n            // 왼쪽 인덱스는 0부터\n            int left = 0;\n\n            // 배열 입력\n            String ar = br.readLine();\n            // 앞뒤의 []을 제거해줌\n            ar = ar.substring(1, ar.length() - 1);\n            // , 기준으로 배열로 변환\n            String[] arr = ar.split(\",\");\n\n            // 에러나지 않고 내용물을 출력해주는 신호 print_flag와 R명령어 인식을 위한 reverse_flag 선언\n            boolean print_flag = true, reverse_flag = false;\n\n            // 커맨드 배열에서 하나씩 꺼내서 실행\n            for (char cmd : cmds) {\n                if (cmd == 'R') { \n                    // 명령어 R일 경우 배열을 뒤집어야 하지만 그냥 인덱스 처리만 뒤집기 위한 reverse_flag 조작\n                    reverse_flag = !reverse_flag;\n                } else if (cmd == 'D') { \n                    // 명령어 D일 경우\n                    // R이 안나왔다면 맨 앞 값을 제거해야하지만 left 인덱스 증가\n                    if (!reverse_flag)\n                        left++;\n                    // R이 나왔다면 맨 뒤 값을 제거해야하지만 right 인덱스를 감소\n                    else\n                        right--;\n\n                    // 만약 left 인덱스가 right + 1한 값보다 크다면 에러, +1 한 이유는 빈 배열도 출력해야함\n                    if (left \u003e right + 1) {\n                        sb.append(\"error\\n\");\n                        print_flag = false;\n                        break;\n                    }\n                }\n            }\n            // 출력\n            if (print_flag) {\n                sb.append('[');\n                // 인덱스 증가를 뒤집어졌다면 1씩 내려가고 아니라면 1씩 올라가면서 출력\n                int step = 1;\n                if (reverse_flag) {\n                    step *= -1;\n                }\n\n                // 시작 인덱스는 뒤집어졌다면 right 아니면 left부터 시작\n                // 인덱스 범위는 left와 right 안에 있음\n                for (int index = (reverse_flag ? right : left); index \u003c= right \u0026\u0026 index \u003e= left; index += step) {\n                    sb.append(arr[index] + (index != (reverse_flag ? left : right) ? \",\" : \"\"));\n                }\n                sb.append(\"]\\n\");\n            }\n        }\n\n        // 완성된 String 출력\n        bw.write(sb.toString());\n        bw.flush();\n    }\n}\n```\n\n---\n\n- 위와 같이 푸는 방식도 있지만 java에는 Deque 클래스가 있으므로 일일히 구현할 필요 없이 이미 구현된 클래스를 사용하여도 된다.\n\n```java\n/**\n * AC 문제 해결 (방법 2 - Deque 사용)\n * R(뒤집기)과 D(삭제) 명령을 처리하는 문제\n * Java의 Deque 클래스를 사용하여 간단하게 구현\n */\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Deque;\nimport java.util.LinkedList;\n\nclass Main {\n    static BufferedReader br;\n    static BufferedWriter bw;\n\n    public static void main(String[] args) throws java.lang.Exception {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        StringBuilder sb = new StringBuilder();\n        int T = Integer.parseInt(br.readLine());\n\n        for (int i = 0; i \u003c T; i++) {\n            char[] cmds = br.readLine().toCharArray();\n            int len = Integer.parseInt(br.readLine());\n            \n            String ar = br.readLine();\n            ar = ar.substring(1, ar.length() - 1);\n            String[] arr = ar.split(\",\");\n            \n            // Deque를 선언하여 값을 하나씩 넣어줌\n            Deque dq = new LinkedList();\n            for (int j = 0; j \u003c len; j++) {\n                dq.add(Integer.parseInt(arr[j]));\n            }\n\n            boolean print_flag = true, reverse_flag = false;\n            for (char cmd : cmds) {\n                if (cmd == 'R') {\n                    reverse_flag = !reverse_flag;\n                } else if (cmd == 'D') {\n                    // Deque가 비어있는데 삭제를 요청했으므로 에러를 출력하고 반복문을 종료\n                    if (dq.isEmpty()) {\n                        sb.append(\"error\\n\");\n                        print_flag = false;\n                        break;\n                    }\n\n                    // Deque가 그대로라면 앞에서 삭제\n                    if (!reverse_flag)\n                        dq.removeFirst();\n                    // Deque가 뒤집어졌다면 뒤에서 삭제\n                    else\n                        dq.removeLast();\n                }\n            }\n            if (print_flag) {\n                sb.append(\"[\");\n                // Deque가 빌 때까지 반복\n                while (!dq.isEmpty()) {\n                    // reverse_flag가 true면 뒤에서 하나씩 꺼내고 false라면 앞에서 하나씩 꺼내어 문장에 붙임\n                    sb.append((reverse_flag ? dq.pollLast() : dq.pollFirst()) + (dq.isEmpty() ? \"\" : \",\"));\n                }\n                sb.append(\"]\\n\");\n            }\n        }\n        \n        bw.write(sb.toString());\n        bw.flush();\n    }\n}\n"])</script><script>self.__next_f.push([1,"15:Ta67,"])</script><script>self.__next_f.push([1,"\n[![프로그래머스](https://file.newswire.co.kr/data/datafile2/thumb_640/2021/06/1993996598_20210610150326_5364622170.jpg)](https://programmers.co.kr/learn/courses/30/lessons/42585)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://programmers.co.kr/learn/courses/30/lessons/42585\"\u003ehttps://programmers.co.kr/learn/courses/30/lessons/42585\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 주어진 숫자를 붙여 가며 사칙연산을 통과시켜 값을 확인한다.\n- N이 1부터 9이하로 주어지니 반복횟수를 맞추기 위해 0부터 8로한다.\n- 처음 식은 5가 주어지고 사칙연산을 붙일 수 없으니 카운트 1부터 사칙연산으로 나눠진다.\n- 그런식으로 각 dfs들이 목표 숫자에 도달했을때 최소 값인지 비교하여 대입한다.\n\n```java\n/**\n * N으로 표현 문제 해결\n * 숫자 N을 사용하여 목표 숫자를 만드는 최소 사용 횟수를 구하는 문제\n * DFS를 사용하여 모든 경우의 수를 탐색\n */\nclass Solution {\n    // target과 써야하는 숫자 n을 함수 호출시 매개변수가 늘어나므로 매개변수로 쓰기보다 전역변수로 빼 놓음\n    int target,n,min=Integer.MAX_VALUE;\n\n    public int solution(int N, int number) {\n        target = number;\n        n = N;\n        // 0부터 시작 (사용 횟수, 현재 값)\n        dfs(0, 0);\n        return min == Integer.MAX_VALUE ? -1 : min;\n    }\n\n    /**\n     * DFS를 사용하여 모든 경우의 수를 탐색\n     * @param count: 현재까지 사용한 N의 개수\n     * @param num: 현재까지 만든 숫자\n     */\n    public void dfs(int count, int num) {\n        // count는 0부터 8로 9번, 그보다 크면 -1을 돌려줌\n        if (count \u003e 8) {\n            min = -1;\n            return;\n        }\n        // 생성된 숫자가 목표 값일 경우\n        if (num == target) {\n            // 기존의 목표 생성까지 최소 카운트 값과 비교하여 더 작을 경우 min에 대입\n            min = min\u003ccount?min:count;\n            return;\n        }\n\n        int tempN = n;\n        // 현재 카운트에서 8까지 접근할 만큼 dfs를 반복\n        // N, NN, NNN... 형태로 숫자를 만들 수 있음\n        for (int i = 0; i \u003c 8 - count; i++) {\n            int newCount = count + i + 1; // N을 i+1개 사용\n            // 사칙연산을 수행\n            dfs(newCount, num + tempN);\n            dfs(newCount, num - tempN);\n            dfs(newCount, num * tempN);\n            dfs(newCount, num / tempN);\n\n            // 현재 만든 숫자를 한 칸 앞으로 밀고 n을 추가하여 숫자를 만듦 (N -\u003e NN -\u003e NNN...)\n            tempN = tempN * 10 + n;\n        }\n    }\n}\n```\n"])</script><script>self.__next_f.push([1,"16:T618,\n[![프로그래머스](https://file.newswire.co.kr/data/datafile2/thumb_640/2021/06/1993996598_20210610150326_5364622170.jpg)](https://programmers.co.kr/learn/courses/30/lessons/43105)\n\n## \u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://programmers.co.kr/learn/courses/30/lessons/43105\"\u003ehttps://programmers.co.kr/learn/courses/30/lessons/43105\u003c/a\u003e\u003c/div\u003e\n\n- 삼각형의 밑바닥부터 훑고 올라간다.\n- 맨 밑 우측 끝의 두값을 비교해서 위에 칸에 더해준다.\n- 최대 값은 자연스럽게 0,0에 들어가게 된다.\n\n```java\n/**\n * 정수 삼각형 문제 해결\n * 삼각형의 꼭대기에서 바닥까지 내려올 때, 거쳐간 숫자의 합이 최대가 되는 경로를 찾는 문제\n * 다이나믹 프로그래밍: 아래에서 위로 올라가며 최대값 계산\n */\nclass Solution {\n    public int solution(int[][] triangle) {\n        int len = triangle.length;\n        int[][] dp = new int[len][len]; // dp[i][j]: i행 j열까지의 최대 합\n        \n        // 맨 밑바닥은 그대로 초기화\n        dp[len - 1] = triangle[len - 1];\n        \n        // 삼각형의 밑바닥부터 위로 올라가며 최대값 계산\n        for (int i = len - 2; i \u003e= 0; i--) {\n            for (int j = i; j \u003e= 0; j--) {\n                // 아래 행의 두 값 중 큰 값을 선택하여 현재 값과 더함\n                dp[i][j] = Math.max(dp[i + 1][j], dp[i + 1][j + 1]) + triangle[i][j];\n            }\n        }\n\n        // 최대값은 자연스럽게 꼭대기(0,0)에 들어감\n        return dp[0][0];\n    }\n}\n```\n17:T961,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/11729)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/11729\"\u003ehttps://www.acmicpc.net/problem/11729\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 규칙\n\n  - 1 2 3 칸이 있고 1에 있는 원판을 3으로 옮겨야한다.\n  - 원판은 크기 순서로 쌓여 있는데 큰 원판이 작은원판 위로 갈 수 없다.\n  - 1에서 3으로 옮기려는 원판을 놓고\n  - 1에서 그 다음 원판을 2에 놓고\n  - 3에서 2로 옮긴뒤\n  - 2에서 쌓여있는 원판들을 3으로 옮긴다.\n  - 반복\n\n- hanoi 함수에서 마지막 원판을 옮기는 것부터 조건을 놓고 그 숫자가 마지막 숫자가 아니라면 그 전의 동작으로 거슬러 올라간다.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\n/**\n * 하노이 탑 이동 순서 문제 해결\n * 하노이 탑을 이동시키는 최소 이동 횟수와 이동 순서를 구하는 문제\n * 재귀를 사용하여 해결\n */\nclass Main {\n    static StringBuilder sb = new StringBuilder(); // 이동 순서를 저장할 문자열\n    static int count = 0; // 이동 횟수\n\n    public static void main(String[] args) throws java.lang.Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine()); // 원판 개수\n        hanoi(n, 1, 2, 3); // 1번 기둥에서 3번 기둥으로 이동\n        System.out.println(count + \"\\n\" + sb);\n    }\n\n    /**\n     * 하노이 탑 재귀 함수\n     * @param n: 이동할 원판 개수\n     * @param start: 시작 기둥\n     * @param mid: 보조 기둥\n     * @param end: 목표 기둥\n     */\n    public static void hanoi(int n, int start, int mid, int end) {\n        count++; // 이동 횟수 증가\n        if (n == 1) {\n            // 원판이 1개면 바로 이동\n            sb.append(start + \" \" + end + \"\\n\");\n        } else {\n            // 1단계: n-1개 원판을 시작 기둥에서 보조 기둥으로 이동\n            hanoi(n - 1, start, end, mid);\n            // 2단계: 가장 큰 원판을 시작 기둥에서 목표 기둥으로 이동\n            sb.append(start + \" \" + end + \"\\n\");\n            // 3단계: n-1개 원판을 보조 기둥에서 목표 기둥으로 이동\n            hanoi(n - 1, mid, start, end);\n        }\n    }\n}\n```\n"])</script><script>self.__next_f.push([1,"18:T854,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/2579)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/2579\"\u003ehttps://www.acmicpc.net/problem/2579\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 계단은 3번 연속 갈 수 없다.\n- 고로 현재 칸까지 합은 전전칸까지 합+현재칸 이거나 전전전 칸까지 합+ 전 칸 + 현재 칸 중 큰 것을 넣어준다.\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\n\n/**\n * 계단 오르기 문제 해결\n * 계단을 오를 때 연속으로 3개를 밟을 수 없으므로\n * 다이나믹 프로그래밍을 사용하여 최대 점수를 구함\n */\nclass Main {\n    static int[] dp = new int[300]; // dp[i]: i번째 계단까지의 최대 점수\n    static int[] ar = new int[300]; // ar[i]: i번째 계단의 점수\n\n    public static int max(int a, int b) {\n        return a \u003e b ? a : b;\n    }\n\n    public static void main(String[] args) throws java.lang.Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        int n = Integer.parseInt(br.readLine()); // 계단 개수\n        \n        // 각 계단의 점수 입력\n        for (int i = 0; i \u003c n; i++) {\n            ar[i] = Integer.parseInt(br.readLine());\n        }\n\n        // 초기값 설정\n        dp[0] = ar[0]; // 첫 번째 계단\n        dp[1] = max(ar[0] + ar[1], ar[1]); // 두 번째 계단: 0-\u003e1 또는 바로 1\n        dp[2] = max(ar[0] + ar[2], ar[1] + ar[2]); // 세 번째 계단: 0-\u003e2 또는 1-\u003e2\n        \n        // 4번째 계단부터: 연속 3개를 밟을 수 없으므로\n        // 경우 1: i-2에서 바로 i로 (dp[i-2] + ar[i])\n        // 경우 2: i-3 -\u003e i-1 -\u003e i로 (dp[i-3] + ar[i-1] + ar[i])\n        for (int i = 3; i \u003c n; i++)\n            dp[i] = max(dp[i - 2], dp[i - 3] + ar[i - 1]) + ar[i];\n        \n        bw.write(dp[n - 1] + \"\"); // 마지막 계단까지의 최대 점수\n        bw.flush();\n    }\n}\n```\n"])</script><script>self.__next_f.push([1,"19:T89e,"])</script><script>self.__next_f.push([1,"\n[![프로그래머스](https://file.newswire.co.kr/data/datafile2/thumb_640/2021/06/1993996598_20210610150326_5364622170.jpg)](https://programmers.co.kr/learn/courses/30/lessons/60058)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://programmers.co.kr/learn/courses/30/lessons/60058\"\u003ehttps://programmers.co.kr/learn/courses/30/lessons/60058\u003c/a\u003e\u003c/div\u003e\n\n- 입력받은 문자열을 완전한 괄호 부분이 있는지 확인한다.\n- 앞부분이 완전한 괄호라면 뒤엣 부분을 다시 체크.\n- 완전하지 않다면 길이만큼 재구성한다.\n\n```java\n/**\n * 괄호 변환 문제 해결\n * 균형잡힌 괄호 문자열을 올바른 괄호 문자열로 변환하는 문제\n * 재귀를 사용하여 문제를 분할하여 해결\n */\nclass Solution {\n    public String solution(String p) {\n        // 빈 문자열이면 그대로 반환\n        if (p.length() == 0)\n            return p;\n\n        String u = \"\", v = \"\"; // u: 균형잡힌 괄호 문자열, v: 나머지\n        int count = 0; // 괄호 균형 체크\n        boolean flag = true; // 올바른 괄호 문자열인지 여부\n        \n        // 균형잡힌 괄호 문자열 u를 찾음\n        for (int i = 0; i \u003c p.length(); i++) {\n            if (p.charAt(i) == '(')\n                count++;\n            else\n                count--;\n\n            // ')'가 먼저 나오면 올바른 괄호 문자열이 아님\n            if (count \u003c 0)\n                flag = false;\n\n            // 균형잡힌 괄호 문자열을 찾음\n            else if (count == 0) {\n                u = p.substring(0, i + 1);\n                v = p.substring(i + 1);\n                break;\n            }\n\n        }\n\n        // u가 올바른 괄호 문자열이면 v를 재귀적으로 처리\n        if (flag)\n            return u + solution(v);\n\n        // u가 올바른 괄호 문자열이 아니면 변환 필요\n        // 1. '(' + solution(v) + ')'\n        String result = \"(\" + solution(v) + \")\";\n        // 2. u의 첫 번째와 마지막 문자를 제거하고 나머지 괄호를 뒤집음\n        for (int i = 1; i \u003c u.length() - 1; i++) {\n            result += u.charAt(i) == '(' ? \")\" : \"(\";\n        }\n\n        return result;\n    }\n}\n```\n"])</script><script>self.__next_f.push([1,"1a:T782,\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1927)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/1927\"\u003ehttps://www.acmicpc.net/problem/1927\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 우선순위 큐를 이용하여 정렬한 수 입력받은 값이 0일 경우 가장 작은 값을 출력하도록 한다.\n- 자바의 PriorityQueue를 사용한다.\n- 보통 퀵소트 구현을 하던가 하지만 \u003ca href=\"https://www.joinc.co.kr/w/Site/Test/PqueueVsQsort\"\u003e어떤 분께서 실험한 글\u003c/a\u003e에 따르면 자바 내장 우선순위 큐가 나쁘지 않다고 하니 구현된 것을 사용한다.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.PriorityQueue;\n\n/**\n * 최소 힙 문제 해결\n * 최소 힙을 구현하는 문제\n * PriorityQueue를 사용하여 최소값이 먼저 나오도록 함\n */\nclass Main {\n    public static void main(String[] args) throws java.lang.Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        int n = Integer.parseInt(br.readLine()); // 연산 개수\n        \n        // 우선순위 큐 선언 (기본적으로 최소 힙)\n        PriorityQueue\u003cInteger\u003e q = new PriorityQueue\u003cInteger\u003e();\n        \n        for (int i = 0; i \u003c n; i++) {\n            int temp = Integer.parseInt(br.readLine());\n            // 입력 값이 0일 경우 가장 앞으로 정렬된 최소 값을 출력\n            if (temp == 0) {\n                // 큐에 비어있을 경우 그냥 0을 출력\n                bw.write((q.size() == 0 ? 0 : q.poll()) + \"\\n\");\n            } else {\n                q.add(temp); // 0이 아니면 큐에 추가\n            }\n        }\n        bw.flush();\n    }\n}\n```\n1b:T961,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/12015)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/12015\"\u003ehttps://www.acmicpc.net/problem/12015\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 입력 받는 값을 순차적으로 받는다.\n- 받은 값을 결과 배열에서 탐색을 해서 끼워넣거나 새로 넣는다.\n- 최대 값보다 큰 경우는 새로 넣는다.\n- 그렇지 않은 경우 기존 배열에 탐색해서 적합한 자리를 찾아 새로 갱신한다.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\n/**\n * 가장 긴 증가하는 부분 수열 문제 해결\n * 이분 탐색을 사용하여 O(n log n) 시간 복잡도로 해결\n * result 배열에는 각 길이의 증가하는 부분 수열의 마지막 원소 중 최소값을 저장\n */\nclass Main {\n    public static void main(String[] args) throws java.lang.Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        int[] ar = new int[n];\n        ArrayList\u003cInteger\u003e result = new ArrayList\u003cInteger\u003e();\n        result.add(0); // 인덱스 0은 사용하지 않음 (1부터 시작)\n        StringTokenizer st = new StringTokenizer(br.readLine(), \" \");\n        \n        for (int i = 0; i \u003c n; i++) {\n            int num = ar[i] = Integer.parseInt(st.nextToken());\n            \n            // 현재 값이 result의 마지막 값보다 크면 추가 (부분 수열 길이 증가)\n            if (num \u003e result.get(result.size() - 1))\n                result.add(num);\n            else {\n                // 이분 탐색으로 적절한 위치를 찾아 값 갱신\n                int left = 0, right = result.size() - 1;\n                while (left \u003c right) {\n                    int mid = (left + right) / 2;\n                    if (result.get(mid) \u003c num)\n                        left = mid + 1;\n                    else\n                        right = mid;\n                }\n                // 해당 길이의 부분 수열의 마지막 원소를 더 작은 값으로 갱신\n                result.set(right, num);\n            }\n        }\n        // result.size() - 1이 가장 긴 증가하는 부분 수열의 길이\n        System.out.println(result.size() - 1);\n    }\n}\n```\n"])</script><script>self.__next_f.push([1,"1c:T11fc,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/3055)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/3055\"\u003ehttps://www.acmicpc.net/problem/3055\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 물웅덩이가 '시간마다' 번지고 고슴도치가 '시간마다' 움직인다.\n- BFS를 써서 푼다.\n- 일단 물이 먼저 퍼지고, 그 다음 고슴도치가 움직인다.\n- 물의 위치를 큐에 넣고 탐색을 처음 큐 길이만큼 돌려서 새로 넣은 물의 위치는 다음 타임에 한다.\n- 거리를 적어놓는 int배열 dist를 만들어서 고슴도치가 움직일때마다 현위치에서 이동할 곳에 +1을 넣어준다.\n- 고슴도치가 목적지에 도착하면 고슴도치 위치 큐에 넣지 않아 큐가 비가 되어 while문을 멈춘다.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\n/**\n * 탈출 문제 해결\n * 물이 퍼지고 고슴도치가 이동하는 시뮬레이션 문제\n * BFS를 사용하여 물이 먼저 퍼지고, 그 다음 고슴도치가 이동\n */\nclass Main {\n\n    public static void main(String[] args) throws java.lang.Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        String[] input = br.readLine().split(\" \");\n        int N = Integer.parseInt(input[0]), M = Integer.parseInt(input[1]); // N: 세로, M: 가로\n        char[][] map = new char[N + 1][M + 1];\n        int[][] directions = new int[][] { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } }; // 상하좌우\n        int[][] dist = new int[N + 1][M + 1]; // 고슴도치의 이동 거리\n        int[] dest = new int[2]; // 목적지 위치\n        Queue\u003cint[]\u003e waterQ = new LinkedList\u003cint[]\u003e(), sonicQ = new LinkedList\u003cint[]\u003e(); // 물 큐, 고슴도치 큐\n\n        // 맵 입력 및 초기 위치 설정\n        for (int i = 0; i \u003c N; i++) {\n            char[] temp = br.readLine().toCharArray();\n            for (int j = 0; j \u003c M; j++) {\n                map[i][j] = temp[j];\n                if (temp[j] == '*')\n                    waterQ.add(new int[] { i, j }); // 물 위치\n                else if (temp[j] == 'S')\n                    sonicQ.add(new int[] { i, j }); // 고슴도치 시작 위치\n                else if (temp[j] == 'D')\n                    dest = new int[] { i, j }; // 목적지\n            }\n        }\n\n        // BFS: 매 시간마다 물이 먼저 퍼지고, 그 다음 고슴도치가 이동\n        while (!sonicQ.isEmpty()) {\n            // 물이 먼저 퍼짐: 현재 큐에 있는 물만 퍼짐 (다음 시간의 물은 제외)\n            int size = waterQ.size();\n            while (size-- \u003e 0) {\n                int[] pos = waterQ.poll();\n                for (int[] dir : directions) {\n                    int next_y = pos[0] + dir[0], next_x = pos[1] + dir[1];\n                    // 범위 내이고, 빈 공간이거나 고슴도치 위치면 물이 퍼짐\n                    if (!(next_y \u003c 0 || next_x \u003c 0 || next_y \u003e= N || next_x \u003e= M)\n                            \u0026\u0026 (map[next_y][next_x] == '.' || map[next_y][next_x] == 'S')) {\n                        map[next_y][next_x] = '*';\n                        waterQ.add(new int[] { next_y, next_x });\n                    }\n                }\n            }\n\n            // 고슴도치 이동: 현재 큐에 있는 고슴도치만 이동\n            size = sonicQ.size();\n            while (size-- \u003e 0) {\n                int[] pos = sonicQ.poll();\n                for (int[] dir : directions) {\n                    int next_y = pos[0] + dir[0], next_x = pos[1] + dir[1];\n                    // 범위 내이고, 물이 아니고, 돌이 아니고, 아직 방문하지 않았으면 이동\n                    if (!(next_y \u003c 0 || next_x \u003c 0 || next_y \u003e= N || next_x \u003e= M)\n                            \u0026\u0026 (map[next_y][next_x] != '*' \u0026\u0026 map[next_y][next_x] != 'X')\n                            \u0026\u0026 dist[next_y][next_x] == 0) {\n                        dist[next_y][next_x] = dist[pos[0]][pos[1]] + 1; // 거리 증가\n                        sonicQ.add(new int[] { next_y, next_x });\n                    }\n                }\n            }\n        }\n\n        int result = dist[dest[0]][dest[1]];\n        // 목적지에 도달했으면 거리 출력, 아니면 \"KAKTUS\" 출력\n        bw.write(result != 0 ? result + \"\" : \"KAKTUS\");\n        bw.flush();\n    }\n}\n```\n"])</script><script>self.__next_f.push([1,"1d:T742,\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/9012)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/9012\"\u003ehttps://www.acmicpc.net/problem/9012\u003c/a\u003e\u003c/div\u003e\n\n- '('의 갯수 와 ')'갯수를 세어 )가 더 크게 되면 갯수가 맞지 않으므로 NO를 출력\n- 끝까지 가면 YES를 출력\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\n\n/**\n * 괄호 문제 해결\n * 올바른 괄호 문자열인지 확인하는 문제\n * '('와 ')'의 개수를 세어 확인\n */\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        int n = Integer.parseInt(br.readLine()); // 테스트 케이스 개수\n\n        for (int a = 0; a \u003c n; a++) {\n            int[] ar = new int[2]; // ar[0]: '(' 개수, ar[1]: ')' 개수\n            boolean flag = true;\n            String input = br.readLine();\n\n            for (int i = 0; i \u003c input.length(); i++) {\n                if (input.charAt(i) == '(')\n                    ar[0]++;\n                else\n                    ar[1]++;\n\n                // ')'가 '('보다 많아지면 올바른 괄호 문자열이 아님\n                if (ar[0] \u003c ar[1]) {\n                    flag = false;\n                    break;\n                }\n            }\n\n            // '('와 ')'의 개수가 같고, 중간에 ')'가 더 많아진 적이 없어야 YES\n            bw.write(flag \u0026\u0026 ar[0] == ar[1] ? \"YES\" : \"NO\");\n            bw.newLine();\n            bw.flush();\n        }\n        br.close();\n        bw.close();\n    }\n}\n```\n1e:T877,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1620)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/1620\"\u003ehttps://www.acmicpc.net/problem/1620\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 이름을 키로 하여 번호를 갖는 맵과 번호를 인덱스로 하는 String배열을 통해 참조하도록 한다.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.HashMap;\n\n/**\n * 나는야 포켓몬 마스터 이다솜 문제 해결\n * 포켓몬 이름과 번호를 양방향으로 조회할 수 있어야 하는 문제\n * HashMap으로 이름-\u003e번호, 배열로 번호-\u003e이름 조회\n */\nclass Main {\n    public static void main(String[] args) throws java.lang.Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        String[] input = br.readLine().split(\" \");\n        int N = Integer.parseInt(input[0]), M = Integer.parseInt(input[1]); // N: 포켓몬 개수, M: 문제 개수\n        \n        // 이름을 키로 하여 번호를 갖는 맵과 번호를 인덱스로 하는 String 배열\n        HashMap\u003cString, Integer\u003e map = new HashMap\u003cString, Integer\u003e();\n        String[] ar = new String[N];\n        \n        // 포켓몬 정보 입력\n        for (int i = 0; i \u003c N; i++) {\n            String in = br.readLine();\n            map.put(in, i + 1); // 이름 -\u003e 번호\n            ar[i] = in; // 번호 -\u003e 이름\n        }\n\n        // 문제 처리\n        for (int i = 0; i \u003c M; i++) {\n            String m = br.readLine();\n            // 입력이 숫자인지 확인\n            if (m.matches(\"[-+]?\\\\d*\\\\.?\\\\d+\")) {\n                // 숫자면 배열에서 이름 조회\n                bw.write(ar[Integer.parseInt(m) - 1]);\n            } else {\n                // 이름이면 맵에서 번호 조회\n                bw.write(map.get(m) + \"\");\n            }\n            if (i != M - 1)\n                bw.write(\"\\n\");\n        }\n        bw.flush();\n    }\n}\n\n\n```\n"])</script><script>self.__next_f.push([1,"1f:T6fc,\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/15829)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/15829\"\u003ehttps://www.acmicpc.net/problem/15829\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 문제를 잘 읽자.\n- M값의 나머지로만 움직여야한다.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\n\n/**\n * Hashing 문제 해결\n * 문자열을 해시값으로 변환하는 문제\n * 각 문자의 위치에 따라 가중치를 곱하여 해시값 계산\n * M값의 나머지로만 계산해야 함 (오버플로우 방지)\n */\npublic class Main {\n    static final int r = 31; // 해시 함수의 기수\n    static final int M = 1234567891; // 나머지 연산을 위한 모듈러 값\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        int n = Integer.parseInt(br.readLine());\n        char[] input = br.readLine().toCharArray();\n        long sum = 0;\n        \n        // 각 문자에 대해 해시값 계산\n        // a=1, b=2, ..., z=26으로 변환하고 r의 i제곱을 곱함\n        for (int i = 0; i \u003c n; i++) {\n            sum += (((input[i] - 'a') + 1) * pow(r, i));\n        }\n\n        // M으로 나눈 나머지 출력\n        bw.write((sum % M) + \"\");\n\n        bw.flush();\n    }\n\n    /**\n     * 거듭제곱 계산 (재귀)\n     * @param a: 밑\n     * @param b: 지수\n     * @return: a^b % M\n     */\n    static long pow(int a, int b) {\n        return b == 0 ? 1 : a * pow(a, b - 1) % M;\n    }\n\n}\n```\n20:T6be,\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1107)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/1107\"\u003ehttps://www.acmicpc.net/problem/1107\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 시"])</script><script>self.__next_f.push([1,"작 100이니 목적지에서 100을 절대값을 넣고 찾기 시작한다.\n- 한글자씩 떼서 확인하는것이 한칸씩 움직이는것과 비교했을때 뭐가 더 적은가를 비교하며 반복한다.\n\n---\n\n```python\n/**\n * 리모컨 문제 해결\n * 고장난 버튼을 제외하고 숫자 버튼으로 목표 채널에 도달하는 최소 버튼 클릭 횟수를 구하는 문제\n * 브루트포스 알고리즘을 사용하여 모든 가능한 채널을 확인\n */\n\nN = int(input()) # 목표 채널\nM = int(input()) # 고장난 버튼 개수\n\n# 사용 가능한 숫자 버튼 집합 (0~9)\nenable = {str(x) for x in range(10)}\nif (M != 0):\n    # 고장난 버튼을 사용 가능한 집합에서 제거\n    enable -= set(input().split())\n\n# 초기값: 현재 채널(100)에서 목표 채널까지 + 또는 - 버튼만 사용하는 경우\nresult = abs(N - 100)\n\n# 0부터 1,000,000까지 모든 채널을 확인\nfor i in range(1000001):\n    is_true = True\n    # 현재 채널의 각 자리수가 사용 가능한 버튼인지 확인\n    for c in str(i):\n        if (c not in enable):\n            is_true = False # 사용 불가능한 버튼이 있으면 건너뜀\n            break\n    # 모든 자리수가 사용 가능한 버튼이면\n    if is_true is True:\n        # 현재 채널로 이동하는 버튼 클릭 횟수 + 목표 채널까지의 차이\n        result = min(result, abs(N - i) + len(str(i)))\n\nprint(result) # 최소 버튼 클릭 횟수 출력\n\n```\n21:T68a,\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1463)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/1463\"\u003ehttps://www.acmicpc.net/problem/1463\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 문제는 최단거리로 n에서 1로 가는거지만 거꾸로 1에서 최단거리로 n가는 방법도 적용된다.\n- 배열은 n+1만큼 선언하여 끝까지 도달할때 더 작은값이 들어가는 조건을 찾아 비교하여 채운다.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.InputSt"])</script><script>self.__next_f.push([1,"reamReader;\n\n/**\n * 1로 만들기 문제 해결\n * 정수 n을 1로 만드는 최소 연산 횟수를 구하는 문제\n * 다이나믹 프로그래밍을 사용하여 각 숫자를 1로 만드는 최소 횟수를 계산\n */\nclass Main{\npublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\t\n\t\t// ar[i]: i를 1로 만드는 최소 연산 횟수\n\t\tint[] ar = new int[n+1];\n\t\t\n\t\t// 2부터 n까지 각 숫자를 1로 만드는 최소 횟수 계산\n\t\tfor(int i=2;i\u003c=n;i++){\n\t\t\t// 기본값: 1을 빼는 연산 (ar[i-1] + 1)\n\t\t\tar[i] = ar[i-1]+1;\n\t\t\t\n\t\t\t// 2로 나누어 떨어지는 경우: 2로 나누는 연산과 비교하여 더 작은 값 선택\n\t\t\tif(i%2==0)\n\t\t\t\tar[i] = ar[i]\u003car[i/2]+1?ar[i]:ar[i/2]+1;\n\t\t\t\n\t\t\t// 3으로 나누어 떨어지는 경우: 3으로 나누는 연산과 비교하여 더 작은 값 선택\n\t\t\tif(i%3==0)\n\t\t\t\tar[i] = ar[i]\u003car[i/3]+1?ar[i]:ar[i/3]+1;\n\t\t}\n\t\t\n\t\t// n을 1로 만드는 최소 연산 횟수 출력\n\t\tSystem.out.println(ar[n]);\n\t}\n}\n\n\n```\n22:T63c,\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1259)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/1259\"\u003ehttps://www.acmicpc.net/problem/1259\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 숫자가 대칭하는 모양인지 판별하는 문제이다.\n- 숫자이지만 대칭하는 모양을 판별하는 것은 문자로 봐야한다.\n- 문자 배열 인덱스를 하나씩 좌우에서 들어가면서 비교한다.\n\n---\n\n```java\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * 펠린드롬수 문제 해결\n * 숫자가 대칭인지(펠린드롬인지) 판별하는 문제\n * 문자열로 변환하여 좌우 대칭을 확인\n */\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String"])</script><script>self.__next_f.push([1," input = reader.readLine();\n        \n        // \"0\"이 입력될 때까지 반복\n        while (!input.equals(\"0\")) {\n            String result = \"yes\"; // 기본값은 펠린드롬\n            // 문자열의 절반까지만 확인 (대칭이므로)\n            for (int i = 0; i \u003c input.length() / 2; i++) {\n                // 앞쪽 문자와 뒤쪽 문자가 다르면 펠린드롬이 아님\n                if (input.charAt(i) != input.charAt(input.length() - i - 1)) {\n                    result = \"no\";\n                    break;\n                }\n            }\n            System.out.println(result);\n            input = reader.readLine();\n        }\n    }\n}\n\n```\n23:Tba1,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1012)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/1012\"\u003ehttps://www.acmicpc.net/problem/1012\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 이어진 배추가 있는지 탐색하여 필요한 배추벌레 갯수를 구한다.\n- 한점을 탐색하여 상하좌우를 살펴서 있을 경우 한마리로 배추가 없을때까지 탐색을 하여 배추를 배열에서 제거하고 카운트를 늘린다.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\n/**\n * 유기농 배추 문제 해결\n * 배추밭에서 인접한 배추 그룹의 개수를 구하는 문제\n * DFS를 사용하여 연결된 배추들을 탐색\n */\npublic class Main {\n    static int[][] ar; // 배추밭 지도\n\n    /**\n     * DFS를 사용하여 인접한 배추들을 모두 탐색하고 제거\n     * @param x: 현재 x 좌표\n     * @param y: 현재 y 좌표\n     * @param m: 배추밭 가로 길이\n     * @param n: 배추밭 세로 길이\n     */\n    public static void finder(int x, int y, int m, int n) {\n        // 범위를 벗어나거나 배추가 없으면 종료\n        if (x \u003e= m || y \u003e= n || x \u003c 0 || y \u003c 0 || ar[y][x] == 0)\n            return;\n        \n        // 현재 위치의 배추를 제거 (방문 표시)\n        ar[y][x] = 0;\n        \n        // 상하좌우 4방향으로 재귀 탐색\n        finder(x + 1, y, m, n); // 오른쪽\n        finder(x, y + 1, m, n); // 아래\n        finder(x - 1, y, m, n); // 왼쪽\n        finder(x, y - 1, m, n); // 위\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine()); // 테스트 케이스 개수\n        \n        for (int i = 0; i \u003c n; i++) {\n            // 입력: 가로(m), 세로(n), 배추 개수(k)\n            int[] data = Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n            ar = new int[data[1]][data[0]]; // 배추밭 초기화\n            \n            // 배추 위치 입력\n            for (int j = 0; j \u003c data[2]; j++) {\n                int[] pos = Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n                ar[pos[1]][pos[0]] = 1; // 배추 위치 표시\n            }\n\n            // 연결된 배추 그룹의 개수 세기\n            int count = 0;\n            for (int y = 0; y \u003c data[1]; y++) {\n                for (int x = 0; x \u003c data[0]; x++) {\n                    if (ar[y][x] == 1) {\n                        count++; // 새로운 그룹 발견\n                        finder(x, y, data[0], data[1]); // 연결된 모든 배추 탐색 및 제거\n                    }\n                }\n            }\n            System.out.println(count); // 필요한 지렁이 개수 출력\n        }\n    }\n}\n```\n"])</script><script>self.__next_f.push([1,"24:Tccd,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/10989)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/10989\"\u003ehttps://www.acmicpc.net/problem/10989\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 정렬 속도를 중요시 하는 퀵정렬을 이용한다.\n- 기준을 왼쪽 앞으로 하느냐 가운데로 하느냐가 있는데 일단 왼쪽 앞으로 했다.\n- 기준을 잡고 양 가운데로 나눈다.\n- 왼쪽을 기준값보다 작은 값, 오른쪽을 큰 값.\n- 나눠진 배열에서 기준값을 잡고 다시 양쪽으로 나누기 반복\n- 두개만 남은 배열에서 정렬 시작.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\n\n/**\n * 수 정렬하기 3 문제 해결\n * 퀵 정렬을 사용하여 배열을 정렬하는 문제\n * 분할 정복 알고리즘을 사용\n */\npublic class Main {\n    /**\n     * 파티션 함수: 기준값(pivot)을 기준으로 배열을 분할\n     * @param ar: 정렬할 배열\n     * @param l: 왼쪽 인덱스\n     * @param r: 오른쪽 인덱스\n     * @return: 기준값의 최종 위치\n     */\n    public int parition(int[] ar, int l, int r) {\n        int p = ar[l], low = l, high = r; // 기준값은 왼쪽 첫 번째 원소\n        low++;\n        \n        while (low \u003c= high) {\n            // 왼쪽에서 기준값보다 큰 값을 찾음\n            while (low \u003c= r \u0026\u0026 p \u003e ar[low])\n                low++;\n            // 오른쪽에서 기준값보다 작은 값을 찾음\n            while (high \u003e= l \u0026\u0026 p \u003c ar[high])\n                high--;\n\n            // low와 high가 교차하지 않았으면 두 값을 교환\n            if (low \u003c= high) {\n                int temp = ar[low];\n                ar[low] = ar[high];\n                ar[high] = temp;\n                low++;\n                high--;\n            }\n        }\n        // 기준값을 올바른 위치로 이동\n        ar[l] = ar[high];\n        ar[high] = p;\n\n        return high; // 기준값의 최종 위치 반환\n    }\n\n    /**\n     * 퀵 정렬 함수: 재귀적으로 배열을 정렬\n     * @param ar: 정렬할 배열\n     * @param left: 왼쪽 인덱스\n     * @param right: 오른쪽 인덱스\n     */\n    public void quickSort(int[] ar, int left, int right) {\n        if (left \u003c right) {\n            int p = parition(ar, left, right); // 기준값의 위치\n            quickSort(ar, left, p - 1); // 왼쪽 부분 정렬\n            quickSort(ar, p + 1, right); // 오른쪽 부분 정렬\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        int n = Integer.parseInt(br.readLine());\n        int[] ar = new int[n];\n        \n        // 배열 입력\n        for (int i = 0; i \u003c n; i++) {\n            ar[i] = Integer.parseInt(br.readLine());\n        }\n        \n        // 퀵 정렬 수행\n        new Main().quickSort(ar, 0, n - 1);\n\n        // 정렬된 결과 출력\n        for (int s : ar)\n            bw.write(s + \"\\n\");\n\n        bw.flush();\n    }\n}\n```\n"])</script><script>self.__next_f.push([1,"25:T1e05,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/20927)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/20927\"\u003ehttps://www.acmicpc.net/problem/20927\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 문제에서 스패닝트리만 읽고 최소 스패닝트리로 하면 답이 없다.\n- 브루트포스로 접근해야한다.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\n/**\n * Degree Bounded Minimum Spanning Tree 문제 해결\n * 각 정점의 차수 제한을 만족하는 스패닝 트리를 찾는 문제\n * 백트래킹을 사용하여 모든 가능한 간선 조합을 탐색\n */\n\n/**\n * 간선을 나타내는 클래스\n * 시작점, 끝점, 비용을 저장하고 비용 기준으로 정렬 가능\n */\nclass Node implements Comparable\u003cNode\u003e{\n    int start,end,cost;\n    public Node(int start,int end,int cost){\n        // 시작점과 끝점을 작은 값이 start, 큰 값이 end가 되도록 정렬\n        this.start = (start\u003cend?start:end);\n        this.end = (start\u003cend?end:end);\n        this.cost = cost;\n    }\n    @Override\n    public int compareTo(Node o) {\n        // 비용 기준 오름차순 정렬\n        return this.cost - o.cost;\n    }\n}\n\npublic class Main {\n    static BufferedReader br;\n    static BufferedWriter bw;\n    static StringBuilder sb;\n    // ar: Union-Find를 위한 부모 배열\n    // limit: 각 정점의 차수 제한\n    // degree: 각 정점의 현재 차수\n    // check: 백트래킹에서 간선 선택 여부를 체크하는 배열\n    static int[] ar,limit,degree,check;\n    static int n,m,sum=Integer.MAX_VALUE; // n: 정점 수, m: 간선 수, sum: 최소 비용\n    static Queue\u003cNode\u003e nodes = new LinkedList\u003cNode\u003e(); // 최종 선택된 간선들을 저장\n    static ArrayList\u003cNode\u003e edges = new ArrayList\u003cNode\u003e(); // 모든 간선 정보\n    \n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        sb = new StringBuilder();\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        n  = Integer.parseInt(st.nextToken()); // 정점의 개수\n        m = Integer.parseInt(st.nextToken()); // 간선의 개수\n        limit = new int[n+1]; // 각 정점의 차수 제한\n        check = new int[m+1]; // 간선 선택 여부 체크 배열\n        \n        // 각 정점의 차수 제한 입력\n        st = new StringTokenizer(br.readLine());\n        for(int i=1;i\u003c=n;i++){\n            limit[i] = Integer.parseInt(st.nextToken());\n        }\n        \n        // 간선 정보 입력 (시작점, 끝점, 비용)\n        for(int i=0;i\u003cm;i++){\n            st = new StringTokenizer(br.readLine());\n            edges.add(new Node(Integer.parseInt(st.nextToken()),Integer.parseInt(st.nextToken()),Integer.parseInt(st.nextToken())));\n        }\n        \n        // 간선을 비용 기준으로 정렬 (백트래킹 효율성을 위해)\n        Collections.sort(edges);\n        \n        // 백트래킹 시작: n-1개의 간선을 선택하여 스패닝 트리 구성\n        backtrack(0,0);\n\n        // 결과 출력\n        // 스패닝 트리를 찾지 못한 경우\n        if(nodes.isEmpty()){\n            // 정점이 1개인 경우는 항상 가능, 그 외는 불가능\n            sb.append(n==1?\"YES\":\"NO\");\n        }\n        else{\n            // 스패닝 트리를 찾은 경우 YES와 선택된 간선들 출력\n            sb.append(\"YES\\n\");\n            while(!nodes.isEmpty()){\n                Node node = nodes.poll();\n                sb.append(node.start+\" \"+node.end+(nodes.isEmpty()?\"\":\"\\n\"));\n            }\n        }\n        bw.write(sb.toString());\n        bw.flush();\n        bw.close();\n    }\n    \n    /**\n     * 백트래킹을 사용하여 n-1개의 간선을 선택\n     * @param index: 현재 고려할 간선의 인덱스\n     * @param cnt: 현재까지 선택한 간선의 개수\n     */\n    private static void backtrack(int index, int cnt) {\n        // n-1개의 간선을 선택했으면 스패닝 트리인지 확인\n        if(cnt==n-1){\n            boolean flag = true;\n            int tsum = 0; // 현재 선택한 간선들의 총 비용\n            \n            // Union-Find 초기화\n            ar = new int[n+1];\n            Arrays.fill(ar,-1); // -1은 루트 노드를 의미\n            degree = new int[n+1]; // 각 정점의 차수 초기화\n            Queue\u003cNode\u003e temp = new LinkedList\u003cNode\u003e(); // 현재 선택한 간선들 임시 저장\n\n            // 선택된 간선들을 사용하여 Union-Find 수행\n            for(int i=0;i\u003cm;i++){\n                if(check[i]==0)continue; // 선택되지 않은 간선은 건너뜀\n                Node node = edges.get(i);\n                // 두 정점이 다른 집합에 속해있으면 (사이클이 없으면)\n                if(find(node.start)!=find(node.end)){\n                    union(node.start, node.end); // 두 집합을 합침\n                    degree[node.start]++; // 두 정점의 차수 증가\n                    degree[node.end]++;\n                    temp.add(node); // 선택된 간선 저장\n                    tsum+=node.cost; // 비용 누적\n                }\n            }\n\n            // 모든 정점이 연결되어 있는지 확인 (스패닝 트리 조건)\n            // 그리고 각 정점의 차수가 제한을 넘지 않는지 확인\n            for(int i=1;i\u003c=n;i++){\n                // 이전 정점과 연결되어 있지 않거나, 차수가 제한을 초과하면 실패\n                if((i\u003e1\u0026\u0026find(i-1)!=find(i))||(degree[i]\u003elimit[i])){\n                    flag=false;\n                    break;\n                }\n            }\n\n            // 조건을 만족하는 스패닝 트리를 찾았고, 비용이 더 작으면 업데이트\n            if(flag){\n                if(sum\u003etsum){\n                    sum=tsum;\n                    nodes=new LinkedList\u003c\u003e(temp);\n                }\n            }\n\n            return;\n        }\n\n        // 백트래킹: 간선을 선택하거나 선택하지 않음\n        for(int i=index;i\u003cm;i++){\n            if(check[i]==1)continue; // 이미 선택된 간선은 건너뜀\n            check[i]=1; // 간선 선택\n            backtrack(i+1, cnt+1); // 다음 간선으로 재귀\n            check[i]=0; // 백트래킹: 선택 취소\n        }\n    }\n    /**\n     * Union-Find: 두 집합을 합치는 함수\n     * @param start: 첫 번째 정점\n     * @param end: 두 번째 정점\n     */\n    private static void union(int start, int end) {\n        int pa = find(start),pb=find(end); // 각 정점의 루트 찾기\n        if(pa==pb)return; // 이미 같은 집합에 속해있으면 종료\n        // pb의 부모를 pa로 설정하여 두 집합을 합침\n        // ar[pa]+=ar[pb]; // 주석 처리된 부분은 랭크 기반 최적화\n        ar[pb]=pa;\n        return;\n    }\n    \n    /**\n     * Union-Find: 정점의 루트를 찾는 함수 (경로 압축 적용)\n     * @param index: 찾을 정점\n     * @return: 정점이 속한 집합의 루트\n     */\n    private static int find(int index) {\n        // ar[index] \u003c 0이면 루트 노드\n        if(ar[index]\u003c0)return index;\n        // 경로 압축: 부모를 루트로 직접 연결하여 다음 조회 시 속도 향상\n        return ar[index] = find(ar[index]);\n    }\n}\n\n\n\n```\n"])</script><script>self.__next_f.push([1,"26:Te1e,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/18111)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/18111\"\u003ehttps://www.acmicpc.net/problem/18111\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 땅을 평평하게 하기 위해 파거나 쌓는 작업을 하는데 그 중 가장 높은 높이를 출력해야한다.\n- 반복의 범위를 줄이기 위해 높이 최저,최고 값을 정해준다.\n- 최저값부터 최고값까지 각 칸과의 거리를 구하여 음수가 나오면 파내는것이고 양수가 나오면 더해줘야하므로 가방에서 더해준다.\n- 배열 탐색을 끝내고 가방에서 쓸 수 있는 블록 보다 더 쓸 경우는 넘어간다.\n- 블록이 사용가능한 갯수면 최소 시간을 비교하여 대입한다.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\n\n/**\n * 마인크래프트 문제 해결\n * 땅을 평평하게 만들기 위해 파거나 쌓는 작업의 최소 시간과 최대 높이를 구하는 문제\n * 브루트포스: 가능한 모든 높이에 대해 시간을 계산하여 최소값 찾기\n */\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        String[] input = br.readLine().split(\" \");\n\n        int n = Integer.parseInt(input[0]), m = Integer.parseInt(input[1]), b = Integer.parseInt(input[2]); // n: 세로, m: 가로, b: 인벤토리 블록 개수\n        int min = 501, max = -1; // 최소 높이, 최대 높이\n        int[][] land = new int[n][m];\n\n        // 땅의 높이 입력 및 최소/최대 높이 찾기\n        for (int i = 0; i \u003c n; i++) {\n            input = br.readLine().split(\" \");\n            for (int j = 0; j \u003c m; j++) {\n                int t = Integer.parseInt(input[j]);\n                land[i][j] = t;\n                if (t \u003c min)\n                    min = t;\n                if (t \u003e max)\n                    max = t;\n            }\n        }\n\n        int minTime = Integer.MAX_VALUE, height = 0;\n        // 최소 높이부터 최대 높이까지 모든 경우를 확인\n        for (int h = min; h \u003c= max; h++) {\n            int inven = b, time = 0; // 현재 인벤토리, 소요 시간\n            for (int[] row : land) {\n                for (int land_h : row) {\n                    int gap = land_h - h; // 목표 높이와의 차이\n                    if (gap \u003e 0) {\n                        // 블록을 제거해야 함 (2초 소요)\n                        time += gap * 2;\n                        inven += gap; // 제거한 블록을 인벤토리에 추가\n                    } else if (gap \u003c 0) {\n                        // 블록을 쌓아야 함 (1초 소요)\n                        time -= gap; // gap이 음수이므로 -를 붙여서 양수로\n                        inven += gap; // 사용한 블록을 인벤토리에서 제거\n                    }\n                }\n            }\n            // 인벤토리에 블록이 부족하면 불가능\n            if (inven \u003c 0) {\n                continue;\n            }\n            // 최소 시간이면 업데이트 (같은 시간이면 높이가 높은 것을 선택)\n            if (minTime \u003e= time) {\n                minTime = time;\n                height = h;\n            }\n\n        }\n\n        bw.write(minTime + \" \" + height);\n        bw.flush();\n    }\n}\n\n```\n"])</script><script>self.__next_f.push([1,"27:T955,"])</script><script>self.__next_f.push([1,"\n[![프로그래머스](https://file.newswire.co.kr/data/datafile2/thumb_640/2021/06/1993996598_20210610150326_5364622170.jpg)](https://programmers.co.kr/learn/courses/30/lessons/17681)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://programmers.co.kr/learn/courses/30/lessons/17681\"\u003ehttps://programmers.co.kr/learn/courses/30/lessons/17681\u003c/a\u003e\u003c/div\u003e\n\n- 입력받은 숫자를 2진수로 변환하여 비교하는 문제다.\n- 이진수 문장길이가 같지 않을 수 있으므로 거꾸로 받아서 비교하여 다시 역순으로 배출한다.\n\n```java\n\n/**\n * 비밀지도 문제 해결\n * 두 배열의 숫자를 이진수로 변환하여 OR 연산을 수행하는 문제\n * 1은 '#'으로, 0은 공백으로 변환하여 지도를 만듦\n */\nclass Solution {\n    public String[] solution(int n, int[] arr1, int[] arr2) {\n        String[] answer = new String[n];\n\n        for (int i = 0; i \u003c n; i++) {\n            // 각 숫자를 이진수 문자열로 변환 (거꾸로 저장됨)\n            char[] r1 = makeString(arr1[i]), r2 = makeString(arr2[i]);\n            String result = \"\";\n            int len1 = r1.length, len2 = r2.length;\n            \n            // 각 자리수를 비교하여 OR 연산 수행\n            // 두 이진수 중 하나라도 1이면 '#'(벽), 둘 다 0이면 공백\n            for (int j = 0; j \u003c n; j++) {\n                // j번째 자리가 범위 내에 있고 '#'인지 확인\n                boolean bit1 = (j \u003c len1 \u0026\u0026 r1[j] == '#');\n                boolean bit2 = (j \u003c len2 \u0026\u0026 r2[j] == '#');\n                // OR 연산: 둘 중 하나라도 true면 '#', 아니면 공백\n                // 결과를 앞에 추가하여 역순으로 저장 (나중에 올바른 순서가 됨)\n                result = (bit1 || bit2 ? \"#\": \" \") + result;\n            }\n            answer[i] = result;\n        }\n        return answer;\n    }\n\n    /**\n     * 숫자를 이진수로 변환하여 '#'과 공백으로 표현\n     * @param num: 변환할 숫자\n     * @return: 이진수 표현 (거꾸로 저장됨, LSB부터)\n     */\n    public char[] makeString(int num) {\n        String result = \"\";\n        while (num \u003e 0) {\n            // 2로 나눈 나머지가 1이면 '#', 0이면 공백\n            result += (num % 2 == 1 ? \"#\" : \" \");\n            num /= 2; // 다음 자리수로 이동\n        }\n        return result.toCharArray();\n    }\n}\n\n\n```\n"])</script><script>self.__next_f.push([1,"28:T7b0,\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/2745)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/2745\"\u003ehttps://www.acmicpc.net/problem/2745\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 입력받은 문자를 하나씩 떼어서 각 자리의 진법 배수 만큼 곱하여 더해준다.\n- 숫자 범위에 걸릴까봐 Math.pow 대신 pow를 구현해서 썼다.\n\n---\n\n```java\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\n\n/**\n * 진법 변환 문제 해결\n * B진법 수를 10진법으로 변환하는 문제\n * 각 자리수를 해당 진법의 거듭제곱과 곱하여 합산\n */\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        String[] input = br.readLine().split(\" \");\n        char[] text = input[0].toUpperCase().toCharArray(); // 대문자로 변환\n        int b = Integer.parseInt(input[1]); // 진법\n        long sum = 0;\n        int len = text.length;\n        \n        // 오른쪽부터 왼쪽으로 (낮은 자리부터 높은 자리로)\n        for (int i = len - 1; i \u003e= 0; i--) {\n            int t = text[i];\n            // 숫자(0-9)면 48('0')을 빼고, 문자(A-Z)면 55('A'-10)를 빼서 10진수 값으로 변환\n            t -= (t \u003e= 48 \u0026\u0026 t \u003c= 57) ? 48 : 55;\n            // 각 자리수에 진법의 거듭제곱을 곱하여 합산\n            sum += t * pow(b, len - 1 - i);\n        }\n        bw.write(sum + \"\");\n        bw.flush();\n    }\n\n    /**\n     * 거듭제곱 계산 (재귀)\n     * @param a: 밑\n     * @param b: 지수\n     * @return: a^b\n     */\n    static long pow(int a, int b) {\n        return b == 0 ? 1 : a * pow(a, b - 1);\n    }\n\n}\n\n```\n29:Tc7b,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/6603)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/6603\"\u003ehttps://www.acmicpc.net/problem/6603\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- Queue에 숫자를 하나씩 넣고 다음 숫자들을 하나씩 끼워서 입력받은 길이 만큼 만들어보는 문제다.\n- 받은 숫자 다음 꺼낸 숫자가 받은 숫자보다 커야 그 다음 숫자를 끼워본다.\n- 재귀로 돌면서 끼워서 6개가 되면 출력한다.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\n/**\n * 로또 문제 해결\n * 주어진 숫자들 중에서 6개를 선택하는 모든 조합을 출력하는 문제\n * 백트래킹을 사용하여 조합 생성\n */\npublic class Main {\n    static BufferedReader br;\n    static BufferedWriter bw;\n    static int n; // 입력 길이\n    static Queue\u003cInteger\u003e q; // 입력 받은 숫자들을 담는 큐\n    \n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        String input = br.readLine();\n        \n        while(!input.equals(\"0\")){ // 입력받은 문자열이 0이 아닐 때 반복\n            StringTokenizer st = new StringTokenizer(input); // 띄어쓰기로 구분하여 하나씩 꺼내주는 StringTokenizer를 사용\n            n = Integer.parseInt(st.nextToken());\n            q = new LinkedList\u003cInteger\u003e(); // 큐 선언\n            while(st.hasMoreTokens()){ // 큐에 입력받은 숫자들을 전부 집어 넣음\n                q.add(Integer.parseInt(st.nextToken()));\n            }\n            // 조합 함수 실행, 빈 문자열과 마지막 받은 숫자를 0으로 넣음 (들어간 숫자가 없으므로 인덱스 개수도 0)\n            permutation(\"\",0,0);\n            input = br.readLine();\n\n            bw.newLine();\n        }\n\n        bw.flush();\n    }\n\n    /**\n     * 조합 함수 (백트래킹)\n     * @param num: 현재까지 선택한 숫자들을 문자열로 저장\n     * @param lastNUM: 마지막으로 선택한 숫자\n     * @param index: 현재까지 선택한 숫자의 개수\n     */\n    public static void permutation(String num, int lastNUM,int index) throws IOException{\n        if(index==6){ // 6개의 조합일 경우 출력하고 함수를 종료\n            bw.write(num+\"\\n\");\n            return;\n        }\n        for(int i=index;i\u003cn;i++){ // 현재 인덱스 개수에서 입력 받은 개수-1까지 반복\n            int next = q.poll(); // 큐에서 다음 숫자를 하나 꺼냄\n            if(lastNUM\u003cnext){ // 마지막 숫자보다 다음 숫자가 클 경우 조합 함수를 실행 (오름차순 유지)\n                permutation(num+(index==0?\"\":\" \")+next,next,index+1);\n            }\n            q.add(next); // 사용한 숫자는 다시 큐의 뒤쪽에 넣어서 재사용할 수 있게 만듦\n        }\n    }\n}\n```\n"])</script><script>self.__next_f.push([1,"2a:T6d7,\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/5692)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/5692\"\u003ehttps://www.acmicpc.net/problem/5692\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 10진법이 123이 1*10^2+ 2*10^1 + 3\\*10^3이 듯 한 글자씩 떼서 각 팩토리얼 자리 값을 곱해서 더해준다.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\n\n/**\n * 팩토리얼 진법 문제 해결\n * 팩토리얼 진법 수를 10진법으로 변환하는 문제\n * 각 자리수에 해당하는 팩토리얼 값을 곱하여 합산\n */\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        // 팩토리얼 값들을 미리 계산 (0! = 1, 1! = 1, 2! = 2, ...)\n        int[] ar = new int[10];\n        for (int i = 0; i \u003c 10; i++) {\n            ar[i] = i \u003c 2 ? 1 : ar[i - 1] * i;\n        }\n\n        while (true) {\n            int n = Integer.parseInt(br.readLine()), result = 0;\n            if (n == 0)\n                break;\n            \n            // 각 자리수를 오른쪽부터 (낮은 자리부터) 확인\n            // 1! 자리, 2! 자리, 3! 자리... 순서로 계산\n            for (int i = 1; n \u003e 0; i++, n /= 10) {\n                int temp = n % 10; // 현재 자리수\n                result += ar[i] * temp; // 팩토리얼 값과 곱하여 합산\n            }\n            bw.write(result + \"\\n\");\n        }\n        bw.flush();\n    }\n}\n```\n2b:T18d9,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/4949)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/4949\"\u003ehttps://www.acmicpc.net/problem/4949\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 소괄호와 대괄호가 대칭적으로 들어있는가에 대한 문제다.\n- 처음 풀이는 스택에 ([을 넣고 )]이 나올때 스택의 마지막 값과 대칭하는지, 스택이 0보다 작은데 )]이 나오는게 아닌지 조건을 줘서 풀었다.\n\n---\n\n```java\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Stack;\n\n/**\n * 균형잡힌 세상 문제 해결 (방법 1 - Stack 사용)\n * 소괄호와 대괄호가 대칭적으로 들어있는지 확인하는 문제\n * 스택을 사용하여 괄호의 짝을 확인\n */\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        // 입력은 한번 먼저 받고 시작\n        String input = br.readLine();\n        Stack\u003cCharacter\u003e stack = null;\n        while (true) {\n            // 결과값 제어를 위한 flag, true면 yes를 false면 no를 출력하게 만듦\n            boolean flag = true;\n            stack = new Stack\u003cCharacter\u003e();\n            // 빠른 탐색을 위해 char[]로 변경하여 반복\n            for (char c : input.toCharArray()) {\n                // stack에 여는 괄호만 넣음\n                if (\"([\".contains(c + \"\")) {\n                    stack.push(c);\n\n                // 닫힌 괄호가 나왔을 때 스택의 마지막 값과 비교하여 맞지 않을 경우 또는\n                // stack이 비어있는데 닫힌 괄호가 나온 경우 flag에 false를 넣음\n                } else if (\")]\".contains(c + \"\")) {\n                    if (stack.isEmpty()) {\n                        flag = false;\n                        break;\n                    }\n                    char last = stack.pop();\n                    // 괄호의 짝이 맞지 않으면 false\n                    if ((last == '(' \u0026\u0026 c == ']') || (last == '[' \u0026\u0026 c == ')')) {\n                        flag = false;\n                        break;\n                    }\n                }\n            }\n            // 반복문이 끝났지만 stack에 무언가 남아있다면 짝이 맞지 않으므로 flag에 false 대입\n            if (!stack.isEmpty())\n                flag = false;\n            bw.write(flag ? \"yes\" : \"no\");\n            input = br.readLine();\n\n            if (input.equals(\".\"))\n                break;\n            bw.write(\"\\n\");\n        }\n        bw.flush();\n    }\n}\n\n```\n\n---\n\n- 훨씬 메모리와 속도에서 좋은 풀이가 있길래 따라해봤다.\n- 아스키 코드에서 '(' 와 ')'는 1차이가 나고 '[' 와 ']'는 2차이가 난다\n- 근데 결과는 별 차이가 안났다.\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\n\n/**\n * 균형잡힌 세상 문제 해결 (방법 2 - String 사용)\n * 아스키 코드를 이용: '('와 ')'는 1 차이, '['와 ']'는 2 차이\n */\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        while (true) {\n            String input = br.readLine();\n            char[] ar = input.toCharArray();\n            if (ar.length == 1 \u0026\u0026 ar[0] == '.')\n                break;\n            String stack = \"\"; // 스택 대신 String 사용\n            for (char c : ar) {\n                if (\"()[]\".contains(c + \"\")) {\n                    // 아스키 코드 차이를 이용: '('와 ')'는 1 차이, '['와 ']'는 2 차이\n                    // 짝이 맞으면 스택에서 제거\n                    if (stack.length() != 0 \u0026\u0026 (c - stack.charAt(stack.length() - 1) == 2\n                            || c - stack.charAt(stack.length() - 1) == 1)) {\n                        stack = stack.substring(0, stack.length() - 1);\n                    } else {\n                        stack += c; // 짝이 맞지 않으면 스택에 추가\n                    }\n                }\n            }\n            bw.write((stack.length() == 0 ? \"yes\" : \"no\") + \"\\n\");\n        }\n        bw.flush();\n    }\n}\n```\n\n---\n\n- 결국 \u003ca href='https://www.acmicpc.net/source/27698325'\u003e참조한 코드\u003c/a\u003e는 char[]를 사용했다.\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\n/**\n * 균형잡힌 세상 문제 해결 (방법 3 - char 배열 사용, 최적화)\n * char 배열을 직접 사용하여 스택을 구현\n * 아스키 코드 차이를 이용하여 괄호 짝 확인\n */\npublic class Main {\n\n    static char[] bracket = {'[', '(', ')', ']'}; // 괄호 배열\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder sb = new StringBuilder();\n\n        while(true){\n            String origin = br.readLine();\n            char[] arr = origin.toCharArray();\n\n            if(arr[0] == '.') break;\n\n            int top = -1; // 스택의 top 인덱스\n            char[] stack = new char[100]; // 스택 배열\n\n            for(char c:arr)\n                for(int a=0; a\u003c4; a++)\n                    if(c == bracket[a]) {\n                        // 아스키 코드 차이를 이용: '('와 ')'는 1 차이, '['와 ']'는 2 차이\n                        // 짝이 맞으면 스택에서 제거 (top 감소)\n                        if (top != -1 \u0026\u0026 (c - stack[top] == 2 || c - stack[top] == 1))\n                            --top;\n                        else\n                            stack[++top] = c; // 짝이 맞지 않으면 스택에 추가\n                    }\n\n            // top이 -1이면 모든 괄호가 짝이 맞음\n            sb.append(top == -1? \"yes\":\"no\").append('\\n');\n        }\n        System.out.println(sb);\n    }\n}\n\n```\n"])</script><script>self.__next_f.push([1,"2c:T870,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/2869)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/2869\"\u003ehttps://www.acmicpc.net/problem/2869\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 아침에 a만큼 올라가고(+) 잘때 b만큼 미끄러지는(-) 상황에 v만큼 올라가는데 얼마나 걸리느냐 묻는 문제다.\n- 올라간 위치가 v인 날이므로 앞으로 가야하는 거리(v)에서 하루동안 움직이는 거리(a-b)를 나눈다.\n- 하지만 v/(a-b)만 계산할 경우 오전 동안 올라갔건 a가 빠져야하므로 v-a를 해준다.\n- 그리고 나눈 값에 나머지가 존재할 경우 나머지 거리도 올라가야 하므로 1을 더해준다(나는 그냥 올림을 했다).\n- 그리고 0일부터 시작했지만 세기는 1일부터 세므로 1을 더해준다.\n\n---\n\n```java\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\n\n/**\n * 달팽이는 올라가고 싶다 문제 해결\n * 아침에 a만큼 올라가고 밤에 b만큼 미끄러질 때, v 높이에 도달하는데 걸리는 일수를 구하는 문제\n * 수학 공식을 사용하여 계산\n */\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        String[] input = br.readLine().split(\" \");\n        double a = Integer.parseInt(input[0]), b = Integer.parseInt(input[1]), v = Integer.parseInt(input[2]); // a: 올라가는 높이, b: 미끄러지는 높이, v: 목표 높이\n        \n        // 공식: (v - a) / (a - b) + 1\n        // v-a: 마지막 날 아침에 올라가기 전까지 가야 하는 거리\n        // (a-b): 하루에 실제로 올라가는 거리\n        // +1: 마지막 날(아침에 올라가는 날)과 0일부터 시작하므로 1일 더함\n        int r = (int) (Math.ceil((v - a) / (a - b)) + 1);\n        bw.write(r + \"\");\n        bw.flush();\n    }\n}\n\n```\n"])</script><script>self.__next_f.push([1,"2d:Tb23,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/2805)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/2805\"\u003ehttps://www.acmicpc.net/problem/2805\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 최대한 필요한 만큼만 가져가도록 절단기 높이를 가장 높게 잡아줘야한다.\n- 높이의 최소는 0 최대는 나무 중 가장 높은 나무의 높이를 넣는다.\n- 최소 최대의 중간 값으로 잘라주고 자를 때 음수는 합하지 않는다.\n- 그렇게 구해진 높이는 결과에 담고 구해진 높이가 기존 높이보다 낮으면 넣지 않는다.\n\n---\n\n```java\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Arrays;\n\n/**\n * 나무 자르기 문제 해결\n * 필요한 만큼의 나무를 가져가기 위한 최대 절단 높이를 구하는 문제\n * 이분 탐색을 사용하여 최적의 높이를 찾음\n */\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        String[] input = br.readLine().split(\" \");\n        int n = Integer.parseInt(input[0]); // 나무 개수\n        long m = Integer.parseInt(input[1]); // 필요한 나무 길이\n        long max = 0; // 가장 높은 나무의 높이\n        long[] ar = new long[n];\n        input = br.readLine().split(\" \");\n        \n        // 나무 높이 입력 및 최대 높이 찾기\n        for (int i = 0; i \u003c n; i++) {\n            long num = Long.parseLong(input[i]);\n            ar[i] = num;\n            if (num \u003e max)\n                max = num;\n        }\n\n        long sum = 0; // 잘린 나무의 총 길이\n        long min = 0, mid = 0, answer = -1; // min: 최소 높이, mid: 중간 높이, answer: 최종 답\n        \n        // 이분 탐색\n        while (min \u003c= max) {\n            sum = 0;\n            mid = (max + min) / 2; // 중간 높이\n            \n            // 각 나무를 mid 높이로 자를 때 얻을 수 있는 나무 길이 계산\n            for (long num : ar) {\n                sum += num - mid \u003e 0 ? num - mid : 0; // 음수는 합하지 않음\n            }\n\n            // 필요한 나무 길이 이상을 얻을 수 있으면 높이를 더 높일 수 있음\n            if (sum \u003e= m) {\n                answer = mid \u003e answer ? mid : answer; // 더 높은 높이로 업데이트\n                min = mid + 1;\n            } else {\n                // 필요한 나무 길이보다 적으면 높이를 낮춰야 함\n                max = mid - 1;\n            }\n        }\n        bw.write(answer+\"\");\n        bw.flush();\n    }\n}\n\n```\n"])</script><script>self.__next_f.push([1,"2e:T808,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/2775)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/2775\"\u003ehttps://www.acmicpc.net/problem/2775\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 14 입력 범위 끝이니 배열로 미리 만들어두면 편하다.\n- 각층 각호에 아랫층 같은호(ar[i-1][j])와 같은층 앞호(ar[i][j-1])을 합치면 현재 살아야하는 인원수가 나온다.\n- 맨 밑층은 밑이 없으니 1.\n- 0호는 층과 같다.\n\n---\n\n```java\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\n\n/**\n * 부녀회장이 될테야 문제 해결\n * 아파트의 각 층, 각 호에 사는 사람 수를 구하는 문제\n * 다이나믹 프로그래밍을 사용하여 미리 계산\n * 각 층 각 호 = 아랫층 같은 호 + 같은 층 앞 호\n */\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        int[][] ar = new int[15][15]; // ar[층][호] = 사람 수\n\n        // 초기값 설정\n        for (int i = 0; i \u003c 15; i++) {\n            ar[i][1] = 1; // 각 층의 1호는 1명\n            ar[0][i] = i; // 0층의 i호는 i명\n        }\n        \n        // 각 층, 각 호의 사람 수 계산\n        for (int i = 1; i \u003c 15; i++) {\n            for (int j = 2; j \u003c 15; j++) {\n                // 각 층 각 호 = 아랫층 같은 호 + 같은 층 앞 호\n                ar[i][j] = ar[i - 1][j] + ar[i][j - 1];\n            }\n        }\n        \n        int t = Integer.parseInt(br.readLine()); // 테스트 케이스 개수\n        for (int i = 0; i \u003c t; i++) {\n            int k = Integer.parseInt(br.readLine()), n = Integer.parseInt(br.readLine()); // k: 층, n: 호\n            bw.write(ar[k][n] + \"\\n\");\n        }\n\n        bw.flush();\n    }\n}\n\n```\n"])</script><script>self.__next_f.push([1,"2f:T5e7,\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/2292)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/2292\"\u003ehttps://www.acmicpc.net/problem/2292\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 가운데 1개에서 7,19,37,61...\n- 증가량이 6,12,18,24.... 6의 배수이다\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\n\n/**\n * 벌집 문제 해결\n * 벌집의 중심에서 n번 방까지 최소 거리를 구하는 문제\n * 각 층의 방 개수가 6의 배수로 증가하는 패턴을 이용\n */\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        int n = Integer.parseInt(br.readLine()); // 목표 방 번호\n\n        // 벌집 구조: 1 -\u003e 7(6개) -\u003e 19(12개) -\u003e 37(18개) -\u003e 61(24개)...\n        // 증가량: 6, 12, 18, 24... (6의 배수)\n        // 1 6 12 18 24\n\n        int count = 1, d = 0; // count: 현재까지의 방 개수, d: 거리\n        for (int i = 0; count \u003c n; i++) {\n            count += (i * 6); // 각 층마다 6의 배수만큼 방이 증가\n            d = i;\n        }\n\n        // 거리는 층수 + 1 (0층부터 시작하므로)\n        bw.write((d + 1) + \"\\n\");\n\n        bw.flush();\n    }\n}\n```\n30:Tace,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/2108)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/2108\"\u003ehttps://www.acmicpc.net/problem/2108\u003c/a\u003e\u003c/div\u003e\n\n---\n\n\u003e 구해야하는 값이 4개(산술평균,중앙값,최빈값,범위)이다\n\n- 산술평균 : 전체합을 갯수로 나눔\n- 중앙값 : 주어진 값들을 정렬하여 가운데 위치하는 값, 카운트를 n/2번 한다.\n- 최빈값 : 입력할때 최대 카운트를 찾고 그 값과 같은 값을 2번 이하로 찾는다.\n- 범위 : 최댓값에서 최솟값을 뺀다.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\n\n/**\n * 통계학 문제 해결\n * 산술평균, 중앙값, 최빈값, 범위를 구하는 문제\n * 카운팅 배열을 사용하여 효율적으로 계산\n */\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        int n = Integer.parseInt(br.readLine()), sum = 0, min = 4000, max = -4000, max_count = 0, mode = 0, mid = 0;\n        int[] ar = new int[8001]; // -4000 ~ 4000 범위를 0 ~ 8000으로 매핑\n        \n        // 숫자 입력 및 통계 계산\n        for (int i = 0; i \u003c n; i++) {\n            int num = Integer.parseInt(br.readLine());\n            ar[num + 4000]++; // 카운팅 (음수를 양수로 변환)\n            sum += num; // 합계\n            if (min \u003e num)\n                min = num; // 최솟값\n            if (max \u003c num)\n                max = num; // 최댓값\n            if (max_count \u003c ar[num + 4000])\n                max_count = ar[num + 4000]; // 최빈값의 개수\n        }\n\n        // 중앙값과 최빈값 계산\n        for (int i = 0, count = 0, mode_count = 0; i \u003c 8001; i++) {\n            if (ar[i] \u003e 0) {\n                // 중앙값: n/2번째 값\n                if (count \u003c (n + 1) / 2) {\n                    count += ar[i];\n                    mid = i - 4000; // 원래 값으로 변환\n                }\n\n                // 최빈값: 가장 많이 나타난 값 (같은 개수가 여러 개면 두 번째로 작은 값)\n                if (ar[i] == max_count \u0026\u0026 mode_count \u003c 2) {\n                    mode = i - 4000; // 원래 값으로 변환\n                    mode_count++;\n                }\n            }\n        }\n\n        // 산술평균, 중앙값, 최빈값, 범위 출력\n        bw.write((int) Math.round((double) sum / n) + \"\\n\" + mid + \"\\n\" + mode + \"\\n\" + (max - min));\n        bw.flush();\n    }\n}\n```\n"])</script><script>self.__next_f.push([1,"31:Te6a,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1978)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/1978\"\u003ehttps://www.acmicpc.net/problem/1978\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 1과 자기 자신 외에 나눠지지 않는 소수를 찾는 문제이다.\n- 처음 생각한 코드는 2부터 주어진 수의 제곱근까지 반복시켜 소수를 판별했다.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n/**\n * 소수 찾기 문제 해결 (방법 1)\n * 각 수를 제곱근까지 나누어 소수인지 판별하는 방법\n */\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine()), count = 0; // 숫자 개수, 소수 개수\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        for (int i = 0; i \u003c n; i++) {\n            int num = Integer.parseInt(st.nextToken());\n            if (num == 1) // 1은 소수가 아니므로 건너뜀\n                continue;\n            \n            boolean flag = true; // 소수 여부 플래그\n            // 2부터 제곱근까지 나누어 떨어지는지 확인\n            // 제곱근까지만 확인하면 충분 (약수는 대칭적이므로)\n            for (int j = 2; j \u003c= Math.sqrt(num); j++) {\n                if (num % j == 0) {\n                    flag = false; // 나누어 떨어지면 소수가 아님\n                    break;\n                }\n            }\n            if (flag)\n                count++; // 소수이면 개수 증가\n        }\n        System.out.println(count);\n    }\n}\n```\n\n---\n\n- 하지만 걸린 시간과 메로리가 더 짧은 방법이 있었다.\n- 최대 1000까지 입력이므로 불린형 배열에 true false로 소수 판별을 미리 만들어 놓고 인덱스로 찾아가서 true면 출력.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.StringTokenizer;\n\n/**\n * 소수 찾기 문제 해결 (방법 2 - 에라토스테네스의 체)\n * 최대 1000까지이므로 에라토스테네스의 체를 사용하여 미리 소수를 계산\n * 더 빠르고 메모리 효율적인 방법\n */\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        \n        // 입력된 숫자들을 표시할 배열 (true면 입력된 숫자)\n        boolean[] ar = new boolean[1001];\n        int n = Integer.parseInt(br.readLine());\n        int count = 0;\n\n        StringTokenizer st = new StringTokenizer(br.readLine());\n\n        // 입력된 숫자들을 배열에 표시\n        for (int i = 0; i \u003c n; i++) {\n            ar[Integer.parseInt(st.nextToken())] = true;\n        }\n\n        // 에라토스테네스의 체: 2부터 1000까지 순회\n        for (int i = 2; i \u003c= 1000; i++) {\n            if (ar[i]) // 입력된 숫자이면 소수 개수 증가\n                count++;\n            \n            // i의 배수들을 모두 제거 (소수가 아님을 표시)\n            for (int j = 2;; j++) {\n                if (i * j \u003e 1000)\n                    break;\n                ar[i * j] = false; // i의 배수는 소수가 아님\n            }\n        }\n        bw.write(count + \"\");\n        bw.flush();\n    }\n}\n```\n"])</script><script>self.__next_f.push([1,"32:T76c,\n[![프로그래머스](https://file.newswire.co.kr/data/datafile2/thumb_640/2021/06/1993996598_20210610150326_5364622170.jpg)](https://programmers.co.kr/learn/courses/30/lessons/43165)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://programmers.co.kr/learn/courses/30/lessons/43165\"\u003ehttps://programmers.co.kr/learn/courses/30/lessons/43165\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 깊이 우선 탐색을 이용하여 파고 내려가면서 결과를 도출하게 만든다.\n- 첫번째 값부터 +,- 로 갈라져 내려가게 만든다.\n- 덧셈이 먼저 나오고 그 다음 +,-로 가른 다음 다시 +으로 인덱스만큼 반복.\n- 반복이 끝날때 목표값과 같은지 확인.\n\n---\n\n```java\n/**\n * 타겟 넘버 문제 해결\n * 숫자 배열에 + 또는 -를 붙여서 타겟 넘버를 만드는 방법의 개수를 구하는 문제\n * DFS를 사용하여 모든 경우의 수를 탐색\n */\nclass Solution {\n    int answer = 0; // 타겟 넘버를 만드는 방법의 개수\n\n    public int solution(int[] numbers, int target) {\n        // DFS 시작: 현재 합 0, 인덱스 0부터 시작\n        dfs(numbers, target, 0, 0);\n        return answer;\n    }\n\n    /**\n     * DFS를 사용하여 모든 경우의 수를 탐색\n     * @param numbers: 숫자 배열\n     * @param target: 목표 값\n     * @param sum: 현재까지의 합\n     * @param index: 현재 처리할 인덱스\n     */\n    public void dfs(int[] numbers, int target, int sum, int index) {\n        // 모든 숫자를 처리했으면\n        if (index \u003e= numbers.length) {\n            if (sum == target) // 합이 타겟과 같으면\n                answer++; // 방법 개수 증가\n            return;\n        }\n\n        // 현재 숫자를 더하는 경우\n        dfs(numbers, target, sum + numbers[index], index + 1);\n        // 현재 숫자를 빼는 경우\n        dfs(numbers, target, sum - numbers[index], index + 1);\n    }\n}\n```\n33:T936,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/2606)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/2606\"\u003ehttps://www.acmicpc.net/problem/2606\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 탐색을 해서 풀어보라고 그림으로 그려져있다.\n- 이어지는 노드를 카운트 하는 문제 같아서 DFS로 풀었다.\n- DFS에 대한 자세한 설명은 \u003ca href=\"https://devuna.tistory.com/32\"\u003e이 블로그 글\u003c/a\u003e을 추천한다.\n- count가 -1인 이유는 본인은 제외해야한다.\n\n---\n\n```java\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * 바이러스 문제 해결\n * 1번 컴퓨터와 연결된 모든 컴퓨터의 개수를 구하는 문제\n * DFS를 사용하여 연결된 모든 노드를 탐색\n */\npublic class Main {\n    static int count = -1, n, m; // count: 감염된 컴퓨터 개수 (본인 제외하므로 -1로 시작)\n    static int[][] ar; // 인접 행렬\n    static boolean[] visit; // 방문 여부\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        n = Integer.parseInt(br.readLine()); // 컴퓨터 개수\n        m = Integer.parseInt(br.readLine()); // 연결 개수\n        ar = new int[n + 1][n + 1];\n        visit = new boolean[n + 1];\n\n        // 연결 정보 입력 (무방향 그래프)\n        for (int i = 0; i \u003c m; i++) {\n            String[] input = br.readLine().split(\" \");\n            int x = Integer.parseInt(input[0]), y = Integer.parseInt(input[1]);\n            ar[y][x] = ar[x][y] = 1; // 양방향 연결\n        }\n\n        dfs(1); // 1번 컴퓨터부터 탐색 시작\n        System.out.println(count);\n    }\n\n    /**\n     * DFS를 사용하여 연결된 모든 컴퓨터를 탐색\n     * @param v: 현재 탐색할 컴퓨터 번호\n     */\n    public static void dfs(int v) {\n        count++; // 감염된 컴퓨터 개수 증가\n        visit[v] = true; // 방문 표시\n        \n        // 연결된 모든 컴퓨터 탐색\n        for (int i = 1; i \u003c= n; i++) {\n            if (visit[i] || ar[v][i] == 0) { // 이미 방문했거나 연결되지 않았으면 건너뜀\n                continue;\n            }\n            dfs(i); // 재귀적으로 탐색\n        }\n    }\n}\n\n```\n"])</script><script>self.__next_f.push([1,"34:Td05,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1260)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/1260\"\u003ehttps://www.acmicpc.net/problem/1260\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 깊이 우선 탐색(DFS)과 너비 우선 탐색(BFS)을 구현하는 문제이다.\n- 깊이 우선 탐색은 연결된 노드가 없을때까지 내려가면서 탐색, 너비 우선 탐색은 직접 연결된 노드들을 다 훑고 내려가는 탐색 방식이다.\n- 자세한 설명은 \u003ca href=\"https://devuna.tistory.com/32\"\u003e이 블로그 글\u003c/a\u003e을 추천한다.\n\n---\n\n```java\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\n/**\n * DFS와 BFS 문제 해결\n * 그래프를 깊이 우선 탐색(DFS)과 너비 우선 탐색(BFS)으로 탐색하는 문제\n */\npublic class Main {\n    static boolean[] visit; // 방문 여부 배열\n    static int n, m, v; // n: 정점 개수, m: 간선 개수, v: 시작 정점\n    static int[][] ar; // 인접 행렬\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] input = br.readLine().split(\" \");\n        n = Integer.parseInt(input[0]);\n        m = Integer.parseInt(input[1]);\n        v = Integer.parseInt(input[2]);\n        ar = new int[1001][1001];\n        visit = new boolean[1001];\n\n        // 간선 정보 입력 (무방향 그래프)\n        for (int i = 0; i \u003c m; i++) {\n            input = br.readLine().split(\" \");\n            int x = Integer.parseInt(input[0]), y = Integer.parseInt(input[1]);\n            ar[y][x] = 1;\n            ar[x][y] = 1; // 무방향이므로 양방향으로 연결\n        }\n\n        // DFS 수행\n        new Main().dfs(v);\n        System.out.println();\n        // BFS 수행\n        new Main().bfs(v);\n    }\n\n    /**\n     * 깊이 우선 탐색 (DFS)\n     * 연결된 노드를 끝까지 탐색한 후 돌아옴\n     * @param v: 현재 탐색할 정점\n     */\n    public void dfs(int v) {\n        System.out.print(v + \" \");\n        visit[v] = true; // 방문 표시\n        \n        // 작은 번호부터 탐색\n        for (int i = 1; i \u003c= n; i++) {\n            if (visit[i] || ar[v][i] == 0) // 이미 방문했거나 연결되지 않았으면 건너뜀\n                continue;\n            dfs(i); // 재귀적으로 탐색\n        }\n    }\n\n    /**\n     * 너비 우선 탐색 (BFS)\n     * 같은 레벨의 노드를 모두 탐색한 후 다음 레벨로 이동\n     * @param v: 시작 정점\n     */\n    public void bfs(int v) {\n        Queue\u003cInteger\u003e q = new LinkedList\u003cInteger\u003e();\n        q.add(v);\n        visit[v] = false; // DFS에서 true로 설정했으므로 false로 변경 (재사용)\n\n        while (!q.isEmpty()) {\n            v = q.peek();\n            System.out.print(q.peek() + \" \");\n            q.poll();\n            \n            // 연결된 모든 노드를 큐에 추가\n            for (int i = 1; i \u003c= n; i++) {\n                if (!visit[i] || ar[v][i] == 0) // 이미 방문했거나 연결되지 않았으면 건너뜀\n                    continue;\n                q.add(i);\n                visit[i] = false; // 방문 표시\n            }\n        }\n    }\n}\n\n```\n"])</script><script>self.__next_f.push([1,"35:T1140,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1874)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/1874\"\u003ehttps://www.acmicpc.net/problem/1874\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 1부터 N까지 수열이 쌓여 있고 거기서 하나씩 넣고 꺼내는 방식이다.\n- 예제에 따라 1부터 8까지 있다고 할때 처음 모양은 이러하다.\n\n  | input | stack |\n  | ----- | :---: |\n  | 1     |       |\n  | 2     |       |\n  | 3     |       |\n  | 4     |       |\n  | 5     |       |\n  | 6     |       |\n  | 7     |       |\n  | 8     |       |\n\n- 처음 꺼내야하는 값이 4이므로 1부터 4까지를 stack에 넣고 +를 출력해줄때 상황\n\n  | input | stack |\n  | ----- | :---: |\n  |       |       |\n  |       |       |\n  |       |       |\n  |       |       |\n  | 5     |   4   |\n  | 6     |   3   |\n  | 7     |   2   |\n  | 8     |   1   |\n\n    \u003ch3\u003eoutput: + + + +\u003c/h3\u003e\n\n- 그리고 4를 출력에 넣고 -를 출력한다.\n\n  | input | stack |\n  | ----- | :---: |\n  |       |       |\n  |       |       |\n  |       |       |\n  |       |       |\n  | 5     |       |\n  | 6     |   3   |\n  | 7     |   2   |\n  | 8     |   1   |\n\n    \u003ch3\u003eoutput: + + + + -\u003c/h3\u003e\n\n- 그 다음 스택의 맨위의 값이 요구는 숫자 3과 같으므로 꺼낸다.\n\n  | input | stack |\n  | ----- | :---: |\n  |       |       |\n  |       |       |\n  |       |       |\n  |       |       |\n  | 5     |       |\n  | 6     |       |\n  | 7     |   2   |\n  | 8     |   1   |\n\n    \u003ch3\u003eoutput: + + + + - -\u003c/h3\u003e\n\n- 다음 숫자는 6이니 6까지 숫자를 넣어준다.\n\n  | input | stack |\n  | ----- | :---: |\n  |       |       |\n  |       |       |\n  |       |       |\n  |       |   6   |\n  |       |   5   |\n  |       |   3   |\n  | 7     |   2   |\n  | 8     |   1   |\n\n    \u003ch3\u003eoutput: + + + + - - + +\u003c/h3\u003e\n\n- stack의 맨 위가 6이 되었으므로 출력\n\n  | input | stack |\n  | ----- | :---: |\n  |       |       |\n  |       |       |\n  |       |       |\n  |       |       |\n  |       |   5   |\n  |       |   3   |\n  | 7     |   2   |\n  | 8     |   1   |\n\n    \u003ch3\u003eoutput: + + + + - - + + -\u003c/h3\u003e\n\n- 위와 같은 동작을 반복한다.\n- 만약 목표값이 현재 수열의 맨 위의 값보다 작은데 같지 않은 경우는 접근할 방법이 없으므로 NO를 출력한다.\n\n---\n\n```java\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Stack;\n\n/**\n * 스택 수열 문제 해결\n * 1부터 n까지의 수를 스택에 넣고 빼서 주어진 수열을 만들 수 있는지 확인하는 문제\n * 스택을 사용하여 시뮬레이션\n */\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        int n = Integer.parseInt(br.readLine()); // 수열의 길이\n        Stack\u003cInteger\u003e stack = new Stack\u003cInteger\u003e();\n        StringBuilder sb = new StringBuilder(); // 연산 결과 저장\n\n        int num = 0; // 현재까지 스택에 넣은 최대 숫자\n        for (int i = 0; i \u003c n; i++) {\n            int goal = Integer.parseInt(br.readLine()); // 목표 숫자\n\n            // 목표가 현재 숫자보다 큰 경우: 목표까지 숫자를 스택에 넣어야 함\n            if (goal \u003e num) {\n                // num이 목표와 같아질 때까지 반복\n                while (num \u003c goal) {\n                    // num을 늘려주면서 stack에 입력\n                    num++;\n                    stack.push(num);\n                    sb.append(\"+\\n\");\n                }\n            }\n\n            // 목표가 현재 숫자와 같거나 큰 상황에 스택 최상위 값과 같지 않을 경우\n            // 아래 숫자로 접근할 수 없으므로 NO를 출력\n            else if (stack.peek() != goal) {\n                bw.write(\"NO\");\n                bw.flush();\n                return;\n            }\n\n            // 목표가 현재 숫자와 같은 경우\n            // 스택에서 맨 위의 값을 꺼내고 -를 출력\n            stack.pop();\n            sb.append(\"-\\n\");\n        }\n\n        bw.write(sb.toString());\n        bw.flush();\n\n        br.close();\n        bw.close();\n    }\n}\n```\n"])</script><script>self.__next_f.push([1,"36:T1032,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1157)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/1157\"\u003ehttps://www.acmicpc.net/problem/1157\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 첫번째 생각으로 HashMap에 넣고 Value로 정렬하기를 해보았다\n- 코드가 너무 길긴하지만 범위를 정하기 어려울때는 쓰기 좋을것 같다.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\n/**\n * 단어 공부 문제 해결 (방법 1 - HashMap 사용)\n * 가장 많이 사용된 알파벳을 찾는 문제\n * HashMap을 사용하여 각 알파벳의 개수를 세고 정렬\n */\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        char[] input = br.readLine().toCharArray();\n        HashMap\u003cCharacter, Integer\u003e map = new HashMap\u003cCharacter, Integer\u003e();\n        \n        // 각 알파벳의 개수를 HashMap에 저장 (대소문자 구분 없음)\n        for (int i = 0; i \u003c input.length; i++) {\n            char c = Character.toUpperCase(input[i]);\n            map.put(c, (map.get(c) != null ? map.get(c) + 1 : 1));\n        }\n\n        // HashMap의 엔트리를 리스트로 변환하여 값 기준으로 정렬\n        List\u003cMap.Entry\u003cCharacter, Integer\u003e\u003e entries = new ArrayList\u003c\u003e(map.entrySet());\n        Collections.sort(entries, new Comparator\u003cMap.Entry\u003cCharacter, Integer\u003e\u003e() {\n            @Override\n            public int compare(Entry\u003cCharacter, Integer\u003e o1, Entry\u003cCharacter, Integer\u003e o2) {\n                return o2.getValue() - o1.getValue(); // 내림차순 정렬\n            }\n        });\n\n        // 가장 많이 사용된 알파벳이 여러 개면 \"?\" 출력, 아니면 해당 알파벳 출력\n        bw.write((entries.size() \u003e 1 \u0026\u0026 entries.get(0).getValue().equals(entries.get(1).getValue()) ? \"?\"\n                : entries.get(0).getKey()) + \"\");\n        bw.flush();\n\n        br.close();\n        bw.close();\n    }\n}\n```\n\n---\n\n- 문제의 정석처럼 풀어지는 코드는 A~Z를 아스키코드 int형으로 배열을 맞춰서 카운트 해주는 방법\n\n---\n\n```java\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\n\n/**\n * 단어 공부 문제 해결 (방법 2 - 배열 사용, 더 효율적)\n * 가장 많이 사용된 알파벳을 찾는 문제\n * 아스키 코드를 이용하여 배열 인덱스로 직접 접근\n */\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        int[] counts = new int[26]; // A~Z까지의 개수를 저장하는 배열\n        char[] input = br.readLine().toCharArray();\n\n        // 각 알파벳의 개수를 배열에 저장\n        for (char c : input) {\n            int index = Character.toUpperCase(c) - 'A'; // A를 0으로 하는 인덱스 계산\n            counts[index]++;\n        }\n\n        // 가장 많이 사용된 알파벳 찾기\n        int max = 0;\n        char c = ' ';\n        for (int i = 0; i \u003c= 'Z' - 'A'; i++) {\n            if (max \u003c counts[i]) {\n                // 더 많이 사용된 알파벳을 찾으면 업데이트\n                c = (char) (i + 65); // 'A'는 65\n                max = counts[i];\n            } else if (max == counts[i]) {\n                // 같은 개수가 있으면 \"?\" 출력\n                c = '?';\n                break;\n            }\n        }\n\n        bw.write(c + \"\");\n\n        bw.flush();\n        bw.close();\n    }\n}\n\n```\n"])</script><script>self.__next_f.push([1,"37:Ta9c,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1654)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/1654\"\u003ehttps://www.acmicpc.net/problem/1654\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 랜선을 얼마나 자를 수 있는가에 대해 묻는 문제이다.\n- 랜선길이를 보아하니 long 써야한다.\n- 그냥 탐색을 돌리면 시간초과에 걸리니 이분 탐색을 사용한다.\n- 이분 탐색에 대한 설명은 \u003ca href=\"https://wootool.tistory.com/62\"\u003e이 블로그 글\u003c/a\u003e을 추천한다.\n- 이분 탐색에 대한 설명에 맞춰 코드를 짠다.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Arrays;\n\n/**\n * 랜선 자르기 문제 해결\n * K개의 랜선을 잘라서 N개의 랜선을 만들 때, 만들 수 있는 최대 길이를 구하는 문제\n * 이분 탐색을 사용하여 최적의 길이를 찾음\n */\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        String[] input = br.readLine().split(\" \");\n        int k = Integer.parseInt(input[0]), n = Integer.parseInt(input[1]); // k: 가지고 있는 랜선 개수, n: 필요한 랜선 개수\n        long[] ar = new long[k];\n\n        // 랜선 길이 입력\n        for (int i = 0; i \u003c k; i++) {\n            ar[i] = Long.parseLong(br.readLine());\n        }\n        br.close();\n        Arrays.sort(ar); // 정렬\n\n        long count = 0; // 만들 수 있는 랜선 개수\n        long mid = 0; // 중간값\n        long min = 1; // 최소 길이\n        long len = ar[k - 1]; // 최대 길이 (가장 긴 랜선)\n        \n        // 이분 탐색\n        while (len \u003e= min) {\n            mid = (len + min) / 2; // 중간 길이\n            count = 0;\n            \n            // 각 랜선을 mid 길이로 자를 때 만들 수 있는 개수 계산\n            for (long i : ar) {\n                count += i / mid;\n            }\n            \n            // 만들 수 있는 개수가 n 이상이면 더 긴 길이도 가능하므로 min 증가\n            if (count \u003e= n)\n                min = mid + 1;\n            // 만들 수 있는 개수가 n보다 작으면 길이를 줄여야 하므로 len 감소\n            else if (count \u003c n)\n                len = mid - 1;\n        }\n        \n        // 최종적으로 len이 최대 길이가 됨\n        bw.write(len + \"\");\n        bw.flush();\n        bw.close();\n    }\n}\n\n```\n"])</script><script>self.__next_f.push([1,"38:T624,\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1436)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/1436\"\u003ehttps://www.acmicpc.net/problem/1436\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 666이 들어가는 숫자로 제목을 만드는것이다.\n- 1666,2666,3666.....16661,....\n- 숫자를 늘려서 문자열로 바꿔 666이 들어가는지 확인하여 몇번째인지 카운트한다.\n\n---\n\n```java\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\n\n/**\n * 영화감독 숌 문제 해결\n * 666이 포함된 숫자 중 n번째 숫자를 찾는 문제\n * 브루트포스 알고리즘을 사용하여 666부터 시작하여 순차적으로 확인\n */\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        int n = Integer.parseInt(br.readLine()); // n번째 666이 포함된 숫자\n        int count = 0; // 찾은 개수\n        String result = \"\";\n        \n        // 666부터 시작하여 \"666\"이 포함된 숫자를 찾음\n        for (int i = 666; count \u003c n; i++) {\n            if ((i + \"\").contains(\"666\")) {\n                result = i + \"\";\n                count++;\n            }\n        }\n\n        bw.write(result);\n        bw.flush();\n\n        br.close();\n        bw.close();\n    }\n}\n\n\n```\n39:T837,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/10816)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/10816\"\u003ehttps://www.acmicpc.net/problem/10816\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 숫자 카드가 몇번 나왔는가 카운트 해주면 된다.\n- Map에 카드 숫자를 키로, 나온 횟수를 값으로 넣어줬다.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.HashMap;\n\n/**\n * 숫자카드 2 문제 해결\n * 각 숫자 카드가 몇 개 있는지 세는 문제\n * HashMap을 사용하여 각 숫자의 개수를 저장\n */\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        \n        // 숫자 카드를 키로, 개수를 값으로 저장하는 HashMap\n        HashMap\u003cInteger, Integer\u003e map = new HashMap\u003cInteger, Integer\u003e();\n        \n        int n = Integer.parseInt(br.readLine()); // 가지고 있는 숫자 카드 개수\n        String[] input = br.readLine().split(\" \");\n        \n        // 각 숫자 카드의 개수를 HashMap에 저장\n        for (int i = 0; i \u003c n; i++) {\n            int key = Integer.parseInt(input[i]);\n            // 이미 존재하면 개수 증가, 없으면 1로 초기화\n            map.put(key, map.get(key) == null ? 1 : map.get(key) + 1);\n        }\n\n        int m = Integer.parseInt(br.readLine()); // 찾을 숫자 카드 개수\n        input = br.readLine().split(\" \");\n        \n        // 각 숫자 카드의 개수를 출력\n        for (int i = 0; i \u003c m; i++) {\n            int key = Integer.parseInt(input[i]);\n            // HashMap에 있으면 개수 출력, 없으면 0 출력\n            bw.write((map.get(key) != null ? map.get(key) : 0) + \" \");\n        }\n        bw.flush();\n\n        br.close();\n        bw.close();\n    }\n}\n```\n"])</script><script>self.__next_f.push([1,"3a:Tea0,"])</script><script>self.__next_f.push([1,"\n[![프로그래머스](https://file.newswire.co.kr/data/datafile2/thumb_640/2021/06/1993996598_20210610150326_5364622170.jpg)](https://programmers.co.kr/learn/courses/30/lessons/42839)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://programmers.co.kr/learn/courses/30/lessons/42839\"\u003ehttps://programmers.co.kr/learn/courses/30/lessons/42839\u003c/a\u003e\u003c/div\u003e\n\n- 입력받은 문자열을 문자하나씩 조개서 배열에 넣는다.\n- 작성한 순열 생성 함수에서 한칸씩 진행한다.\n- 문자 하나를 결과물에 넣고 순열 생성을 한글자 빼고 다시 문자배열에 넣기.\n- 순열 생성 함수는 붙여야할 글자가 없을때까지 문자열을 붙여서 만든다. 단 0으로 시작하는건 제외.\n- 문자열을 숫자로 만들어서 검사용 Set에 있는지 확인한다.\n- 없다면 소수인지 확인하여 맞을 경우 count ++.\n\n```java\nimport java.util.TreeSet;\nimport java.util.ArrayList;\n\n/**\n * 소수 찾기 문제 해결\n * 주어진 숫자들로 만들 수 있는 소수의 개수를 구하는 문제\n * 순열을 생성하여 모든 숫자 조합을 만들고 소수인지 확인\n */\nclass Solution {\n    TreeSet\u003cInteger\u003e set = new TreeSet\u003cInteger\u003e(); // 중복 제거를 위한 Set\n    int count=0; // 소수 개수\n\n    public int solution(String numbers) {\n        ArrayList\u003cCharacter\u003e chars = new ArrayList\u003cCharacter\u003e();\n        ArrayList\u003cCharacter\u003e results = new ArrayList\u003cCharacter\u003e();\n\n        int num_len = numbers.length();\n        // 입력받은 문자열을 문자 하나씩 배열에 넣음\n        for(int i=0;i\u003cnum_len;i++) chars.add(numbers.charAt(i));\n\n        // 1자리부터 num_len자리까지 모든 순열 생성\n        for(int i=0;i\u003cnum_len;i++)\n            permutation(chars,results,num_len,i+1);\n\n        return count;\n    }\n\n    /**\n     * 순열 생성 함수 (백트래킹)\n     * @param chars: 사용 가능한 문자들\n     * @param result: 현재까지 선택한 문자들\n     * @param n: 남은 문자 개수\n     * @param r: 선택해야 할 문자 개수\n     */\n    private void permutation(ArrayList\u003cCharacter\u003e chars, ArrayList\u003cCharacter\u003e result, int n, int r) {\n        if (r == 0) {\n            // 0으로 시작하는 숫자는 제외\n            if (result.get(0) != '0') {\n                String str = \"\";\n                int len = result.size();\n                // 선택한 문자들을 문자열로 합침\n                for (int i = 0; i \u003c len; i++) {\n                    str += result.get(i);\n                }\n\n                int num = Integer.parseInt(str);\n                // 중복 체크: 이미 확인한 숫자는 건너뜀\n                if (!set.contains(num)) {\n                    set.add(num);\n                    // 소수인지 확인\n                    if (isPrime(num)) {\n                        count++;\n                    }\n                }\n                return;\n            }\n\n        }\n        // 백트래킹: 문자를 하나씩 선택하여 순열 생성\n        for (int i = 0; i \u003c n; i++) {\n            result.add(chars.remove(i)); // 문자 선택\n            permutation(chars, result, n - 1, r - 1); // 재귀 호출\n            chars.add(i, result.remove(result.size() - 1)); // 백트래킹: 원상복구\n        }\n    }\n\n    /**\n     * 소수 판별 함수\n     * @param num: 판별할 숫자\n     * @return: 소수이면 true, 아니면 false\n     */\n    private boolean isPrime(int num) {\n        if (num == 2)\n            return true;\n        if (num == 1 || num % 2 == 0)\n            return false;\n        // 3부터 제곱근까지 홀수만 확인\n        for (int i = 3; i \u003c= (int) Math.sqrt(num); i += 2)\n            if (num % i == 0)\n                return false;\n        return true;\n    }\n}\n```\n"])</script><script>self.__next_f.push([1,"3b:T63b,\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1697)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/1697\"\u003ehttps://www.acmicpc.net/problem/1697\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 수빈의 위치(N)에서 동생의 위치(K)로 가기 위해 몇 번 걸리는가 묻고 있다.\n- 방문 기록을 세우고 거기에 카운트를 쓴다.\n- 큐에 순서를 넣고 맨 앞을 꺼내면서 체크한다.\n\n---\n\n```python\nimport sys\n\n/**\n * 숨바꼭질 문제 해결\n * 수빈의 위치(N)에서 동생의 위치(K)로 가는 최소 시간을 구하는 문제\n * BFS를 사용하여 최단 경로 탐색\n */\n\nsys.setrecursionlimit(10000000)\n\nn,k = (int(i) for i in sys.stdin.readline().split()) # n: 수빈 위치, k: 동생 위치\nvisit = [0]*100001 # 방문 기록과 시간을 저장하는 배열\nq = [n] # BFS를 위한 큐\n\nwhile(q.count!=0):\n    pos = q.pop(0) # 현재 위치\n\n    # 동생의 위치에 도달했으면 시간 출력하고 종료\n    if(pos==k): print(visit[pos]); break\n\n    # +1 이동: 범위 내이고 방문하지 않았으면\n    if(pos+1\u003c=100000 and visit[pos+1]==0):\n        q.append(pos+1)\n        visit[pos+1] = visit[pos]+1 # 시간 증가\n\n    # -1 이동: 범위 내이고 방문하지 않았으면\n    if(pos-1\u003e=0 and visit[pos-1]==0):\n        q.append(pos-1)\n        visit[pos-1] = visit[pos]+1 # 시간 증가\n\n    # *2 이동: 범위 내이고 방문하지 않았으면\n    if(pos*2\u003c=100000 and visit[pos*2] ==0 ):\n        q.append(pos*2)\n        visit[pos*2] = visit[pos]+1 # 시간 증가\n\n```\n3c:T900,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/11866)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/11866\"\u003ehttps://www.acmicpc.net/problem/11866\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 1부터 N까지 수열을 놓고 K번째 숫자를 하나씩 빼서 출력해줘야 한다.\n- 스택에 숫자를 넣어놓고 인덱스를 K씩 더해줘서 빼낼거다.\n- 시작 인덱스는 K가 N보다 크지 않으니 K를 넣되 인덱스는 0부터 니까 1을 뺀다.\n- 그 다음 스택의 길이보다 크거나 같으면 스택의 인덱스보다 커지므로 나머지를 이용하여 빼준다.\n- 반복\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.ArrayList;\n\n/**\n * 요세푸스 문제 0 해결\n * 1부터 N까지의 수열에서 K번째 숫자를 제거하는 과정을 반복하는 문제\n * ArrayList를 사용하여 인덱스로 접근\n */\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        String[] input = br.readLine().split(\" \");\n        int n = Integer.parseInt(input[0]), k = Integer.parseInt(input[1]); // n: 사람 수, k: 제거할 간격\n        ArrayList\u003cInteger\u003e list = new ArrayList\u003cInteger\u003e();\n        \n        // 1부터 n까지 리스트에 추가\n        for (int i = 1; i \u003c= n; i++)\n            list.add(i);\n\n        bw.write(\"\u003c\");\n\n        // 시작 인덱스는 k-1 (0부터 시작하므로)\n        for (int i = k - 1; !list.isEmpty(); i += k) {\n            // 인덱스가 리스트 크기를 넘어가면 나머지 연산으로 조정\n            if (i \u003e= list.size())\n                i %= list.size();\n            \n            // 해당 인덱스의 원소를 제거하고 출력\n            bw.write(list.remove(i) + \"\");\n\n            if (!list.isEmpty())\n                bw.write(\", \");\n            i--; // 원소를 제거했으므로 인덱스 조정\n        }\n        bw.write(\"\u003e\");\n        bw.flush();\n\n        br.close();\n        bw.close();\n\n    }\n}\n\n\n```\n"])</script><script>self.__next_f.push([1,"3d:T7c7,\n[![프로그래머스](https://file.newswire.co.kr/data/datafile2/thumb_640/2021/06/1993996598_20210610150326_5364622170.jpg)](https://programmers.co.kr/learn/courses/30/lessons/42840)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://programmers.co.kr/learn/courses/30/lessons/42840\"\u003ehttps://programmers.co.kr/learn/courses/30/lessons/42840\u003c/a\u003e\u003c/div\u003e\n\n- 수포자 셋의 패턴을 배열로 바꾼다.\n- 맞은 갯수를 배열에 저장하고 제일 큰 값을 표시한다.\n- 가변 배열을 위해 ArrayList를 써서 제일 큰 값과 같은 수포자를 넣고 배열을 반환한다.\n\n```java\nimport java.util.ArrayList;\n\n/**\n * 모의고사 문제 해결\n * 세 수포자의 찍기 패턴과 정답을 비교하여 가장 많이 맞춘 사람을 찾는 문제\n */\nclass Solution {\n    public int[] solution(int[] answers) {\n        int[] counter = new int[3]; // 각 수포자가 맞춘 개수\n        // 수포자 셋의 패턴을 배열로 저장\n        int[][] pattern = { { 1, 2, 3, 4, 5 }, { 2, 1, 2, 3, 2, 4, 2, 5 }, { 3, 3, 1, 1, 2, 2, 4, 4, 5, 5 } };\n        int[] lens = { 5, 8, 10 }; // 각 패턴의 길이\n        int max = 0; // 최대 맞춘 개수\n        \n        // 각 수포자의 정답 개수 계산\n        for (int i = 0; i \u003c 3; i++) {\n            int count = 0;\n            for (int j = 0; j \u003c answers.length; j++) {\n                // 패턴이 반복되므로 나머지 연산 사용\n                if (pattern[i][(j % lens[i])] == answers[j]) {\n                    count++;\n                }\n            }\n            if (max \u003c count)\n                max = count;\n            counter[i] = count;\n        }\n        \n        // 가장 많이 맞춘 수포자들을 리스트에 추가\n        ArrayList\u003cInteger\u003e list = new ArrayList\u003cInteger\u003e();\n        for (int i = 0; i \u003c 3; i++)\n            if (counter[i] == max)\n                list.add(i + 1); // 수포자 번호는 1부터 시작\n\n        return list.stream().mapToInt(i -\u003e i).toArray();\n    }\n}\n```\n3e:Tad1,"])</script><script>self.__next_f.push([1,"\n[![프로그래머스](https://file.newswire.co.kr/data/datafile2/thumb_640/2021/06/1993996598_20210610150326_5364622170.jpg)](https://programmers.co.kr/learn/courses/30/lessons/42583)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://programmers.co.kr/learn/courses/30/lessons/42583\"\u003ehttps://programmers.co.kr/learn/courses/30/lessons/42583\u003c/a\u003e\u003c/div\u003e\n\n- 대기중인 트럭에서 한대씩 꺼낸다.\n- 다리의 현재하중(bridge_weight)를 체크하여 견딜 수 있을 경우 트럭을 올린다(bridge_weight+트럭무게,큐에 트럭삽입).\n- 견디지 못할 경우 큐에 0을 집어 넣는다.\n- 걸리는 시간에 올라가는 시간을 무게한도 만큼 1씩 더해주고 마지막 트럭이 나가는 다리의 길이 만큼의 시간을 더해준다.\n\n```java\nimport java.util.Queue;\nimport java.util.LinkedList;\n\n/**\n * 다리를 지나는 트럭 문제 해결\n * 트럭이 다리를 건너는데 걸리는 시간을 구하는 문제\n * 큐를 사용하여 다리 위의 트럭을 관리\n */\nclass Solution {\n    public int solution(int bridge_length, int weight, int[] truck_weights) {\n        // 결과 시간(time)과 현재 다리의 하중(bridge_weight)를 선언\n        int time = 0, bridge_weight = 0;\n        // 다리 위의 상황을 Queue로 선언\n        Queue\u003cInteger\u003e on_bridge = new LinkedList\u003cInteger\u003e();\n        \n        // 나가야하는 트럭 개수만큼 반복\n        for (int i = 0; i \u003c truck_weights.length;) {\n            // 현재 다리의 하중이 견딜 수 있는 무게보다 적고 아직 나가야하는 트럭이 남아있다면 반복\n            while (bridge_weight \u003c weight \u0026\u0026 i \u003c truck_weights.length) {\n                // 올라갈 때 시간 추가\n                time++;\n                // 현재 다리 하중에 트럭의 무게를 더함\n                bridge_weight += truck_weights[i];\n                // 다리 상태 큐에 트럭의 무게를 기록\n                on_bridge.add(truck_weights[i]);\n                i++;\n            }\n\n            // 위 조건에서 무게가 초과하여 while문이 끝날 경우\n            if (bridge_weight \u003e weight) {\n                // 다리 위 트럭이 나갈 때까지 기다리는 시간을 더함 (다리 길이만큼)\n                time += bridge_length;\n                // 트럭이 나갔으니 Queue를 비움\n                while (!on_bridge.isEmpty()) {\n                    bridge_weight -= on_bridge.poll();\n                }\n            }\n        }\n        // 무게는 초과하지 않았지만 다리에 남아있는 트럭이 있는 경우\n        if (!on_bridge.isEmpty())\n            // 마지막 트럭이 나가는 시간을 더해줌 (다리 길이만큼)\n            time += bridge_length;\n        return time;\n    }\n}\n```\n"])</script><script>self.__next_f.push([1,"3f:T90e,"])</script><script>self.__next_f.push([1,"\n[![프로그래머스](https://file.newswire.co.kr/data/datafile2/thumb_640/2021/06/1993996598_20210610150326_5364622170.jpg)](https://programmers.co.kr/learn/courses/30/lessons/42586)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://programmers.co.kr/learn/courses/30/lessons/42586\"\u003ehttps://programmers.co.kr/learn/courses/30/lessons/42586\u003c/a\u003e\u003c/div\u003e\n\n- 기능별로 필요한 기간을 배열로 만들어줍니다.\n- 기능별로 비교하는데 앞의 기간이 뒤의 기간보다 클경우 계속 한번에 배포해야하는 양이 커지므로 complete라는 변수를 키웁니다.\n- 그렇게 키운 complete가 뒤의 기간이 더 클 경우 break문으로 나와서 배열에 넣어줍니다.\n\n```java\nimport java.util.ArrayList;\n\n/**\n * 기능개발 문제 해결\n * 각 기능의 개발 속도에 따라 배포되는 기능의 개수를 구하는 문제\n * 앞의 기능이 완료되어야 뒤의 기능도 배포 가능\n */\nclass Solution {\n    public int[] solution(int[] progresses, int[] speeds) {\n        int[] answer = {};\n        ArrayList\u003cInteger\u003e list = new ArrayList\u003cInteger\u003e();\n        int[] ar = new int[progresses.length];\n        \n        // 각 기능이 완료되는데 필요한 일수 계산\n        for(int i=0;i\u003cprogresses.length;i++){\n            // 남은 작업량을 속도로 나눔 (나머지가 있으면 +1일)\n            ar[i]=(100-progresses[i])/speeds[i]+((100-progresses[i])%speeds[i]\u003e0?1:0);\n        }\n        \n        // 각 배포마다 배포되는 기능 개수 계산\n        for(int i=0;i\u003car.length;i++){\n            int complete=1; // 현재 기능 포함\n            // 뒤의 기능들 중 현재 기능보다 일찍 또는 같이 완료되는 것들 확인\n            for(int j=i+1;j\u003car.length;j++){\n                // 뒤의 기능이 더 늦게 완료되면 중단\n                if(ar[i]\u003car[j]){\n                    i=j-1; // 다음 배포 시작 위치\n                    break;\n                }else if(j==ar.length-1){\n                    i=j; // 마지막까지 확인\n                }\n                complete++; // 같이 배포되는 기능 개수 증가\n            }\n            list.add(complete);\n        }\n\n        answer = new int[list.size()];\n        for(int i=0;i\u003clist.size();i++)answer[i]=list.get(i);\n        return answer;\n    }\n}\n```\n"])</script><script>self.__next_f.push([1,"40:T544,\n[![프로그래머스](https://file.newswire.co.kr/data/datafile2/thumb_640/2021/06/1993996598_20210610150326_5364622170.jpg)](https://programmers.co.kr/learn/courses/30/lessons/42584)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://programmers.co.kr/learn/courses/30/lessons/42584\"\u003ehttps://programmers.co.kr/learn/courses/30/lessons/42584\u003c/a\u003e\u003c/div\u003e\n\n- 시간별로 하나씩 꺼낸다.\n- 시간이 흐를때 꺼낸 값보다 더 작은 값일 경우 answer 배열의 값을 1씩 늘려준다.\n- 더 큰값이 나올 경우 break;\n\n```java\n/**\n * 주식가격 문제 해결\n * 각 시점의 주식 가격이 떨어지지 않은 기간을 구하는 문제\n * 이중 반복문을 사용하여 각 시점부터 가격이 떨어질 때까지의 시간 계산\n */\nclass Solution {\n    public int[] solution(int[] prices) {\n        int[] answer = new int[prices.length];\n        int len = prices.length;\n        \n        // 각 시점에서 가격이 떨어지지 않은 기간 계산\n        for(int i=0;i\u003clen;i++){\n            // 현재 시점 이후의 가격들을 확인\n            for(int j=i+1;j\u003clen;j++){\n                answer[i]++; // 시간 증가\n                // 가격이 떨어지면 중단\n                if(prices[i]\u003eprices[j]){\n                    break;\n                }\n            }\n        }\n        return answer;\n    }\n}\n```\n41:T747,\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/10250)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/10250\"\u003ehttps://www.acmicpc.net/problem/10250\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 호텔을 높이로 잘라서 반복하면 끝\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\n\n/**\n * ACM 호텔 문제 해결\n * 호텔 방 번호를 구하는 문제\n * 방 배정 순서: 1층부터 H층까지 순서대로, 같은 층에서는 1호부터 W호까지\n */\npublic class Main {\n    public static void"])</script><script>self.__next_f.push([1," main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        int t = Integer.parseInt(br.readLine()); // 테스트 케이스 개수\n\n        for (int a = 0; a \u003c t; a++) {\n            // 입력: H(층 수), W(각 층의 방 수), N(N번째 손님)\n            String[] input = br.readLine().split(\" \");\n            int h = Integer.parseInt(input[0]), w = Integer.parseInt(input[1]), n = Integer.parseInt(input[2]);\n            \n            // front: 층 수 (나머지 연산으로 구함)\n            // back: 호 수 (몫 연산으로 구함)\n            int front = n % h, back = n / h;\n\n            // 방 번호 계산: YXX 형태 (Y는 층, XX는 호)\n            // n % h == 0인 경우: 마지막 층에 배정되므로 h층\n            // 그 외: n % h 층에 배정\n            // 호 수는 n % h == 0이면 back, 아니면 back + 1\n            bw.write((front == 0 ? h : front) * 100 + (front == 0 ? back : back + 1) + \"\\n\");\n            bw.flush();\n        }\n        br.close();\n        bw.close();\n    }\n}\n```\n42:T1938,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1197)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/1197\"\u003ehttps://www.acmicpc.net/problem/1197\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- '최소 스패닝 트리'에 대한 설명이 적혀있는데 잘 모르겠다.\n\n  - 검색해보니 크루스칼 알고리즘을 쓰라는데 그렇다면 크루스칼 알고리즘은 또 무엇인가?\n    ![](/media/ac1197/1.jpg)\n  - 위와 같은 노드와 노드를 잇는 가중치가 주어질때 최소값으로 정렬 후 '순환하지 않게' 모두 이어준다.\n  - 가중치 정렬표\n\n  | B-C | A-B | D-E | B-D | C-E | A-D | A-E | C-D |\n  | --- | --- | --- | --- | --- | --- | --- | --- |\n  | 1   | 3   | 3   | 4   | 4   | 5   | 7   | 8   |\n\n  - 이제 저기서 최소값부터 하나씩 이어준다.\n    ![](/media/ac1197/2.jpg)\n    이렇게 잇기 시작해서\n    ![](/media/ac1197/3.jpg)\n    하나씩 연결해주는데 저렇게 모든 점들이 연결되고 C-E도 4이긴 하지만 연결시 순환되므로 생략한다.\n    https://yabmoons.tistory.com/186를 참조했습니다.\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.stream.IntStream;\n\n/**\n * 최소 스패닝 트리 문제 해결 (방법 1)\n * 크루스칼 알고리즘을 사용하여 최소 스패닝 트리를 구함\n * Union-Find를 사용하여 사이클을 방지\n */\npublic class Main {\n    static int[] parent; // Union-Find를 위한 부모 배열\n\n    /**\n     * Union-Find: 정점의 루트를 찾는 함수 (경로 압축 적용)\n     */\n    public static int find(int x) {\n        if (parent[x] == x) {\n            return x; // 루트 노드\n        }\n        // 경로 압축: 부모를 루트로 직접 연결\n        return parent[x] = find(parent[x]);\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String[] input = reader.readLine().split(\" \");\n        int v = Integer.parseInt(input[0]), e = Integer.parseInt(input[1]); // 정점 수, 간선 수\n        ArrayList\u003cint[]\u003e ar = new ArrayList\u003cint[]\u003e(); // 간선 리스트 [시작, 끝, 가중치]\n        parent = IntStream.range(0, v + 1).toArray(); // Union-Find 초기화\n        int sum = 0; // 최소 스패닝 트리의 총 가중치\n\n        // 간선 정보 입력\n        for (int i = 0; i \u003c e; i++) {\n            input = reader.readLine().split(\" \");\n            int[] temp = new int[3];\n            for (int j = 0; j \u003c 3; j++)\n                temp[j] = Integer.parseInt(input[j]);\n            ar.add(temp);\n        }\n\n        // 간선을 가중치 기준으로 오름차순 정렬\n        ar.sort(Comparator.comparing(o -\u003e o[2]));\n\n        // 크루스칼 알고리즘: 가중치가 작은 간선부터 선택\n        for (int[] x : ar) {\n            int a = find(x[0]), b = find(x[1]); // 두 정점의 루트 찾기\n            if (a != b) { // 다른 집합에 속해있으면 (사이클이 없으면)\n                sum += x[2]; // 가중치 추가\n                parent[b] = a; // 두 집합을 합침\n            }\n        }\n\n        System.out.println(sum);\n    }\n}\n```\n\n- 일단 답은 맞췄는데 메모리가 범람했다. 메모리계의 을지문덕이 되었다.\n  ![](/media/ac1197/4.jpg)\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\nimport java.util.stream.IntStream;\n\n/**\n * 최소 스패닝 트리 문제 해결 (방법 2 - 메모리 최적화)\n * PriorityQueue를 사용하여 정렬 대신 우선순위 큐 활용\n * 커스텀 클래스를 사용하여 메모리 사용량 감소\n */\npublic class Main {\n    /**\n     * 간선을 나타내는 클래스\n     * a: 시작 정점, b: 끝 정점, c: 가중치\n     */\n    static class Node implements Comparable\u003cNode\u003e {\n        int a, b, c;\n\n        Node(int a, int b, int c) {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n\n        @Override\n        public int compareTo(Node arg0) {\n            // 가중치 기준 오름차순 정렬\n            return arg0.c \u003e= this.c ? -1 : 1;\n        }\n    }\n\n    static int[] parent; // Union-Find를 위한 부모 배열\n\n    /**\n     * Union-Find: 정점의 루트를 찾는 함수 (경로 압축 적용)\n     */\n    public static int find(int x) {\n        if (parent[x] == x) {\n            return x; // 루트 노드\n        }\n        // 경로 압축: 부모를 루트로 직접 연결\n        return parent[x] = find(parent[x]);\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer input = new StringTokenizer(reader.readLine());\n        int v = Integer.parseInt(input.nextToken()), e = Integer.parseInt(input.nextToken()); // 정점 수, 간선 수\n        PriorityQueue\u003cNode\u003e ar = new PriorityQueue\u003cNode\u003e(); // 우선순위 큐 (가중치가 작은 것부터)\n        parent = IntStream.range(0, v + 1).toArray(); // Union-Find 초기화\n        int sum = 0; // 최소 스패닝 트리의 총 가중치\n\n        // 간선 정보를 우선순위 큐에 추가\n        for (int i = 0; i \u003c e; i++) {\n            input = new StringTokenizer(reader.readLine());\n            ar.add(new Node(Integer.parseInt(input.nextToken()), Integer.parseInt(input.nextToken()),\n                    Integer.parseInt(input.nextToken())));\n        }\n        input = null;\n        reader.close();\n\n        // 크루스칼 알고리즘: 가중치가 작은 간선부터 선택\n        while (!ar.isEmpty()) {\n            Node x = ar.poll(); // 가장 가중치가 작은 간선\n            int a = find(x.a), b = find(x.b); // 두 정점의 루트 찾기\n            if (a != b) { // 다른 집합에 속해있으면 (사이클이 없으면)\n                sum += x.c; // 가중치 추가\n                parent[b] = a; // 두 집합을 합침\n            }\n        }\n\n        System.out.println(sum);\n    }\n}\n```\n\n- 커스텀 클래스로 만들어서 Comparable를 받아서 만들어주니 메모리가 많이 줄었다.\n- 정렬을 커스텀으로 하는게 메모리를 많이 먹나보다.\n  ![](/media/ac1197/5.jpg)\n"])</script><script>self.__next_f.push([1,"43:Tb80,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1149)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/1149\"\u003ehttps://www.acmicpc.net/problem/1149\u003c/a\u003e\u003c/div\u003e\n\n---\n\n\u003e i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.\n\n- 이 문장을 읽으면 순간 복잡하게 생각이 들었지만 따지고 보면 그냥 앞집의 색과 다르면 그만이다\n- 도색에 드는 비용이 들어있는 배열(ar) | 여태까지 겹치지 않고 최소값으로 도배를 해온 비용으로 나누어 배열(dp)을 만들어 채운다.\n- 최소도색비용 배열(dp)을 채울때 위에서 색을 정하고(dp[i-1][0])\n- 이전 줄(dp[i-1])의 겹치지 않는 색의 최소도배비용을 비교하여 더 작은값(dp[i-1][1] \u003c dp[i-1][2]?)과 현재 집에 선택한 색의 도색비용을 더해준다(+ar[i][0]).\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\n/**\n * RGB거리 문제 해결\n * 인접한 집은 같은 색으로 칠할 수 없을 때, 모든 집을 칠하는 최소 비용을 구하는 문제\n * 다이나믹 프로그래밍을 사용하여 각 집을 각 색으로 칠할 때의 최소 비용을 계산\n */\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(reader.readLine()); // 집의 개수\n        int[][] ar = new int[n][3], dp = new int[n][3]; // ar: 각 집의 RGB 비용, dp: 최소 비용\n\n        // 각 집의 RGB 비용 입력\n        for (int i = 0; i \u003c n; i++) {\n            ar[i] = Arrays.stream(reader.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        }\n\n        // 첫 번째 집은 그대로 초기화\n        dp[0] = ar[0];\n        \n        // 두 번째 집부터: 이전 집과 다른 색을 선택하여 최소 비용 계산\n        for (int i = 1; i \u003c n; i++) {\n            // i번째 집을 빨강(0)으로 칠할 때: 이전 집은 초록 또는 파랑 중 최소 비용 선택\n            dp[i][0] = (dp[i - 1][1] \u003c dp[i - 1][2] ? dp[i - 1][1] : dp[i - 1][2]) + ar[i][0];\n            // i번째 집을 초록(1)으로 칠할 때: 이전 집은 빨강 또는 파랑 중 최소 비용 선택\n            dp[i][1] = (dp[i - 1][0] \u003c dp[i - 1][2] ? dp[i - 1][0] : dp[i - 1][2]) + ar[i][1];\n            // i번째 집을 파랑(2)으로 칠할 때: 이전 집은 빨강 또는 초록 중 최소 비용 선택\n            dp[i][2] = (dp[i - 1][0] \u003c dp[i - 1][1] ? dp[i - 1][0] : dp[i - 1][1]) + ar[i][2];\n        }\n\n        // 마지막 집의 세 가지 색 중 최소 비용 선택\n        int min = dp[n - 1][0] \u003c dp[n - 1][1] ? dp[n - 1][0] : dp[n - 1][1];\n        System.out.println(min \u003c dp[n - 1][2] ? min : dp[n - 1][2]);\n    }\n}\n\n```\n"])</script><script>self.__next_f.push([1,"44:T62b,\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1013)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/1013\"\u003ehttps://www.acmicpc.net/problem/1013\u003c/a\u003e\u003c/div\u003e\n\n---\n\n\u003e “무한히 넓은 저 우주에 인류만이 홀로 존재한다면, 그건 정말 슬픈 일이 아닐까요”\n\n- 이걸 풀고 난 후에 나는 혼자 있고 싶어졌다.\n\n- 문제에서 표기법의 규칙에 대해 설명해준 뒤\n- (100+1+ | 01)+ 에 맞는 지 확인하여 YES와 NO를 출력하라고 했다\n\n- 정규식을 쓰면 손쉽다. 그렇다 처음엔 생각 못해서 안쉬웠다.\n\n```java\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * Contact 문제 해결\n * 주어진 문자열이 특정 패턴 (100+1+ | 01)+ 에 맞는지 확인하는 문제\n * 정규식을 사용하여 간단하게 해결\n */\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(reader.readLine()); // 테스트 케이스 개수\n\n        for (int i = 0; i \u003c n; i++) {\n            String input = reader.readLine();\n            // 정규식 패턴: (100+1+ | 01)+\n            // 100+1+: \"1\" 다음에 \"0\"이 1개 이상, 그 다음 \"1\"이 1개 이상\n            // 01: \"01\" 패턴\n            // +: 위 패턴이 1번 이상 반복\n            System.out.println(input.matches(\"(100+1+|01)+\") ? \"YES\" : \"NO\");\n        }\n    }\n}\n\n```\n45:Td85,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1008)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/1008\"\u003ehttps://www.acmicpc.net/problem/1008\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 가로 m 세로 n의 배추밭에 배추를 심고 배추 보호를 위해 순찰도는 배추흰지렁이를 밭에 풀려고 한다. 비용절감을 위해 필요한 만큼만 풀어야 한다.\n- 배추흰지렁이는 인접한 배추들로 이동할 수 있으므로 지렁이가 배추가 보이면 한마리 놓고 붙어있는 배추들을 지도에서 지워주자\n- 인접했다는 말은 배추의 위치를 2차원 좌표로 (x,y) 라고 할때\n\n  |         |         |       |\n  | ------- | ------- | ----- |\n  |         | (x,y+1) |       |\n  | (x-1,y) | (x,y)   | (x+1) |\n  |         | (x,y-1) |       |\n\n- 재귀를 이용해서 근처를 전부 탐색하고 지도 밖으로 나가거나 배추가 없을 경우 멈추는 함수를 만든다.\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\n/**\n * 유기농 배추 문제 해결\n * 배추밭에서 인접한 배추 그룹의 개수를 구하는 문제\n * DFS를 사용하여 연결된 배추들을 탐색\n */\npublic class Main {\n    static int[][] ar; // 배추밭 지도\n\n    /**\n     * DFS를 사용하여 인접한 배추들을 모두 탐색하고 제거\n     * @param x: 현재 x 좌표\n     * @param y: 현재 y 좌표\n     * @param m: 배추밭 가로 길이\n     * @param n: 배추밭 세로 길이\n     */\n    public static void finder(int x, int y, int m, int n) {\n        // 범위를 벗어나거나 배추가 없으면 종료\n        if (x \u003e= m || y \u003e= n || x \u003c 0 || y \u003c 0 || ar[y][x] == 0)\n            return;\n        \n        // 현재 위치의 배추를 제거 (방문 표시)\n        ar[y][x] = 0;\n        \n        // 상하좌우 4방향으로 재귀 탐색\n        finder(x + 1, y, m, n); // 오른쪽\n        finder(x, y + 1, m, n); // 아래\n        finder(x - 1, y, m, n); // 왼쪽\n        finder(x, y - 1, m, n); // 위\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine()); // 테스트 케이스 개수\n        \n        for (int i = 0; i \u003c n; i++) {\n            // 입력: 가로(m), 세로(n), 배추 개수(k)\n            int[] data = Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n            ar = new int[data[1]][data[0]]; // 배추밭 초기화\n            \n            // 배추 위치 입력\n            for (int j = 0; j \u003c data[2]; j++) {\n                int[] pos = Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n                ar[pos[1]][pos[0]] = 1; // 배추 위치 표시\n            }\n\n            // 연결된 배추 그룹의 개수 세기\n            int count = 0;\n            for (int y = 0; y \u003c data[1]; y++) {\n                for (int x = 0; x \u003c data[0]; x++) {\n                    if (ar[y][x] == 1) {\n                        count++; // 새로운 그룹 발견\n                        finder(x, y, data[0], data[1]); // 연결된 모든 배추 탐색 및 제거\n                    }\n                }\n            }\n            System.out.println(count); // 필요한 지렁이 개수 출력\n        }\n    }\n}\n```\n"])</script><script>self.__next_f.push([1,"46:T9bd,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1003)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/1003\"\u003ehttps://www.acmicpc.net/problem/1003\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 피보나치 함수에서 0과 1이 몇번 출력 되는지 묻는다.\n  \u003e 0과 1이 몇번 나오는 지 세보자\n\n| n   | 0이 나오는 횟수 | 1이 나오는 횟수 |\n| --- | :-------------: | :-------------: |\n| 0   |        1        |        0        |\n| 1   |        0        |        1        |\n| 2   |        1        |        1        |\n| 3   |        1        |        2        |\n| 4   |        2        |        3        |\n| 5   |        3        |        5        |\n| 6   |        5        |        8        |\n| 7   |        8        |       13        |\n| 8   |       13        |       21        |\n| 9   |       21        |       34        |\n\n- 0이 나오는 횟수는 n이 1부터, 1이 나오는 횟수 n이 0부터 수열이 시작된다.\n- 다행히 문제가 n이 40까지로 제한되어 있다.\n- 0일 경우를 예외처리하고 그 다음부터는 수열 값을 출력해주면 된다.\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * 피보나치 함수 문제 해결\n * 피보나치 함수에서 0과 1이 출력되는 횟수를 구하는 문제\n * 다이나믹 프로그래밍을 사용하여 미리 계산\n */\npublic class Main {\n\n    public static void main(String[] args) throws IOException {\n        // 피보나치 수열을 미리 계산 (n은 최대 40)\n        int[] ar = new int[41];\n        ar[0] = 0; // 피보나치(0) = 0\n        ar[1] = 1; // 피보나치(1) = 1\n        ar[2] = 1; // 피보나치(2) = 1\n\n        // 피보나치 수열 계산: F(n) = F(n-2) + F(n-1)\n        for (int i = 3; i \u003c 41; i++)\n            ar[i] = ar[i - 2] + ar[i - 1];\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String in = reader.readLine();\n        int testCases = Integer.parseInt(in);\n        \n        for (int i = 0; i \u003c testCases; i++) {\n            int n = Integer.parseInt(reader.readLine());\n            // n=0일 때: 0이 1번, 1이 0번 출력\n            // n=1일 때: 0이 0번, 1이 1번 출력\n            // n\u003e=2일 때: 0이 나오는 횟수 = ar[n-1], 1이 나오는 횟수 = ar[n]\n            System.out.println((n == 0 ? \"1 0\" : n == 1 ? \"0 1\" : ar[n - 1] + \" \" + ar[n]));\n        }\n    }\n}\n```\n"])</script><script>self.__next_f.push([1,"47:T93f,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/15649)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/15649\"\u003ehttps://www.acmicpc.net/problem/15649\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 자연수 수열을 만드는 문제다.\n- 갯수의 카운트를 올라가며 만들어놓은 배열에 넣으면서 방문목록을 체크한다.\n\n---\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.StringTokenizer;\n\n/**\n * N과 M(1) 문제 해결\n * 1부터 N까지의 자연수 중에서 중복 없이 M개를 고른 수열을 모두 구하는 문제\n * 백트래킹을 사용하여 순열을 생성\n */\nclass Main {\n    static BufferedReader br;\n    static BufferedWriter bw;\n    static int[] ar; // 현재까지 선택한 수열\n    static boolean[] visited; // 방문 여부 체크\n    static int m, n; // n: 자연수 범위, m: 선택할 개수\n\n    public static void main(String[] args) throws java.lang.Exception {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        n = Integer.parseInt(st.nextToken());\n        m = Integer.parseInt(st.nextToken());\n        ar = new int[m + 1];\n        visited = new boolean[n + 1];\n        func(0); // 백트래킹 시작\n        bw.flush();\n    }\n\n    /**\n     * 백트래킹을 사용하여 순열 생성\n     * @param cnt: 현재까지 선택한 숫자의 개수\n     */\n    public static void func(int cnt) throws IOException {\n        // m개를 모두 선택했으면 수열 출력\n        if (cnt == m) {\n            for (int i = 0; i \u003c m; i++)\n                bw.write(ar[i] + \" \");\n            bw.write(\"\\n\");\n            return;\n        }\n        \n        // 1부터 n까지의 숫자를 순회\n        for (int i = 1; i \u003c= n; i++) {\n            if (!visited[i]) { // 아직 사용하지 않은 숫자면\n                visited[i] = true; // 방문 표시\n                ar[cnt] = i; // 수열에 추가\n                func(cnt + 1); // 다음 숫자 선택\n                visited[i] = false; // 백트래킹: 방문 표시 해제\n            }\n        }\n    }\n}\n```\n"])</script><script>self.__next_f.push([1,"48:T7c0,\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/11650)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/11650\"\u003ehttps://www.acmicpc.net/problem/11650\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 간단한 정렬문제다.\n- Array.stream에서 comparing을 쓰는 것보다 클래스를 만들어서 Comparable을 쓰는게 빠르다.\n\n---\n\n```java\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Arrays;\n\n/**\n * 좌표 정렬하기 문제 해결\n * 좌표를 x좌표 오름차순, x좌표가 같으면 y좌표 오름차순으로 정렬\n */\n\n/**\n * 좌표를 나타내는 클래스\n */\nclass Node implements Comparable\u003cNode\u003e {\n    public int x, y; // x좌표, y좌표\n\n    public Node(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * 정렬 기준: x좌표 오름차순, x좌표가 같으면 y좌표 오름차순\n     */\n    @Override\n    public int compareTo(Node o) {\n        return this.x == o.x ? this.y - o.y : this.x - o.x;\n    }\n\n}\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        int n = Integer.parseInt(br.readLine()); // 좌표 개수\n        Node[] ar = new Node[n];\n        \n        // 좌표 입력\n        for (int i = 0; i \u003c n; i++) {\n            String[] input = br.readLine().split(\" \");\n            ar[i] = new Node(Integer.parseInt(input[0]), Integer.parseInt(input[1]));\n        }\n        \n        // 정렬 수행\n        Arrays.sort(ar);\n        \n        // 정렬된 결과 출력\n        for (Node o : ar) {\n            bw.write(o.x + \" \" + o.y + \"\\n\");\n            bw.flush();\n        }\n        br.close();\n        bw.close();\n    }\n}\n\n\n```\n49:Te0b,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1002)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/1002\"\u003ehttps://www.acmicpc.net/problem/1002\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- 백승환과 조규현에게 류재명과의 거리를 구해 류재명이 있을 수 있는 위치를 구하는 좌표를 구하라고 한다.\n- 백승환과 조규현의 위치는 좌표점으로 제공된다.\n- 두 점에서 목표까지의 거리가 나와 있고 두 점간의 거리를 구해서 가장 큰 값과 세 거리의 합(sum)에서 가장 큰 값(max)을 뺀 값을 구한다.\n- 원의 방정식을 사용할것이다.\n- 백승환과 류재명의 거리 r1 , 조규현과 류재명의 거리 r2 , 백승환과 조규현의 거리 r3 라고 할때 조건을 따라가보자\n\n  - r1과 r2가 같고 r3가 0이다 =\u003e r1과r2가 같은 위치 =\u003e 원이 완벽하게 겹쳐서 무수하게 많은 수 =\u003e -1\n\n  - r1 + r2 == r3 =\u003e r1로 그린 원과 r2로 그린 원의 중점의 거리가 r3일때 두 원은 한점에서 만나게 된다 =\u003e 1\n    ![](/media/ac1002/2.jpg)\n  - r1+r2+r3-max = max =\u003e r3로 그린 원과 r1 또는 r2로 그린 원 하나가 내접 =\u003e 1\n    ![](/media/ac1002/4.jpg)\n  - max\u003esum =\u003e 두 원의 지름보다 합의 거리가 더 기므로 원이 만나지 않음 =\u003e 0\n    ![](/media/ac1002/1.jpg)\n  - 앞의 조건을 다 피할 경우=\u003e 두 원이 두 군데에서 겹치게 된다 =\u003e 2\n    ![](/media/ac1002/3.jpg)\n\n---\n\n```java\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\n/**\n * 터렛 문제 해결\n * 두 원의 교점 개수를 구하는 문제\n * 원의 방정식을 사용하여 두 원의 위치 관계를 판단\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine()); // 테스트 케이스 개수\n        \n        for (int i = 0; i \u003c n; i++) {\n            // 입력: x1, y1, r1, x2, y2, r2\n            // (x1, y1): 첫 번째 점의 좌표, r1: 첫 번째 점에서 목표까지의 거리\n            // (x2, y2): 두 번째 점의 좌표, r2: 두 번째 점에서 목표까지의 거리\n            int[] in = Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::valueOf).toArray();\n            \n            // 두 점 사이의 거리 계산 (유클리드 거리)\n            double distance = Math.sqrt(Math.pow(in[3] - in[0], 2) + Math.pow(in[1] - in[4], 2));\n            \n            // 세 거리(r1, r2, 두 점 사이 거리) 중 최댓값\n            double max = Arrays.stream(new double[] { in[2], in[5], distance }).max().getAsDouble();\n            \n            // 세 거리의 합에서 최댓값을 뺀 값 (나머지 두 거리의 합)\n            double sum = in[2] + in[5] + distance - max;\n            \n            // 두 원의 교점 개수 판단\n            // -1: 두 원이 완전히 겹침 (무수히 많은 교점)\n            // 0: 두 원이 만나지 않음\n            // 1: 두 원이 한 점에서 만남 (외접 또는 내접)\n            // 2: 두 원이 두 점에서 만남\n            int x = (in[2] == in[5] \u0026\u0026 distance == 0) ? -1 : // 반지름이 같고 중심이 같음\n                    (distance == in[2] + in[5] || sum == max) ? 1 : // 외접 또는 내접\n                    (max \u003e sum) ? 0 : // 두 원이 만나지 않음\n                    2; // 두 원이 두 점에서 만남\n            System.out.println(x);\n        }\n    }\n}\n\n```\n"])</script><script>self.__next_f.push([1,"4a:Ta0a,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1018)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/1018\"\u003ehttps://www.acmicpc.net/problem/1018\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- M _ N 크기의 보드에서 8 _ 8의 체스판을 만드는 문제이다.\u003cbr /\u003e\n- 자칫하면 처음칸의 색에서 고정으로 생각하기 쉬우나 무슨 색으로 칠하건 횟수가 적은 경우의 수를 출력하는 것이다.\u003cbr /\u003e\n  그래서 첫칸이 W일 경우의 수와 B일 경우의 수로 나누어 카운트를 해준다.\u003cbr /\u003e\n- 카운트 할 경우\n  - 첫칸(0,0)이 W일 경우 -\u003e 행렬 숫자의 합이 짝수\u0026\u0026 B , 행렬 숫자의 합이 홀수 \u0026\u0026 W 이면 카운트1 ++\u003cbr /\u003e\n  - 첫칸(0,0)이 B일 경우 -\u003e 행렬 숫자의 합이 짝수\u0026\u0026 W , 행렬 숫자의 합이 홀수 \u0026\u0026 B 이면 카운트2 ++\n\n```python\nimport sys\n\n/**\n * 체스판 다시 칠하기 문제 해결\n * M x N 크기의 보드에서 8 x 8 체스판을 만들기 위해 다시 칠해야 하는 최소 칸 수를 구하는 문제\n * 첫 번째 칸이 W인 경우와 B인 경우를 모두 고려하여 최소값을 찾음\n */\n\nN,M=map(int,sys.stdin.readline().split()) # 보드의 세로, 가로 크기\nboard=list()\nfor _ in range(N):\n    board.append(list(sys.stdin.readline())) # 보드 입력\n\nmin = 64 # 최대 변경 횟수 (8x8 = 64)\n\n# 8x8 크기의 체스판을 만들 수 있는 모든 시작 위치 탐색\nfor r_sub in range(0,N-7): # 세로 시작 위치\n    for c_sub in range(0,M-7): # 가로 시작 위치\n        count1,count2=0,0 # 첫 칸이 W일 때와 B일 때의 변경 횟수\n        start = board[0+r_sub][0+c_sub] # 시작 칸의 색상\n        flag = bool((0+r_sub+0+c_sub)%2) # 시작 칸의 위치가 짝수인지 홀수인지\n        \n        # 8x8 영역을 순회하며 체스판 패턴과 비교\n        for row in range(0+r_sub,8+r_sub):\n            for col in range(0+c_sub,8+c_sub):\n                # 체스판 패턴: (row+col)이 짝수/홀수에 따라 색상이 결정됨\n                # 패턴과 실제 색상이 다르면 count1 증가, 같으면 count2 증가\n                if ((row+col)%2==flag) != (board[row][col]==start):\n                    count1+=1 # 첫 칸이 start 색일 때 변경 필요\n                else:\n                    count2+=1 # 첫 칸이 다른 색일 때 변경 필요\n\n        # 두 경우 중 더 작은 값으로 최소값 업데이트\n        if min\u003ecount1:min=count1\n        if min\u003ecount2:min=count2\n\nprint(min) # 최소 변경 횟수 출력\n\n```\n"])</script><script>self.__next_f.push([1,"4b:Td6c,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1158)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/1158\"\u003ehttps://www.acmicpc.net/problem/1158\u003c/a\u003e\u003c/div\u003e\n\n---\n\n- prev와 next란 배열을 서로 인덱스로 교차하며 배열을 출력한다.\n\n- n이 7이고 m이 3일 경우 처음 모양은 이러하다.\n\n|      |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |\n| :--: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |\n| prev | -1  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |\n| next |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |\n\n- prev의 1번째에는 n을 넣고 next의 n번째에는 1을 넣는다.\n\n|      |  0  |    1     |  2  |  3  |  4  |  5  |  6  |    7     |\n| :--: | :-: | :------: | :-: | :-: | :-: | :-: | :-: | :------: |\n| prev | -1  | \u003cb\u003e7\u003c/b\u003e |  1  |  2  |  3  |  4  |  5  |    6     |\n| next |  1  |    2     |  3  |  4  |  5  |  6  |  7  | \u003cb\u003e1\u003c/b\u003e |\n\n\u003cbr /\u003e\n\n- i에 next[i]를 넣으면서 탐색을 나가는데 0부터 시작하여 m번 반복한다.\u003cbr /\u003e\n  i = (next[0] =\u003e next[1] =\u003e next[2]) =\u003e3\u003cbr /\u003e\n  i = 3\u003cbr /\u003e\n\n- i 값을 출력해주고 next에 이전 값이 담긴 자리에 다음 위치의 값을 넣는다.\u003cbr /\u003e\n  next[prev[i]] = next[i];\u003cbr /\u003e\n  next[prev[3]] = next[3];\u003cbr /\u003e\n  next[2] = next[3];\u003cbr /\u003e\n\n|      |  0  |  1  |    2    |  3  |  4  |  5  |  6  |  7  |\n| :--: | :-: | :-: | :-----: | :-: | :-: | :-: | :-: | :-: |\n| prev | -1  |  7  |    1    |  2  |  3  |  4  |  5  |  6  |\n| next |  1  |  2  | \u003cb\u003e4\u003c/b\u003e |  4  |  5  |  6  |  7  |  1  |\n\n\u003cbr /\u003e\n\n- 그리고 prev 배열에는 출력된 값의 자리에 그 이전 값을 넣는다.\u003cbr /\u003e\n  prev[next[i]] = prev[i];\u003cbr /\u003e\n  prev[next[3]] = prev[3];\u003cbr /\u003e\n  prev[4] = prev[3];\u003cbr /\u003e\n\n|      |  0  |  1  |  2  |  3  |    4     |  5  |  6  |  7  |\n| :--: | :-: | :-: | :-: | :-: | :------: | :-: | :-: | :-: |\n| prev | -1  |  7  |  1  |  2  | \u003cb\u003e2\u003c/b\u003e |  4  |  5  |  6  |\n| next |  1  |  2  |  4  |  4  |    5     |  6  |  7  |  1  |\n\n\u003cbr /\u003e\n\n- 위 과정을 반복한다.\n\n- 2년전에 푼 문제인데 내가 풀었다기엔 어떻게 이렇게 푼건지 모르겠고 어디서 봤다기엔 검색을 해도 안나오고 한번에 맞췄다.\n\n---\n\n```C\n#include \u003cstdio.h\u003e\n\n/**\n * 요세푸스 문제 해결\n * 원형 연결 리스트를 배열로 구현하여 K번째 사람을 제거하는 문제\n * prev와 next 배열을 사용하여 원형 구조를 표현\n */\nint main() {\n    int n, m, i, j; // n: 사람 수, m: 제거할 간격, i: 현재 위치, j: 반복 변수\n\n    scanf(\"%d %d\", \u0026n, \u0026m);\n\tint prev[n+1], next[n+1]; // prev: 이전 노드, next: 다음 노드\n\n    // 원형 연결 리스트 초기화\n    for (i = 0; i \u003c= n;++i) {\n        prev[i] = i - 1;\n        next[i] = i + 1;\n    }\n    // 원형 구조 만들기: 첫 번째와 마지막 연결\n    prev[1] = n;\n    next[n] = 1;\n\n    printf(\"\u003c\");\n    i = 0; // 시작 위치\n    for (;--n;) { // n-1번 반복 (마지막 하나 남을 때까지)\n        // m번째 사람까지 이동\n        for (j = 0;j \u003c m;++j)\n            i = next[i];\n        printf(\"%d, \", i);\n        // i번째 노드를 리스트에서 제거\n        next[prev[i]] = next[i]; // 이전 노드의 next를 다음 노드로 연결\n        prev[next[i]] = prev[i]; // 다음 노드의 prev를 이전 노드로 연결\n    }\n    printf(\"%d\u003e\", next[i]); // 마지막 남은 사람 출력\n\n    return 0;\n}\n```\n"])</script><script>self.__next_f.push([1,"4c:T8d0,"])</script><script>self.__next_f.push([1,"\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/9095)\n\n\u003cdiv className=\"text-center\"\u003e\u003ca href=\"https://www.acmicpc.net/problem/9095\"\u003ehttps://www.acmicpc.net/problem/9095\u003c/a\u003e\u003c/div\u003e\n\n- T개 주어지는 정수 n에 대해 1,2,3의 합으로 표현하는 방법의 갯수를 세는 문제이다\n- 경우는 앞의 숫자를 고정하고 나머지 값을 가변시켜보는 방식으로 카운트하게 만들면 된다.\n\n| 정수 n | 표현 방법                                                                                         | 가지 수 |\n| ------ | ------------------------------------------------------------------------------------------------- | ------- |\n| 1      | 1                                                                                                 | 1       |\n| 2      | 2, 1+1                                                                                            | 2       |\n| 3      | 3, 2+1, 1+2, 1+1+1                                                                                | 4       |\n| 4      | 3+1, 2+2, 2+1+1, 1+3, 1+2+1, 1+1+2, 1+1+1+1                                                       | 7       |\n| 5      | 3+2, 3+1+1, 1+3+1, 1+1+3, 2+3, 2+2+1, 2+1+2, 1+2+2, 2+1+1+1, 1+2+1+1, 1+1+2+1, 1+1+1+2, 1+1+1+1+1 | 13      |\n\n- 1,2,3의 경우는 각자 값을 가지고 이상의 n은 n-1,n-2,n-3의 합과 같다.\n\n```C\n#include \u003cstdio.h\u003e\n\n/**\n * 1, 2, 3 더하기 문제 해결\n * 정수 n을 1, 2, 3의 합으로 나타내는 방법의 개수를 구하는 문제\n * 다이나믹 프로그래밍: n = (n-1) + (n-2) + (n-3)\n */\n\nint m(int in);\n\nint main(void) {\n\tint n;\n\tscanf(\"%d\",\u0026n);\n\tif(n\u003e11)return 0;\n\tfor(int i=0;i\u003cn;i++){\n\t\tint s;\n\t\tscanf(\"%d\",\u0026s);\n\t\tprintf(\"%d\\n\",m(s));\n\t}\n\treturn 0;\n}\n\n/**\n * 재귀 함수: n을 1, 2, 3의 합으로 나타내는 방법의 개수\n * @param in: 정수 n\n * @return: 방법의 개수\n */\nint m(int in){\n\t// 초기값 설정\n\tif(in==0)return 0;\n\telse if(in==1)return 1; // 1\n\telse if(in==2)return 2; // 2, 1+1\n\telse if(in==3)return 4; // 3, 2+1, 1+2, 1+1+1\n\t// n = (n-1) + (n-2) + (n-3)\n\t// n-1에 1을 더하거나, n-2에 2를 더하거나, n-3에 3을 더하는 방법\n\treturn m(in-1)+m(in-2)+m(in-3);\n}\n```\n"])</script><script>self.__next_f.push([1,"54:[]\n"])</script><script>self.__next_f.push([1,"0:[\"$\",\"$L2\",null,{\"buildId\":\"vicXI5GcatXf95Mh6ZPn7\",\"assetPrefix\":\"\",\"urlParts\":[\"\",\"posts\",\"\"],\"initialTree\":[\"\",{\"children\":[\"posts\",{\"children\":[\"__PAGE__\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"posts\",{\"children\":[\"__PAGE__\",{},[[\"$L3\",[\"$\",\"$L4\",null,{\"allPosts\":[{\"slug\":\"programmers72412\",\"title\":\"순위 검색\",\"date\":\"2021-10-07T15:13:37.121Z\",\"description\":\"프로그래머스 큐 연습문제, KAKAO BLIND RECRUITMENT\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$5\"},{\"slug\":\"ac1922\",\"title\":\"네트워크 연결\",\"date\":\"2021-07-12T12:18:37.121Z\",\"description\":\"백준 1922번 최소 스패닝 트리 그래프이론 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$6\"},{\"slug\":\"ac1939\",\"title\":\"중량제한\",\"date\":\"2021-07-07T23:55:37.121Z\",\"description\":\"백준 1939번 유니온 파인드 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$7\"},{\"slug\":\"ac1976\",\"title\":\"여행 가자\",\"date\":\"2021-07-05T01:31:37.121Z\",\"description\":\"백준 1976번 유니온 파인드 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$8\"},{\"slug\":\"ac1717\",\"title\":\"집합의 표현\",\"date\":\"2021-07-03T15:53:37.121Z\",\"description\":\"백준 1717번 유니온 파인드 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$9\"},{\"slug\":\"ac1826\",\"title\":\"연료 채우기\",\"date\":\"2021-06-30T23:29:37.121Z\",\"description\":\"백준 1827번 그리디 우선순위 큐 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$a\"},{\"slug\":\"ac11000\",\"title\":\"강의실 배정\",\"date\":\"2021-06-27T17:30:37.121Z\",\"description\":\"백준 11000번 정렬 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$b\"},{\"slug\":\"ac11286\",\"title\":\"절댓값 힙\",\"date\":\"2021-06-27T03:37:37.121Z\",\"description\":\"백준 11286번 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$c\"},{\"slug\":\"ac11279\",\"title\":\"최대 힙\",\"date\":\"2021-06-27T02:20:37.121Z\",\"description\":\"백준 11279번 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$d\"},{\"slug\":\"ac13305\",\"title\":\"주유소\",\"date\":\"2021-06-21T20:11:37.121Z\",\"description\":\"백준 13305번 그리디 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$e\"},{\"slug\":\"ac1931\",\"title\":\"회의실 배정\",\"date\":\"2021-06-21T16:12:37.121Z\",\"description\":\"백준 1931번 그리디 정렬 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$f\"},{\"slug\":\"ac13460\",\"title\":\"구슬 탈출 2\",\"date\":\"2021-06-18T15:16:37.121Z\",\"description\":\"백준 13460번 그래프이론 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$10\"},{\"slug\":\"ac7562\",\"title\":\"나이트의 이동\",\"date\":\"2021-06-14T10:18:37.121Z\",\"description\":\"백준 7562번 그래프 탐색 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$11\"},{\"slug\":\"ac11724\",\"title\":\"연결 요소의 개수\",\"date\":\"2021-06-06T21:08:37.121Z\",\"description\":\"백준 11724번 그래프 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$12\"},{\"slug\":\"ac14888\",\"title\":\"연산자 끼워넣기\",\"date\":\"2021-05-31T18:32:37.121Z\",\"description\":\"백준 14888번 브루트포스 백트레킹 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$13\"},{\"slug\":\"ac5430\",\"title\":\"AC\",\"date\":\"2021-05-31T00:54:37.121Z\",\"description\":\"백준 5430번 파싱 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$14\"},{\"slug\":\"programmers42585\",\"title\":\"N으로 표현\",\"date\":\"2021-05-30T01:46:37.121Z\",\"description\":\"프로그래머스 큐 연습문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$15\"},{\"slug\":\"programmers43105\",\"title\":\"정수 삼각형\",\"date\":\"2021-05-27T02:20:37.121Z\",\"description\":\"프로그래머스 큐 연습문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$16\"},{\"slug\":\"ac11729\",\"title\":\"하노이 탑 이동 순서\",\"date\":\"2021-05-24T02:43:37.121Z\",\"description\":\"백준 11729번 재귀 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$17\"},{\"slug\":\"ac2579\",\"title\":\"계단오르기\",\"date\":\"2021-05-15T00:06:37.121Z\",\"description\":\"백준 2579번 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$18\"},{\"slug\":\"programmers60058\",\"title\":\"괄호 변환\",\"date\":\"2021-05-13T15:13:37.121Z\",\"description\":\"프로그래머스 큐 연습문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$19\"},{\"slug\":\"ac1927\",\"title\":\"최소 힙\",\"date\":\"2021-05-12T12:56:37.121Z\",\"description\":\"백준 1927번 우선순위 큐 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$1a\"},{\"slug\":\"ac12015\",\"title\":\"가장 긴 증가하는 부분 수열\",\"date\":\"2021-05-12T02:43:37.121Z\",\"description\":\"백준 12015번 이분탐색 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$1b\"},{\"slug\":\"ac10872\",\"title\":\"팩토리얼\",\"date\":\"2021-05-03T23:59:37.121Z\",\"description\":\"백준 10872번 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"\\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/10872)\\n\\n\u003cdiv className=\\\"text-center\\\"\u003e\u003ca href=\\\"https://www.acmicpc.net/problem/10872\\\"\u003ehttps://www.acmicpc.net/problem/10872\u003c/a\u003e\u003c/div\u003e\\n\\n---\\n\\n- 정수 N에 반복적으로 곱해준다.\\n\\n---\\n\\n```cpp\\n#include \u003ciostream\u003e\\nusing namespace std;\\n\\n/**\\n * 팩토리얼 문제 해결\\n * n!을 계산하는 문제\\n * 1부터 n까지의 모든 수를 곱함\\n */\\nint main() {\\n\\tint n,sum=1; // n: 입력값, sum: 팩토리얼 결과 (1로 초기화)\\n\\tcin\u003e\u003en;\\n\\t\\n\\t// 1부터 n까지 반복하여 곱함\\n\\tfor(int i=1;i\u003c=n;i++){\\n\\t\\tsum*=i; // i를 곱함\\n\\t}\\n\\tcout\u003c\u003csum;\\n\\treturn 0;\\n}\\n```\\n\"},{\"slug\":\"ac10829\",\"title\":\"이진수 변환\",\"date\":\"2021-05-03T23:44:37.121Z\",\"description\":\"백준 10829번 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"\\n[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/10829)\\n\\n\u003cdiv className=\\\"text-center\\\"\u003e\u003ca href=\\\"https://www.acmicpc.net/problem/10829\\\"\u003ehttps://www.acmicpc.net/problem/10829\u003c/a\u003e\u003c/div\u003e\\n\\n---\\n\\n- n을 2나눈 나머지를 출력하고 n에 2를 나눈다.\\n- n/2가 0이면 2보다 작아졌다는 말이므로 멈춘다.\\n\\n---\\n\\n```java\\nimport java.util.*;\\nimport java.lang.*;\\nimport java.io.*;\\n\\n/**\\n * 이진수 변환 문제 해결\\n * 10진수를 2진수로 변환하는 문제\\n * 2로 나눈 나머지를 역순으로 모으면 2진수가 됨\\n */\\nclass Main\\n{\\n\\tpublic static void main (String[] args) throws IOException\\n\\t{\\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\\n\\t\\tBufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\\n\\t\\tString result=\\\"\\\"; // 2진수 결과 문자열\\n\\t\\tlong n = Long.parseLong(br.readLine());\\n\\t\\t\\n\\t\\t// 2로 나눈 나머지를 앞에 추가하고, n을 2로 나눔\\n\\t\\t// n이 0이 될 때까지 반복\\n\\t\\twhile(n!=0){\\n\\t\\t\\tresult = (n%2)+result; // 나머지를 앞에 추가 (역순으로 저장)\\n\\t\\t\\tn/=2; // 2로 나눔\\n\\t\\t}\\n\\t\\tbw.write(result);\\n\\t\\tbw.flush();\\n\\t}\\n}\\n```\\n\"},{\"slug\":\"ac3055\",\"title\":\"탈출\",\"date\":\"2021-05-02T19:21:37.121Z\",\"description\":\"백준 3055번 그래프 탐색 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$1c\"},{\"slug\":\"ac9012\",\"title\":\"괄호\",\"date\":\"2021-04-30T11:17:37.121Z\",\"description\":\"백준 9012번 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$1d\"},{\"slug\":\"ac1620\",\"title\":\"나는야 포켓몬 마스터 이다솜\",\"date\":\"2021-04-29T23:56:37.121Z\",\"description\":\"백준 1620번 해시를 사용한 집합과 맵 문자열 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$1e\"},{\"slug\":\"programmers42577\",\"title\":\"전화번호 목록\",\"date\":\"2021-04-27T19:44:37.121Z\",\"description\":\"프로그래머스 큐 연습문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"\\n[![프로그래머스](https://file.newswire.co.kr/data/datafile2/thumb_640/2021/06/1993996598_20210610150326_5364622170.jpg)](https://programmers.co.kr/learn/courses/30/lessons/42577)\\n\\n\u003cdiv className=\\\"text-center\\\"\u003e\u003ca href=\\\"https://programmers.co.kr/learn/courses/30/lessons/42577\\\"\u003ehttps://programmers.co.kr/learn/courses/30/lessons/42577\u003c/a\u003e\u003c/div\u003e\\n\\n---\\n\\n- String의 매치를 이용하여 배열내를 탐색해 문자열이 다른 문자열 앞에 오는지 확인한다.\\n\\n```java\\n/**\\n * 전화번호 목록 문제 해결\\n * 전화번호 배열에서 한 번호가 다른 번호의 접두사인지 확인하는 문제\\n * 정규식을 사용하여 문자열 매칭\\n */\\nclass Solution {\\n    public boolean solution(String[] phone_book) {\\n        boolean answer = true;\\n        \\n        // 모든 전화번호 쌍을 비교\\n        for(int i=0;i\u003cphone_book.length;i++){\\n            for(int j=0;j\u003cphone_book.length;j++){\\n                if(i==j)continue; // 같은 번호는 건너뜀\\n                // phone_book[i]가 phone_book[j]로 시작하는지 확인\\n                // ^는 시작, .*$는 뒤에 아무 문자나 올 수 있음을 의미\\n                if(phone_book[i].matches(\\\"^\\\"+phone_book[j]+\\\".*$\\\"))return false;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```\\n\"},{\"slug\":\"programmers42576\",\"title\":\"완주하지 못한 선수\",\"date\":\"2021-04-27T00:46:37.121Z\",\"description\":\"프로그래머스 큐 연습문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"\\n[![프로그래머스](https://file.newswire.co.kr/data/datafile2/thumb_640/2021/06/1993996598_20210610150326_5364622170.jpg)](https://programmers.co.kr/learn/courses/30/lessons/42576)\\n\\n\u003cdiv className=\\\"text-center\\\"\u003e\u003ca href=\\\"https://programmers.co.kr/learn/courses/30/lessons/42576\\\"\u003ehttps://programmers.co.kr/learn/courses/30/lessons/42576\u003c/a\u003e\u003c/div\u003e\\n\\n---\\n\\n- 받은 이름을 정렬하여 이름이 다르면 바로 뽑는다.\\n\\n```java\\nimport java.util.*;\\n\\n/**\\n * 완주하지 못한 선수 문제 해결\\n * 참가자 배열과 완주자 배열을 비교하여 완주하지 못한 선수를 찾는 문제\\n * 정렬을 사용하여 두 배열을 비교\\n */\\nclass Solution {\\n    public String solution(String[] participant, String[] completion) {\\n        // 두 배열을 정렬하여 순서대로 비교\\n        Arrays.sort(participant);\\n        Arrays.sort(completion);\\n        int i=0;\\n        \\n        // 완주자 배열과 비교하여 다른 이름을 찾음\\n        for(i=0;i\u003ccompletion.length;i++){\\n            if(!participant[i].equals(completion[i]))\\n                return participant[i]; // 다른 이름이면 완주하지 못한 선수\\n        }\\n        // 모든 완주자와 일치하면 마지막 참가자가 완주하지 못한 선수\\n        return participant[i];\\n    }\\n}\\n```\\n\"},{\"slug\":\"ac15829\",\"title\":\"Hashing\",\"date\":\"2021-04-27T00:43:37.121Z\",\"description\":\"백준 15829번 해싱 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$1f\"},{\"slug\":\"ac1107\",\"title\":\"리모컨\",\"date\":\"2021-04-26T11:45:37.121Z\",\"description\":\"백준 1107번 브루트포스 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$20\"},{\"slug\":\"ac1463\",\"title\":\"1로 만들기\",\"date\":\"2021-04-25T16:12:37.121Z\",\"description\":\"백준 1463번 다이나믹 프로그래밍 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$21\"},{\"slug\":\"ac1259\",\"title\":\"펠린드롬수\",\"date\":\"2021-04-24T17:11:37.121Z\",\"description\":\"백준 1259번 문자열 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$22\"},{\"slug\":\"ac1012\",\"title\":\"소수 찾기\",\"date\":\"2021-04-23T11:40:37.121Z\",\"description\":\"백준 1012 DFS 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$23\"},{\"slug\":\"ac10989\",\"title\":\"수 정렬하기3\",\"date\":\"2021-04-22T10:11:37.121Z\",\"description\":\"백준 10989번 정렬 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$24\"},{\"slug\":\"ac20927\",\"title\":\"Degree Bounded Minimum Spanning Tree\",\"date\":\"2021-04-21T10:10:37.121Z\",\"description\":\"백준 20927번 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$25\"},{\"slug\":\"ac18111\",\"title\":\"마인크래프트\",\"date\":\"2021-04-21T10:10:37.121Z\",\"description\":\"백준 18111번 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$26\"},{\"slug\":\"programmers17681\",\"title\":\"비밀지도\",\"date\":\"2021-04-20T18:38:37.121Z\",\"description\":\"카카오 블라인드\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$27\"},{\"slug\":\"ac2745\",\"title\":\"진법변환\",\"date\":\"2021-04-19T22:39:37.121Z\",\"description\":\"백준 2745번 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$28\"},{\"slug\":\"ac6603\",\"title\":\"로또\",\"date\":\"2021-04-16T20:55:37.121Z\",\"description\":\"백준 6603번 조합론 백트래킹 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$29\"},{\"slug\":\"ac5692\",\"title\":\"팩토리얼 진법\",\"date\":\"2021-04-16T20:55:37.121Z\",\"description\":\"백준 5692번 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$2a\"},{\"slug\":\"ac4949\",\"title\":\"균형잡힌 세상\",\"date\":\"2021-04-15T20:30:37.121Z\",\"description\":\"백준 4949번 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$2b\"},{\"slug\":\"ac2869\",\"title\":\"달팽이는 올라가고 싶다\",\"date\":\"2021-04-14T20:30:37.121Z\",\"description\":\"백준 2869번 수학 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$2c\"},{\"slug\":\"ac2805\",\"title\":\"나무 자르기\",\"date\":\"2021-04-13T20:30:37.121Z\",\"description\":\"백준 2805번 이분탐색 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$2d\"},{\"slug\":\"ac2775\",\"title\":\"부녀회장이 될테야\",\"date\":\"2021-04-13T18:15:37.121Z\",\"description\":\"백준 2775번 조합론 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$2e\"},{\"slug\":\"ac2292\",\"title\":\"벌집\",\"date\":\"2021-04-12T20:26:37.121Z\",\"description\":\"백준 2292번 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$2f\"},{\"slug\":\"ac2108\",\"title\":\"통계학\",\"date\":\"2021-04-11T15:24:37.121Z\",\"description\":\"백준 2108번 정렬 구현 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$30\"},{\"slug\":\"ac1978\",\"title\":\"소수 찾기\",\"date\":\"2021-04-10T20:17:37.121Z\",\"description\":\"백준 1978번 정수론 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$31\"},{\"slug\":\"programmers43165\",\"title\":\"타겟 넘버\",\"date\":\"2021-04-09T16:19:37.121Z\",\"description\":\"프로그래머스 DFS/BFS 연습문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$32\"},{\"slug\":\"ac2606\",\"title\":\"바이러스\",\"date\":\"2021-04-08T22:39:37.121Z\",\"description\":\"백준 2606번 DFS 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$33\"},{\"slug\":\"ac1260\",\"title\":\"DFS와 BFS\",\"date\":\"2021-04-08T17:11:37.121Z\",\"description\":\"백준 1260번 BFS DFS 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$34\"},{\"slug\":\"ac1874\",\"title\":\"스택 수열\",\"date\":\"2021-04-08T16:22:37.121Z\",\"description\":\"백준 1874번 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$35\"},{\"slug\":\"ac1157\",\"title\":\"단어공부\",\"date\":\"2021-04-07T19:32:37.121Z\",\"description\":\"백준 1157번 문자열 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$36\"},{\"slug\":\"ac1654\",\"title\":\"랜선자르기\",\"date\":\"2021-04-05T16:12:37.121Z\",\"description\":\"백준 1654번 이분탐색 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$37\"},{\"slug\":\"ac1436\",\"title\":\"영화감독 숌\",\"date\":\"2021-04-04T23:47:37.121Z\",\"description\":\"백준 1436번 브루트포스 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$38\"},{\"slug\":\"ac10816\",\"title\":\"숫자카드 2\",\"date\":\"2021-04-02T10:52:37.121Z\",\"description\":\"백준 10816번 이분탐색 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$39\"},{\"slug\":\"programmers42839\",\"title\":\"소수찾기\",\"date\":\"2021-04-01T23:38:37.121Z\",\"description\":\"프로그래머스 큐 연습문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$3a\"},{\"slug\":\"ac1697\",\"title\":\"술래잡기\",\"date\":\"2021-03-31T23:32:37.121Z\",\"description\":\"백준 1697번 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$3b\"},{\"slug\":\"ac11866\",\"title\":\"요세푸스 문제0\",\"date\":\"2021-03-26T15:21:37.121Z\",\"description\":\"백준 11866번 스택 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$3c\"},{\"slug\":\"programmers42840\",\"title\":\"모의고사\",\"date\":\"2021-03-25T15:25:37.121Z\",\"description\":\"프로그래머스 큐 연습문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$3d\"},{\"slug\":\"programmers42583\",\"title\":\"다리를 지나는 트럭\",\"date\":\"2021-03-25T15:25:37.121Z\",\"description\":\"프로그래머스 큐 연습문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$3e\"},{\"slug\":\"programmers42586\",\"title\":\"기능개발\",\"date\":\"2021-03-24T14:22:37.121Z\",\"description\":\"프로그래머스 큐 연습문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$3f\"},{\"slug\":\"programmers42584\",\"title\":\"주식가격\",\"date\":\"2021-03-24T02:05:37.121Z\",\"description\":\"프로그래머스 큐 연습문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$40\"},{\"slug\":\"ac10250\",\"title\":\"ACM 호텔\",\"date\":\"2021-03-18T23:08:37.121Z\",\"description\":\"백준 10250번 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$41\"},{\"slug\":\"ac1197\",\"title\":\"최소 스패닝 트리\",\"date\":\"2021-03-09T11:31:37.121Z\",\"description\":\"백준 1197번 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$42\"},{\"slug\":\"ac1149\",\"title\":\"RGB거리\",\"date\":\"2021-03-05T01:15:37.121Z\",\"description\":\"백준 1149번 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$43\"},{\"slug\":\"ac1013\",\"title\":\"Contact\",\"date\":\"2021-03-05T01:15:37.121Z\",\"description\":\"백준 1013번 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$44\"},{\"slug\":\"ac1008\",\"title\":\"유기농 배추\",\"date\":\"2021-03-02T23:21:37.121Z\",\"description\":\"백준 1008번 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$45\"},{\"slug\":\"ac1003\",\"title\":\"피보나치 수열\",\"date\":\"2021-03-01T23:32:37.121Z\",\"description\":\"백준 1003번 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$46\"},{\"slug\":\"ac15649\",\"title\":\"N과 M(1)\",\"date\":\"2021-02-26T03:38:37.121Z\",\"description\":\"백준 15649번 백트래킹 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$47\"},{\"slug\":\"ac11650\",\"title\":\"좌표 정렬하기\",\"date\":\"2021-02-26T03:38:37.121Z\",\"description\":\"백준 11650번 정렬 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$48\"},{\"slug\":\"ac1002\",\"title\":\"터렛\",\"date\":\"2021-02-24T23:32:37.121Z\",\"description\":\"백준 1002번 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$49\"},{\"slug\":\"ac1018\",\"title\":\"체스판 다시 칠하기\",\"date\":\"2021-02-21T23:32:37.121Z\",\"description\":\"백준 1018번 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$4a\"},{\"slug\":\"ac1158\",\"title\":\"요세푸스 문제\",\"date\":\"2019-05-31T15:23:37.121Z\",\"description\":\"백준 1158번 큐 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$4b\"},{\"slug\":\"ac9095\",\"title\":\"1,2,3 더하기\",\"date\":\"2019-05-11T02:05:37.121Z\",\"description\":\"백준 9095번 문제\",\"categories\":[\"알고리즘\"],\"tags\":[\"알고리즘\"],\"emoji\":\"🧢\",\"content\":\"$4c\"}],\"tags\":[\"알고리즘\"]}],null],null],null]},[null,[\"$\",\"$L4d\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4e\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/328a36cb386d2c2a.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"ko\",\"suppressHydrationWarning\":true,\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",null,{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"page-wrapper\",\"children\":[[\"$\",\"$L4f\",null,{}],[\"$\",\"main\",null,{\"className\":\"page-content\",\"children\":[\"$\",\"$L4d\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4e\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"not-found\",\"children\":[[\"$\",\"h1\",null,{\"children\":\"404: Not Found\"}],[\"$\",\"p\",null,{\"children\":\"존재하지 않는 페이지입니다.\"}],[\"$\",\"$L50\",null,{\"href\":\"/\",\"className\":\"back-link\",\"children\":\"홈으로 돌아가기\"}]]}],\"notFoundStyles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e9d52e2af3c65930.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]]}]}],[\"$\",\"footer\",null,{\"className\":\"page-footer-wrapper\",\"children\":[\"$\",\"p\",null,{\"className\":\"page-footer\",\"children\":[\"© \",2026,\" \",[\"$\",\"a\",null,{\"href\":\"https://github.com/BlueTi\",\"children\":\"이재호\"}],\" powered by\",\" \",[\"$\",\"a\",null,{\"href\":\"https://nextjs.org/\",\"children\":\"Next.js\"}]]}]}],[\"$\",\"$L51\",null,{}]]}]}]]}]],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$L52\"],\"globalErrorComponent\":\"$53\",\"missingSlots\":\"$W54\"}]\n"])</script><script>self.__next_f.push([1,"52:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"blueti.github.io\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"재호의 개발일기\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"이재호\"}]]\n3:null\n"])</script></body></html>