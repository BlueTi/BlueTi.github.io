{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/알고리즘",
    "result": {"pageContext":{"currentCategory":"알고리즘","categories":["All","알고리즘"],"edges":[{"node":{"id":"12ab8ebf-42c6-5061-b5e7-1f864ca74ff0","excerpt":"프로그래머스 Map안에 List를 넣어 관리한다 검색가능한 쿼리 키를 미리 만들어 목록을 작성한다 조건맞을 맞춘 목록에서 이분 탐색으로 속도를 구해야한다","fields":{"slug":"/algorithm/programmers/programmers72412/"},"frontmatter":{"categories":"알고리즘","title":"순위 검색","date":"October 07, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac1922/"}},"previous":null},{"node":{"id":"a202e99f-17fe-5ba1-bd26-a11d388d2282","excerpt":"백준 최소 스패닝 트리에 대한 문제이다. 연결 비용을 오름차순으로 정렬 후 연결 목록을 꺼내 부모노드가 다를때 같아지게 만들고, 같다면 넘겨서 모두를 잇는다. 유니온 파인드에 이어서 보면 매우 편하다.","fields":{"slug":"/algorithm/baekjoon/ac1922/"},"frontmatter":{"categories":"알고리즘","title":"네트워크 연결","date":"July 12, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac1939/"}},"previous":{"fields":{"slug":"/algorithm/programmers/programmers72412/"}}},{"node":{"id":"ca7c5e9c-6302-5054-b665-47d702cfdc5b","excerpt":"백준 가능한 다리의 무게를 무거운 순서로 정렬하여 꺼내면서 부모 노드를 합쳐준다. 합쳐준 부모 노드 기록을 참조하여 합치기가 끝날때 시작점과 끝이 같아졌는지 확인한다.","fields":{"slug":"/algorithm/baekjoon/ac1939/"},"frontmatter":{"categories":"알고리즘","title":"중량제한","date":"July 07, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac1976/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac1922/"}}},{"node":{"id":"c02f6080-cd42-5c28-b9f5-73272d9ef613","excerpt":"백준 여행지의 각 위치를 숫자로 표기한다. 입력 배열에서 1이 들어올 경우 i,j 위치를 이어준다(각 값을 비교하여 루트를 넣어준다).","fields":{"slug":"/algorithm/baekjoon/ac1976/"},"frontmatter":{"categories":"알고리즘","title":"여행 가자","date":"July 05, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac1717/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac1939/"}}},{"node":{"id":"2a1bb8e0-7102-5328-9cf0-cad6875594f2","excerpt":"백준 연결된 숫자들을 찾는 배열을 선언합니다. 부모노드를 숫자가 더 작은 쪽으로 몰아 넣어준다.","fields":{"slug":"/algorithm/baekjoon/ac1717/"},"frontmatter":{"categories":"알고리즘","title":"집합의 표현","date":"July 03, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac1826/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac1976/"}}},{"node":{"id":"b39c7ecd-35dc-5e42-bbd5-9f119b57c83f","excerpt":"백준 주유소를 거리가 짧은 순으로 정렬하여 현재 연료로 접근할 수 있는 주유소로 접근한다. 넣을 수 있는 기름의 양이 큰 순서로 접근한 주유소 목록 정렬하여 큰 양을 넣는다.","fields":{"slug":"/algorithm/baekjoon/ac1826/"},"frontmatter":{"categories":"알고리즘","title":"연료 채우기","date":"June 30, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac11000/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac1717/"}}},{"node":{"id":"5dd8bf2c-1730-5521-816d-2f223edf2654","excerpt":"백준 강의 시간을 정렬하여 넣는데 빠른 강의가 앞에 오도록 넣는다. 시간표 큐의 가장 앞 강의가 넣으려는 시간보다 늦다면 끝났다는 의미이므로 빼버리고 그렇지 않다면 강의중이므로 새 강의를 넣어 큐의 크기(강의실)을 늘린다.","fields":{"slug":"/algorithm/baekjoon/ac11000/"},"frontmatter":{"categories":"알고리즘","title":"강의실 배정","date":"June 27, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac11286/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac1826/"}}},{"node":{"id":"0722a9a0-f6d9-53b7-a668-13f1068fee68","excerpt":"백준 N개의 숫자를 입력받고 숫자가 0일 경우 절댓값이 가장 작은 값을 출력한다. PriorityQueue에서 절대값이 작은경우 앞으로 가도록 하고 나중에 입력받은 값이 뒤로 가도록 정렬한다.","fields":{"slug":"/algorithm/baekjoon/ac11286/"},"frontmatter":{"categories":"알고리즘","title":"절댓값 힙","date":"June 27, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac11279/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac11000/"}}},{"node":{"id":"163d23c1-2114-5ea5-8e7d-791f14d32916","excerpt":"백준 N개 숫자를 받고 0일 경우 가장 큰 값을 출력한다. 자바의 PriorityQueue를 역정렬 시켜서 나오게 만든다.","fields":{"slug":"/algorithm/baekjoon/ac11279/"},"frontmatter":{"categories":"알고리즘","title":"최대 힙","date":"June 27, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac13305/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac11286/"}}},{"node":{"id":"e0282a36-1597-5990-9035-1ecac2090f4d","excerpt":"백준 어쨋거나 도착할 수 있다. 기름을 넣어서 이동하는게 아니라 기름을 꿔서 움직인다고 생각하자. 일단 이동을 하고 이전 주유소의 가격이 더 쌀 경우 그 가격으로 사는거다.","fields":{"slug":"/algorithm/baekjoon/ac13305/"},"frontmatter":{"categories":"알고리즘","title":"주유소","date":"June 21, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac1931/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac11279/"}}},{"node":{"id":"51dc3045-4b07-569b-bcf4-5ebc7129ac68","excerpt":"백준 회의 끝나는 시간을 기준으로 정렬한다. 끝나는 시간이 같을 경우 더 늦게 시작하여 회의시간이 짧은 경우를 넣는다. 그림으로 다른분께서 보기 좋게 정리해주셨다.(https://st-lab.tistory.com/145)\r\n 처음 입력된 회의 시간 목록이다.\r\n 위의 조건으로 정렬한 그림이다. 여기서 앞에 회의시간을 넣고 앞 시간의 끝시간과 다음 시간의 시작시간이 겹치지 않는것을 이어준다.","fields":{"slug":"/algorithm/baekjoon/ac1931/"},"frontmatter":{"categories":"알고리즘","title":"회의실 배정","date":"June 21, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac13460/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac13305/"}}},{"node":{"id":"be1189dc-d178-5210-8f3b-24f3e05736bb","excerpt":"백준 구슬이 어딘가 부딛힐때까지 움직인다. 빨간 구슬과 파란 구슬은 겹쳐지지 않는다. 파란 구슬과 빨간 구슬이 같은 방향으로 동시에 빠질 경우 실패. 파란 구슬이 먼저 빠져도 안된다. 10번 이내 해야하고 그러지 못 할 경우 -1을 출력.","fields":{"slug":"/algorithm/baekjoon/ac13460/"},"frontmatter":{"categories":"알고리즘","title":"구슬 탈출 2","date":"June 18, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac7562/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac1931/"}}},{"node":{"id":"546a32d2-3e1e-58e1-b815-6396ec1d5195","excerpt":"백준 큐를 이용해 탐색할 작업을 돈다. 처음 도착한 값이 최소 값이므로 break.","fields":{"slug":"/algorithm/baekjoon/ac7562/"},"frontmatter":{"categories":"알고리즘","title":"나이트의 이동","date":"June 14, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac11724/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac13460/"}}},{"node":{"id":"c87450d5-65e6-5298-ba70-511d1af3d196","excerpt":"백준 방향이 없는 서로 연결된 노드 덩어리의 갯수를 세는 문제다. 방문한 적이 없는 자식 노드까지 탐색을 돌면 된다.","fields":{"slug":"/algorithm/baekjoon/ac11724/"},"frontmatter":{"categories":"알고리즘","title":"연결 요소의 개수","date":"June 06, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac14888/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac7562/"}}},{"node":{"id":"0cb0e790-ba1b-50bf-90fd-b3e56bf89192","excerpt":"백준 연산자의 갯수가 주어지고 주어진 숫자 배열에 끼워 넣어 만든 값의 최대,최소 값을 출력하는 문제 연산자 하나 끼워서 계산해보고 다시 빼서 다른거 끼워보며 연산을 하는 과정으로 생각하면 편하다.","fields":{"slug":"/algorithm/baekjoon/ac14888/"},"frontmatter":{"categories":"알고리즘","title":"연산자 끼워넣기","date":"May 31, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac5430/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac11724/"}}},{"node":{"id":"a363f124-a940-52b5-bc6f-fb64b00372e1","excerpt":"백준 문제 자체는 단순하다. 명령대로 R일 경우 순서를 뒤집고, D일 경우 앞에서 하나를 빼준다. 하지만 일일히 뒤집으면 시간이 오래 걸리므로 인덱스 left,right를 선언하여 한칸씩 움직여봤다. 위와 같이 푸는 방식도 있지만 java에는 Deque 클래스가 있으므로 일일히 구현할 필요 없이 이미 구현된 클래스를 사용하여도 된다.","fields":{"slug":"/algorithm/baekjoon/ac5430/"},"frontmatter":{"categories":"알고리즘","title":"AC","date":"May 31, 2021"}},"next":{"fields":{"slug":"/algorithm/programmers/programmers42585/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac14888/"}}},{"node":{"id":"7d156331-a077-560e-a256-f6ae6e011032","excerpt":"프로그래머스 주어진 숫자를 붙여 가며 사칙연산을 통과시켜 값을 확인한다. N이 1부터 9이하로 주어지니 반복횟수를 맞추기 위해 0부터 8로한다. 처음 식은 5가 주어지고 사칙연산을 붙일 수 없으니 카운트 1부터 사칙연산으로 나눠진다. 그런식으로 각 dfs들이 목표 숫자에 도달했을때 최소 값인지 비교하여 대입한다.","fields":{"slug":"/algorithm/programmers/programmers42585/"},"frontmatter":{"categories":"알고리즘","title":"N으로 표현","date":"May 30, 2021"}},"next":{"fields":{"slug":"/algorithm/programmers/programmers43105/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac5430/"}}},{"node":{"id":"32d0f4c3-5ccb-5ef8-bb58-ceb57f8e3665","excerpt":"프로그래머스 https://programmers.co.kr/learn/courses/30/lessons/43105 삼각형의 밑바닥부터 훑고 올라간다. 맨 밑 우측 끝의 두값을 비교해서 위에 칸에 더해준다. 최대 값은 자연스럽게 0,0에 들어가게 된다.","fields":{"slug":"/algorithm/programmers/programmers43105/"},"frontmatter":{"categories":"알고리즘","title":"정수 삼각형","date":"May 27, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac11729/"}},"previous":{"fields":{"slug":"/algorithm/programmers/programmers42585/"}}},{"node":{"id":"a1ca99a3-a594-55e4-85c1-0f25d0ddccba","excerpt":"백준 규칙 1 2 3 칸이 있고 1에 있는 원판을 3으로 옮겨야한다. 원판은 크기 순서로 쌓여 있는데 큰 원판이 작은원판 위로 갈 수 없다. 1에서 3으로 옮기려는 원판을 놓고 1에서 그 다음 원판을 2에 놓고 3에서 2로 옮긴뒤 2에서 쌓여있는 원판들을 3으로 옮긴다. 반복 hanoi 함수에서 마지막 원판을 옮기는 것부터 조건을 놓고 그 숫자가 마지막 숫자가 아니라면 그 전의 동작으로 거슬러 올라간다.","fields":{"slug":"/algorithm/baekjoon/ac11729/"},"frontmatter":{"categories":"알고리즘","title":"하노이 탑 이동 순서","date":"May 24, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac2579/"}},"previous":{"fields":{"slug":"/algorithm/programmers/programmers43105/"}}},{"node":{"id":"22a32f04-39cd-5a58-ba0a-db817e9573c4","excerpt":"백준 계단은 3번 연속 갈 수 없다. 고로 현재 칸까지 합은 전전칸까지 합+현재칸 이거나 전전전 칸까지 합+ 전 칸 + 현재 칸 중 큰 것을 넣어준다.","fields":{"slug":"/algorithm/baekjoon/ac2579/"},"frontmatter":{"categories":"알고리즘","title":"계단오르기","date":"May 15, 2021"}},"next":{"fields":{"slug":"/algorithm/programmers/programmers60058/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac11729/"}}},{"node":{"id":"38c7d1fd-c508-55d5-be0e-3e150c325e6b","excerpt":"프로그래머스 입력받은 문자열을 완전한 괄호 부분이 있는지 확인한다. 앞부분이 완전한 괄호라면 뒤엣 부분을 다시 체크. 완전하지 않다면 길이만큼 재구성한다.","fields":{"slug":"/algorithm/programmers/programmers60058/"},"frontmatter":{"categories":"알고리즘","title":"괄호 변환","date":"May 13, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac1927/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac2579/"}}},{"node":{"id":"1039f78c-3fa4-5c23-8c01-3c79382520df","excerpt":"백준 우선순위 큐를 이용하여 정렬한 수 입력받은 값이 0일 경우 가장 작은 값을 출력하도록 한다. 자바의 PriorityQueue를 사용한다. 보통 퀵소트 구현을 하던가 하지만 어떤 분께서 실험한 글에 따르면 자바 내장 우선순위 큐가 나쁘지 않다고 하니 구현된 것을 사용한다.","fields":{"slug":"/algorithm/baekjoon/ac1927/"},"frontmatter":{"categories":"알고리즘","title":"최소 힙","date":"May 12, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac12015/"}},"previous":{"fields":{"slug":"/algorithm/programmers/programmers60058/"}}},{"node":{"id":"dc38c60b-6cbe-5b81-a6dc-67ea0bf5f76e","excerpt":"백준 입력 받는 값을 순차적으로 받는다. 받은 값을 결과 배열에서 탐색을 해서 끼워넣거나 새로 넣는다. 최대 값보다 큰 경우는 새로 넣는다. 그렇지 않은 경우 기존 배열에 탐색해서 적합한 자리를 찾아 새로 갱신한다.","fields":{"slug":"/algorithm/baekjoon/ac12015/"},"frontmatter":{"categories":"알고리즘","title":"가장 긴 증가하는 부분 수열","date":"May 12, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac10872/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac1927/"}}},{"node":{"id":"a0871f81-5587-588d-82c6-5555348c8e30","excerpt":"백준 정수 N에 반복적으로 곱해준다.","fields":{"slug":"/algorithm/baekjoon/ac10872/"},"frontmatter":{"categories":"알고리즘","title":"팩토리얼","date":"May 03, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac10829/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac12015/"}}},{"node":{"id":"ce4b6aba-ff4e-5b70-bc9d-3e41e4d35377","excerpt":"백준 n을 2나눈 나머지를 출력하고 n에 2를 나눈다. n/2가 0이면 2보다 작아졌다는 말이므로 멈춘다.","fields":{"slug":"/algorithm/baekjoon/ac10829/"},"frontmatter":{"categories":"알고리즘","title":"이진수 변환","date":"May 03, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac3055/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac10872/"}}},{"node":{"id":"9397c176-13a2-5b6f-bb8b-168d372d67a4","excerpt":"백준 물웅덩이가 ‘시간마다’ 번지고 고슴도치가 ‘시간마다’ 움직인다. BFS를 써서 푼다. 일단 물이 먼저 퍼지고, 그 다음 고슴도치가 움직인다. 물의 위치를 큐에 넣고 탐색을 처음 큐 길이만큼 돌려서 새로 넣은 물의 위치는 다음 타임에 한다. 거리를 적어놓는 int배열 dist를 만들어서 고슴도치가 움직일때마다 현위치에서 이동할 곳에 +1을 넣어준다. 고슴도치가 목적지에 도착하면 고슴도치 위치 큐에 넣지 않아 큐가 비가 되어 while문을 멈춘다.","fields":{"slug":"/algorithm/baekjoon/ac3055/"},"frontmatter":{"categories":"알고리즘","title":"탈출","date":"May 02, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac9012/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac10829/"}}},{"node":{"id":"dbbd6cd4-489b-5b09-aadf-321eeed1c041","excerpt":"백준 ’(‘의 갯수 와 ’)‘갯수를 세어 )가 더 크게 되면 갯수가 맞지 않으므로 NO를 출력 끝까지 가면 YES를 출력","fields":{"slug":"/algorithm/baekjoon/ac9012/"},"frontmatter":{"categories":"알고리즘","title":"괄호","date":"April 30, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac1620/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac3055/"}}},{"node":{"id":"369cbad0-5d68-56a1-a233-b7d9760ad1bb","excerpt":"백준 이름을 키로 하여 번호를 갖는 맵과 번호를 인덱스로 하는 String배열을 통해 참조하도록 한다.","fields":{"slug":"/algorithm/baekjoon/ac1620/"},"frontmatter":{"categories":"알고리즘","title":"나는야 포켓몬 마스터 이다솜","date":"April 29, 2021"}},"next":{"fields":{"slug":"/algorithm/programmers/programmers42577/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac9012/"}}},{"node":{"id":"95260165-1dff-576d-ae15-10aad3d35a7a","excerpt":"프로그래머스 String의 매치를 이용하여 배열내를 탐색해 문자열이 다른 문자열 앞에 오는지 확인한다.","fields":{"slug":"/algorithm/programmers/programmers42577/"},"frontmatter":{"categories":"알고리즘","title":"전화번호 목록","date":"April 27, 2021"}},"next":{"fields":{"slug":"/algorithm/programmers/programmers42576/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac1620/"}}},{"node":{"id":"ab5dccb0-667a-5ec2-a266-97d84ef0244f","excerpt":"프로그래머스 받은 이름을 정렬하여 이름이 다르면 바로 뽑는다.","fields":{"slug":"/algorithm/programmers/programmers42576/"},"frontmatter":{"categories":"알고리즘","title":"완주하지 못한 선수","date":"April 27, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac15829/"}},"previous":{"fields":{"slug":"/algorithm/programmers/programmers42577/"}}},{"node":{"id":"48d0142c-6be5-5610-9749-999613439227","excerpt":"백준 문제를 잘 읽자. M값의 나머지로만 움직여야한다.","fields":{"slug":"/algorithm/baekjoon/ac15829/"},"frontmatter":{"categories":"알고리즘","title":"Hashing","date":"April 27, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac1107/"}},"previous":{"fields":{"slug":"/algorithm/programmers/programmers42576/"}}},{"node":{"id":"a9372d55-a06d-5bc4-b73c-e06f1292c545","excerpt":"백준 시작 100이니 목적지에서 100을 절대값을 넣고 찾기 시작한다. 한글자씩 떼서 확인하는것이 한칸씩 움직이는것과 비교했을때 뭐가 더 적은가를 비교하며 반복한다.","fields":{"slug":"/algorithm/baekjoon/ac1107/"},"frontmatter":{"categories":"알고리즘","title":"리모컨","date":"April 26, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac1463/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac15829/"}}},{"node":{"id":"8988dac2-51cf-5adb-abf7-ea9414d73e44","excerpt":"백준 문제는 최단거리로 n에서 1로 가는거지만 거꾸로 1에서 최단거리로 n가는 방법도 적용된다. 배열은 n+1만큼 선언하여 끝까지 도달할때 더 작은값이 들어가는 조건을 찾아 비교하여 채운다.","fields":{"slug":"/algorithm/baekjoon/ac1463/"},"frontmatter":{"categories":"알고리즘","title":"1로 만들기","date":"April 25, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac1259/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac1107/"}}},{"node":{"id":"10be00d6-c4d4-5f83-a7cf-8cf48fb7dd48","excerpt":"백준 숫자가 대칭하는 모양인지 판별하는 문제이다. 숫자이지만 대칭하는 모양을 판별하는 것은 문자로 봐야한다. 문자 배열 인덱스를 하나씩 좌우에서 들어가면서 비교한다.","fields":{"slug":"/algorithm/baekjoon/ac1259/"},"frontmatter":{"categories":"알고리즘","title":"펠린드롬수","date":"April 24, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac1012/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac1463/"}}},{"node":{"id":"76e48a8d-dd33-52e2-a2ea-ad21d09080ad","excerpt":"백준 이어진 배추가 있는지 탐색하여 필요한 배추벌레 갯수를 구한다. 한점을 탐색하여 상하좌우를 살펴서 있을 경우 한마리로 배추가 없을때까지 탐색을 하여 배추를 배열에서 제거하고 카운트를 늘린다.","fields":{"slug":"/algorithm/baekjoon/ac1012/"},"frontmatter":{"categories":"알고리즘","title":"소수 찾기","date":"April 23, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac10989/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac1259/"}}},{"node":{"id":"4467db95-462d-59fc-9a61-b1a30858a09f","excerpt":"백준 정렬 속도를 중요시 하는 퀵정렬을 이용한다. 기준을 왼쪽 앞으로 하느냐 가운데로 하느냐가 있는데 일단 왼쪽 앞으로 했다. 기준을 잡고 양 가운데로 나눈다. 왼쪽을 기준값보다 작은 값, 오른쪽을 큰 값. 나눠진 배열에서 기준값을 잡고 다시 양쪽으로 나누기 반복 두개만 남은 배열에서 정렬 시작.","fields":{"slug":"/algorithm/baekjoon/ac10989/"},"frontmatter":{"categories":"알고리즘","title":"수 정렬하기3","date":"April 22, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac18111/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac1012/"}}},{"node":{"id":"a8356885-9bc6-5be8-8782-cabf117d0353","excerpt":"백준 땅을 평평하게 하기 위해 파거나 쌓는 작업을 하는데 그 중 가장 높은 높이를 출력해야한다. 반복의 범위를 줄이기 위해 높이 최저,최고 값을 정해준다. 최저값부터 최고값까지 각 칸과의 거리를 구하여 음수가 나오면 파내는것이고 양수가 나오면 더해줘야하므로 가방에서 더해준다. 배열 탐색을 끝내고 가방에서 쓸 수 있는 블록 보다 더 쓸 경우는 넘어간다. 블록이 사용가능한 갯수면 최소 시간을 비교하여 대입한다.","fields":{"slug":"/algorithm/baekjoon/ac18111/"},"frontmatter":{"categories":"알고리즘","title":"마인크래프트","date":"April 21, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac20927/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac10989/"}}},{"node":{"id":"6b5604da-1cad-5145-9337-d83bc926107d","excerpt":"백준 문제에서 스패닝트리만 읽고 최소 스패닝트리로 하면 답이 없다. 브루트포스로 접근해야한다.","fields":{"slug":"/algorithm/baekjoon/ac20927/"},"frontmatter":{"categories":"알고리즘","title":"Degree Bounded Minimum Spanning Tree","date":"April 21, 2021"}},"next":{"fields":{"slug":"/algorithm/programmers/programmers17681/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac18111/"}}},{"node":{"id":"a1e4dc9a-8dfa-5a3d-8cb3-7999f1a9c955","excerpt":"프로그래머스 입력받은 숫자를 2진수로 변환하여 비교하는 문제다. 이진수 문장길이가 같지 않을 수 있으므로 거꾸로 받아서 비교하여 다시 역순으로 배출한다.","fields":{"slug":"/algorithm/programmers/programmers17681/"},"frontmatter":{"categories":"알고리즘","title":"비밀지도","date":"April 20, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac2745/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac20927/"}}},{"node":{"id":"039108d8-928c-5ef1-bae6-3df2d890c622","excerpt":"백준 입력받은 문자를 하나씩 떼어서 각 자리의 진법 배수 만큼 곱하여 더해준다. 숫자 범위에 걸릴까봐 Math.pow 대신 pow를 구현해서 썼다.","fields":{"slug":"/algorithm/baekjoon/ac2745/"},"frontmatter":{"categories":"알고리즘","title":"진법변환","date":"April 19, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac5692/"}},"previous":{"fields":{"slug":"/algorithm/programmers/programmers17681/"}}},{"node":{"id":"a8a52f4a-0bd8-53f2-a757-93cdfe766dea","excerpt":"백준 10진법이 123이 110^2+ 210^1 + 3*10^3이 듯 한 글자씩 떼서 각 팩토리얼 자리 값을 곱해서 더해준다.","fields":{"slug":"/algorithm/baekjoon/ac5692/"},"frontmatter":{"categories":"알고리즘","title":"팩토리얼 진법","date":"April 16, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac6603/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac2745/"}}},{"node":{"id":"a241aceb-bf0e-5f69-8893-94bf4ff4eb1a","excerpt":"백준 Queue에 숫자를 하나씩 넣고 다음 숫자들을 하나씩 끼워서 입력받은 길이 만큼 만들어보는 문제다. 받은 숫자 다음 꺼낸 숫자가 받은 숫자보다 커야 그 다음 숫자를 끼워본다. 재귀로 돌면서 끼워서 6개가 되면 출력한다.","fields":{"slug":"/algorithm/baekjoon/ac6603/"},"frontmatter":{"categories":"알고리즘","title":"로또","date":"April 16, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac4949/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac5692/"}}},{"node":{"id":"316f2de7-4b59-5d8b-aaff-40ebb0e47087","excerpt":"백준 소괄호와 대괄호가 대칭적으로 들어있는가에 대한 문제다. 처음 풀이는 스택에 ([을 넣고 )]이 나올때 스택의 마지막 값과 대칭하는지, 스택이 0보다 작은데 )]이 나오는게 아닌지 조건을 줘서 풀었다. 훨씬 메모리와 속도에서 좋은 풀이가 있길래 따라해봤다. 아스키 코드에서 ’(’ 와 ’)‘는 1차이가 나고 ’[’ 와 ’]‘는 2차이가 난다 근데 결과는 별 차이가 안났다. 결국 참조한 코드는 char[]를 사용했다.","fields":{"slug":"/algorithm/baekjoon/ac4949/"},"frontmatter":{"categories":"알고리즘","title":"균형잡힌 세상","date":"April 15, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac2869/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac6603/"}}},{"node":{"id":"8de82b99-c0b7-5d5d-8647-66cae6874073","excerpt":"백준 아침에 a만큼 올라가고(+) 잘때 b만큼 미끄러지는(-) 상황에 v만큼 올라가는데 얼마나 걸리느냐 묻는 문제다. 올라간 위치가 v인 날이므로 앞으로 가야하는 거리(v)에서 하루동안 움직이는 거리(a-b)를 나눈다. 하지만 v/(a-b)만 계산할 경우 오전 동안 올라갔건 a가 빠져야하므로 v-a를 해준다. 그리고 나눈 값에 나머지가 존재할 경우 나머지 거리도 올라가야 하므로 1을 더해준다(나는 그냥 올림을 했다). 그리고 0일부터 시작했지만 세기는 1일부터 세므로 1을 더해준다.","fields":{"slug":"/algorithm/baekjoon/ac2869/"},"frontmatter":{"categories":"알고리즘","title":"달팽이는 올라가고 싶다","date":"April 14, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac2805/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac4949/"}}},{"node":{"id":"785a769d-3f4d-5380-bea4-6e731b8c7597","excerpt":"백준 최대한 필요한 만큼만 가져가도록 절단기 높이를 가장 높게 잡아줘야한다. 높이의 최소는 0 최대는 나무 중 가장 높은 나무의 높이를 넣는다. 최소 최대의 중간 값으로 잘라주고 자를 때 음수는 합하지 않는다. 그렇게 구해진 높이는 결과에 담고 구해진 높이가 기존 높이보다 낮으면 넣지 않는다.","fields":{"slug":"/algorithm/baekjoon/ac2805/"},"frontmatter":{"categories":"알고리즘","title":"나무 자르기","date":"April 13, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac2775/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac2869/"}}},{"node":{"id":"54a1df36-47dd-55f8-a028-2e0f6f05d9c2","excerpt":"백준 14 입력 범위 끝이니 배열로 미리 만들어두면 편하다. 각층 각호에 아랫층 같은호(ar[i-1][j])와 같은층 앞호(ar[i][j-1])을 합치면 현재 살아야하는 인원수가 나온다. 맨 밑층은 밑이 없으니 1. 0호는 층과 같다.","fields":{"slug":"/algorithm/baekjoon/ac2775/"},"frontmatter":{"categories":"알고리즘","title":"부녀회장이 될테야","date":"April 13, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac2292/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac2805/"}}},{"node":{"id":"4cf6ce6f-7619-5550-91a9-ea15e3eb9a28","excerpt":"백준 가운데 1개에서 7,19,37,61… 증가량이 6,12,18,24… 6의 배수이다","fields":{"slug":"/algorithm/baekjoon/ac2292/"},"frontmatter":{"categories":"알고리즘","title":"벌집","date":"April 12, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac2108/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac2775/"}}},{"node":{"id":"0a74f232-1f0e-5253-b087-021d5d5b6870","excerpt":"백준 구해야하는 값이 4개(산술평균,중앙값,최빈값,범위)이다 산술평균 : 전체합을 갯수로 나눔 중앙값 : 주어진 값들을 정렬하여 가운데 위치하는 값, 카운트를 n/2번 한다. 최빈값 : 입력할때 최대 카운트를 찾고 그 값과 같은 값을 2번 이하로 찾는다. 범위 : 최댓값에서 최솟값을 뺀다.","fields":{"slug":"/algorithm/baekjoon/ac2108/"},"frontmatter":{"categories":"알고리즘","title":"통계학","date":"April 11, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac1978/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac2292/"}}},{"node":{"id":"576c2a1d-8350-54b5-98dd-b450991fcf95","excerpt":"백준 1과 자기 자신 외에 나눠지지 않는 소수를 찾는 문제이다. 처음 생각한 코드는 2부터 주어진 수의 제곱근까지 반복시켜 소수를 판별했다. 하지만 걸린 시간과 메로리가 더 짧은 방법이 있었다. 최대 1000까지 입력이므로 불린형 배열에 true false로 소수 판별을 미리 만들어 놓고 인덱스로 찾아가서 true면 출력.","fields":{"slug":"/algorithm/baekjoon/ac1978/"},"frontmatter":{"categories":"알고리즘","title":"소수 찾기","date":"April 10, 2021"}},"next":{"fields":{"slug":"/algorithm/programmers/programmers43165/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac2108/"}}},{"node":{"id":"8c2d424a-787f-5bc2-a9fb-e309e8d9eb52","excerpt":"프로그래머스 깊이 우선 탐색을 이용하여 파고 내려가면서 결과를 도출하게 만든다. 첫번째 값부터 +,- 로 갈라져 내려가게 만든다. 덧셈이 먼저 나오고 그 다음 +,-로 가른 다음 다시 +으로 인덱스만큼 반복. 반복이 끝날때 목표값과 같은지 확인.","fields":{"slug":"/algorithm/programmers/programmers43165/"},"frontmatter":{"categories":"알고리즘","title":"타겟 넘버","date":"April 09, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac2606/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac1978/"}}},{"node":{"id":"ec8abc70-a38e-5e57-b1a5-d62858e54d58","excerpt":"백준 탐색을 해서 풀어보라고 그림으로 그려져있다. 이어지는 노드를 카운트 하는 문제 같아서 DFS로 풀었다. DFS에 대한 자세한 설명은 이 블로그 글을 추천한다. count가 -1인 이유는 본인은 제외해야한다.","fields":{"slug":"/algorithm/baekjoon/ac2606/"},"frontmatter":{"categories":"알고리즘","title":"바이러스","date":"April 08, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac1260/"}},"previous":{"fields":{"slug":"/algorithm/programmers/programmers43165/"}}},{"node":{"id":"1175eaef-9fb5-5402-894c-edc89abe050b","excerpt":"백준 깊이 우선 탐색(DFS)과 너비 우선 탐색(BFS)을 구현하는 문제이다. 깊이 우선 탐색은 연결된 노드가 없을때까지 내려가면서 탐색, 너비 우선 탐색은 직접 연결된 노드들을 다 훑고 내려가는 탐색 방식이다. 자세한 설명은 이 블로그 글을 추천한다.","fields":{"slug":"/algorithm/baekjoon/ac1260/"},"frontmatter":{"categories":"알고리즘","title":"DFS와 BFS","date":"April 08, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac1874/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac2606/"}}},{"node":{"id":"f2f53ae7-608d-5c93-9039-10b5d5f2a6bf","excerpt":"백준 1부터 N까지 수열이 쌓여 있고 거기서 하나씩 넣고 꺼내는 방식이다. 예제에 따라 1부터 8까지 있다고 할때 처음 모양은 이러하다. input stack 1  2  3  4  5  6  7  8  처음 꺼내야하는 값이 4이므로 1부터 4까지를 stack에 넣고 +를 출력해줄때 상황 input stack         5 4 6 3 7 2 8 1 그리고 4를 출력에 넣고 -를 출력한다. input stack         5  6 3 7 2 8 1 그 다음 스택의 맨위의 값이 요구는 숫자 3과 같으므로 꺼낸다. input stack         5  6  7 2 8 1 다음 숫자는 6이니 6까지 숫자를 넣어준다. input stack        6  5  3 7 2 8 1 stack의 맨 위가 6이 되었으므로 출력 input stack          5  3 7 2 8 1 위와 같은 동작을 반복한다. 만약 목표값이 현재 수열의 맨 위의 값보다 작은데 같지 않은 경우는 접근…","fields":{"slug":"/algorithm/baekjoon/ac1874/"},"frontmatter":{"categories":"알고리즘","title":"스택 수열","date":"April 08, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac1157/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac1260/"}}},{"node":{"id":"2ee70cad-ba22-59a0-97d4-a2e3eb94d685","excerpt":"백준 첫번째 생각으로 HashMap에 넣고 Value로 정렬하기를 해보았다 코드가 너무 길긴하지만 범위를 정하기 어려울때는 쓰기 좋을것 같다. 문제의 정석처럼 풀어지는 코드는 A~Z를 아스키코드 int형으로 배열을 맞춰서 카운트 해주는 방법","fields":{"slug":"/algorithm/baekjoon/ac1157/"},"frontmatter":{"categories":"알고리즘","title":"단어공부","date":"April 07, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac1654/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac1874/"}}},{"node":{"id":"ff3d65a4-771b-5751-b04b-01484845e977","excerpt":"백준 랜선을 얼마나 자를 수 있는가에 대해 묻는 문제이다. 랜선길이를 보아하니 long 써야한다. 그냥 탐색을 돌리면 시간초과에 걸리니 이분 탐색을 사용한다. 이분 탐색에 대한 설명은 이 블로그 글을 추천한다. 이분 탐색에 대한 설명에 맞춰 코드를 짠다.","fields":{"slug":"/algorithm/baekjoon/ac1654/"},"frontmatter":{"categories":"알고리즘","title":"랜선자르기","date":"April 05, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac1436/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac1157/"}}},{"node":{"id":"57cf56a1-3aa7-5147-9334-300b2f4265bc","excerpt":"백준 666이 들어가는 숫자로 제목을 만드는것이다. 1666,2666,3666…16661,… 숫자를 늘려서 문자열로 바꿔 666이 들어가는지 확인하여 몇번째인지 카운트한다.","fields":{"slug":"/algorithm/baekjoon/ac1436/"},"frontmatter":{"categories":"알고리즘","title":"영화감독 숌","date":"April 04, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac10816/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac1654/"}}},{"node":{"id":"1904ef3c-32d4-5d16-b48c-7f55d7f7bef9","excerpt":"백준 숫자 카드가 몇번 나왔는가 카운트 해주면 된다. Map에 카드 숫자를 키로, 나온 횟수를 값으로 넣어줬다.","fields":{"slug":"/algorithm/baekjoon/ac10816/"},"frontmatter":{"categories":"알고리즘","title":"숫자카드 2","date":"April 02, 2021"}},"next":{"fields":{"slug":"/algorithm/programmers/programmers42839/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac1436/"}}},{"node":{"id":"92c759ec-a87a-5711-9ae4-0fbd4099d94e","excerpt":"프로그래머스 입력받은 문자열을 문자하나씩 조개서 배열에 넣는다. 작성한 순열 생성 함수에서 한칸씩 진행한다. 문자 하나를 결과물에 넣고 순열 생성을 한글자 빼고 다시 문자배열에 넣기. 순열 생성 함수는 붙여야할 글자가 없을때까지 문자열을 붙여서 만든다. 단 0으로 시작하는건 제외. 문자열을 숫자로 만들어서 검사용 Set에 있는지 확인한다. 없다면 소수인지 확인하여 맞을 경우 count ++.","fields":{"slug":"/algorithm/programmers/programmers42839/"},"frontmatter":{"categories":"알고리즘","title":"소수찾기","date":"April 01, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac1697/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac10816/"}}},{"node":{"id":"b4ba0451-23cc-5f44-903c-8f8c710b5743","excerpt":"백준 수빈의 위치(N)에서 동생의 위치(K)로 가기 위해 몇 번 걸리는가 묻고 있다. 방문 기록을 세우고 거기에 카운트를 쓴다. 큐에 순서를 넣고 맨 앞을 꺼내면서 체크한다.","fields":{"slug":"/algorithm/baekjoon/ac1697/"},"frontmatter":{"categories":"알고리즘","title":"술래잡기","date":"March 31, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac11866/"}},"previous":{"fields":{"slug":"/algorithm/programmers/programmers42839/"}}},{"node":{"id":"61211f92-1fa0-580a-9829-74196d8d9aba","excerpt":"백준 1부터 N까지 수열을 놓고 K번째 숫자를 하나씩 빼서 출력해줘야 한다. 스택에 숫자를 넣어놓고 인덱스를 K씩 더해줘서 빼낼거다. 시작 인덱스는 K가 N보다 크지 않으니 K를 넣되 인덱스는 0부터 니까 1을 뺀다. 그 다음 스택의 길이보다 크거나 같으면 스택의 인덱스보다 커지므로 나머지를 이용하여 빼준다. 반복","fields":{"slug":"/algorithm/baekjoon/ac11866/"},"frontmatter":{"categories":"알고리즘","title":"요세푸스 문제0","date":"March 26, 2021"}},"next":{"fields":{"slug":"/algorithm/programmers/programmers42583/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac1697/"}}},{"node":{"id":"46318269-b7b3-5209-8004-49d47a27baa0","excerpt":"프로그래머스 대기중인 트럭에서 한대씩 꺼낸다. 다리의 현재하중(bridge_weight)를 체크하여 견딜 수 있을 경우 트럭을 올린다(bridge_weight+트럭무게,큐에 트럭삽입). 견디지 못할 경우 큐에 0을 집어 넣는다. 걸리는 시간에 올라가는 시간을 무게한도 만큼 1씩 더해주고 마지막 트럭이 나가는 다리의 길이 만큼의 시간을 더해준다.","fields":{"slug":"/algorithm/programmers/programmers42583/"},"frontmatter":{"categories":"알고리즘","title":"다리를 지나는 트럭","date":"March 25, 2021"}},"next":{"fields":{"slug":"/algorithm/programmers/programmers42840/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac11866/"}}},{"node":{"id":"1d98a27e-8f18-5a94-b106-ce9c71af9a2e","excerpt":"프로그래머스 수포자 셋의 패턴을 배열로 바꾼다. 맞은 갯수를 배열에 저장하고 제일 큰 값을 표시한다. 가변 배열을 위해 ArrayList를 써서 제일 큰 값과 같은 수포자를 넣고 배열을 반환한다.","fields":{"slug":"/algorithm/programmers/programmers42840/"},"frontmatter":{"categories":"알고리즘","title":"모의고사","date":"March 25, 2021"}},"next":{"fields":{"slug":"/algorithm/programmers/programmers42586/"}},"previous":{"fields":{"slug":"/algorithm/programmers/programmers42583/"}}},{"node":{"id":"4313cca8-9a2d-5978-92b5-8c3036cdc969","excerpt":"프로그래머스 기능별로 필요한 기간을 배열로 만들어줍니다. 기능별로 비교하는데 앞의 기간이 뒤의 기간보다 클경우 계속 한번에 배포해야하는 양이 커지므로 complete라는 변수를 키웁니다. 그렇게 키운 complete가 뒤의 기간이 더 클 경우 break문으로 나와서 배열에 넣어줍니다.","fields":{"slug":"/algorithm/programmers/programmers42586/"},"frontmatter":{"categories":"알고리즘","title":"기능개발","date":"March 24, 2021"}},"next":{"fields":{"slug":"/algorithm/programmers/programmers42584/"}},"previous":{"fields":{"slug":"/algorithm/programmers/programmers42840/"}}},{"node":{"id":"4ff05077-e6f1-5dd6-8a0c-a43cc7b5526a","excerpt":"프로그래머스 시간별로 하나씩 꺼낸다. 시간이 흐를때 꺼낸 값보다 더 작은 값일 경우 answer 배열의 값을 1씩 늘려준다. 더 큰값이 나올 경우 break;","fields":{"slug":"/algorithm/programmers/programmers42584/"},"frontmatter":{"categories":"알고리즘","title":"주식가격","date":"March 24, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac10250/"}},"previous":{"fields":{"slug":"/algorithm/programmers/programmers42586/"}}},{"node":{"id":"423fe36d-26f5-597a-90c5-dbd69f8b9675","excerpt":"백준 호텔을 높이로 잘라서 반복하면 끝","fields":{"slug":"/algorithm/baekjoon/ac10250/"},"frontmatter":{"categories":"알고리즘","title":"ACM 호텔","date":"March 18, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac1197/"}},"previous":{"fields":{"slug":"/algorithm/programmers/programmers42584/"}}},{"node":{"id":"3ae31620-208b-507f-9429-5a664180cdc2","excerpt":"백준 ‘최소 스패닝 트리’에 대한 설명이 적혀있는데 잘 모르겠다. 검색해보니 크루스칼 알고리즘을 쓰라는데 그렇다면 크루스칼 알고리즘은 또 무엇인가?\r\n 위와 같은 노드와 노드를 잇는 가중치가 주어질때 최소값으로 정렬 후 ‘순환하지 않게’ 모두 이어준다. 가중치 정렬표 B-C A-B D-E B-D C-E A-D A-E C-D 1 3 3 4 4 5 7 8 이제 저기서 최소값부터 하나씩 이어준다.\r\n\r\n이렇게 잇기 시작해서\r\n\r\n하나씩 연결해주는데 저렇게 모든 점들이 연결되고 C-E도 4이긴 하지만 연결시 순환되므로 생략한다.\r\nhttps://yabmoons.tistory.com/186를 참조했습니다. 일단 답은 맞췄는데 메모리가 범람했다. 메모리계의 을지문덕이 되었다.\r\n 커스텀 클래스로 만들어서 Comparable를 받아서 만들어주니 메모리가 많이 줄었다. 정렬을 커스텀으로 하는게 메모리를 많이 먹나보다.","fields":{"slug":"/algorithm/baekjoon/ac1197/"},"frontmatter":{"categories":"알고리즘","title":"최소 스패닝 트리","date":"March 09, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac1013/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac10250/"}}},{"node":{"id":"1cf008a2-9589-5db4-813a-2d060d5bee37","excerpt":"백준 “무한히 넓은 저 우주에 인류만이 홀로 존재한다면, 그건 정말 슬픈 일이 아닐까요” 이걸 풀고 난 후에 나는 혼자 있고 싶어졌다. 문제에서 표기법의 규칙에 대해 설명해준 뒤 (100+1+ | 01)+ 에 맞는 지 확인하여 YES와 NO를 출력하라고 했다 정규식을 쓰면 손쉽다. 그렇다 처음엔 생각 못해서 안쉬웠다.","fields":{"slug":"/algorithm/baekjoon/ac1013/"},"frontmatter":{"categories":"알고리즘","title":"Contact","date":"March 05, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac1149/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac1197/"}}},{"node":{"id":"71dcdd89-3d1c-5911-8747-73c91a07fe65","excerpt":"백준 i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다. 이 문장을 읽으면 순간 복잡하게 생각이 들었지만 따지고 보면 그냥 앞집의 색과 다르면 그만이다 도색에 드는 비용이 들어있는 배열(ar) | 여태까지 겹치지 않고 최소값으로 도배를 해온 비용으로 나누어 배열(dp)을 만들어 채운다. 최소도색비용 배열(dp)을 채울때 위에서 색을 정하고(dp[i-1][0]) 이전 줄(dp[i-1])의 겹치지 않는 색의 최소도배비용을 비교하여 더 작은값(dp[i-1][1] < dp[i-1][2]?)과 현재 집에 선택한 색의 도색비용을 더해준다(+ar[i][0]).","fields":{"slug":"/algorithm/baekjoon/ac1149/"},"frontmatter":{"categories":"알고리즘","title":"RGB거리","date":"March 05, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac1008/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac1013/"}}},{"node":{"id":"aabb72cd-ac12-55f3-bd26-91bf43431984","excerpt":"백준 가로 m 세로 n의 배추밭에 배추를 심고 배추 보호를 위해 순찰도는 배추흰지렁이를 밭에 풀려고 한다. 비용절감을 위해 필요한 만큼만 풀어야 한다. 배추흰지렁이는 인접한 배추들로 이동할 수 있으므로 지렁이가 배추가 보이면 한마리 놓고 붙어있는 배추들을 지도에서 지워주자 인접했다는 말은 배추의 위치를 2차원 좌표로 (x,y) 라고 할때     (x,y+1)  (x-1,y) (x,y) (x+1)  (x,y-1)  재귀를 이용해서 근처를 전부 탐색하고 지도 밖으로 나가거나 배추가 없을 경우 멈추는 함수를 만든다.","fields":{"slug":"/algorithm/baekjoon/ac1008/"},"frontmatter":{"categories":"알고리즘","title":"유기농 배추","date":"March 02, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac1003/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac1149/"}}},{"node":{"id":"19acdecb-5ff8-589f-b52f-02b3e75825c2","excerpt":"백준 피보나치 함수에서 0과 1이 몇번 출력 되는지 묻는다. 0과 1이 몇번 나오는 지 세보자 n 0이 나오는 횟수 1이 나오는 횟수 0 1 0 1 0 1 2 1 1 3 1 2 4 2 3 5 3 5 6 5 8 7 8 13 8 13 21 9 21 34 0이 나오는 횟수는 n이 1부터, 1이 나오는 횟수 n이 0부터 수열이 시작된다. 다행히 문제가 n이 40까지로 제한되어 있다. 0일 경우를 예외처리하고 그 다음부터는 수열 값을 출력해주면 된다.","fields":{"slug":"/algorithm/baekjoon/ac1003/"},"frontmatter":{"categories":"알고리즘","title":"피보나치 수열","date":"March 01, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac11650/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac1008/"}}},{"node":{"id":"e91dc0ff-bc76-5a60-a37c-d554b048d8e5","excerpt":"백준 간단한 정렬문제다. Array.stream에서 comparing을 쓰는 것보다 클래스를 만들어서 Comparable을 쓰는게 빠르다.","fields":{"slug":"/algorithm/baekjoon/ac11650/"},"frontmatter":{"categories":"알고리즘","title":"좌표 정렬하기","date":"February 26, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac15649/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac1003/"}}},{"node":{"id":"7229a510-6dd0-51c8-b22d-b5758f33ebef","excerpt":"백준 자연수 수열을 만드는 문제다. 갯수의 카운트를 올라가며 만들어놓은 배열에 넣으면서 방문목록을 체크한다.","fields":{"slug":"/algorithm/baekjoon/ac15649/"},"frontmatter":{"categories":"알고리즘","title":"N과 M(1)","date":"February 26, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac1002/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac11650/"}}},{"node":{"id":"c427de9f-322c-5afe-a96d-b2924326701e","excerpt":"백준 백승환과 조규현에게 류재명과의 거리를 구해 류재명이 있을 수 있는 위치를 구하는 좌표를 구하라고 한다. 백승환과 조규현의 위치는 좌표점으로 제공된다. 두 점에서 목표까지의 거리가 나와 있고 두 점간의 거리를 구해서 가장 큰 값과 세 거리의 합(sum)에서 가장 큰 값(max)을 뺀 값을 구한다. 원의 방정식을 사용할것이다. 백승환과 류재명의 거리 r1 , 조규현과 류재명의 거리 r2 , 백승환과 조규현의 거리 r3 라고 할때 조건을 따라가보자 r1과 r2가 같고 r3가 0이다 => r1과r2가 같은 위치 => 원이 완벽하게 겹쳐서 무수하게 많은 수 => -1 r1 + r2 == r3 => r1로 그린 원과 r2로 그린 원의 중점의 거리가 r3일때 두 원은 한점에서 만나게 된다 => 1\r\n r1+r2+r3-max = max => r3로 그린 원과 r1 또는 r2로 그린 원 하나가 내접 => 1\r\n max>sum => 두 원의 지름보다 합의 거리가 더 기므로 원이 만나지 않음 =…","fields":{"slug":"/algorithm/baekjoon/ac1002/"},"frontmatter":{"categories":"알고리즘","title":"터렛","date":"February 24, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac1018/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac15649/"}}},{"node":{"id":"164f5526-6368-5700-b264-3a25d69683f3","excerpt":"백준 M _ N 크기의 보드에서 8 _ 8의 체스판을 만드는 문제이다. 자칫하면 처음칸의 색에서 고정으로 생각하기 쉬우나 무슨 색으로 칠하건 횟수가 적은 경우의 수를 출력하는 것이다.\r\n그래서 첫칸이 W일 경우의 수와 B일 경우의 수로 나누어 카운트를 해준다. 카운트 할 경우 첫칸(0,0)이 W일 경우 -> 행렬 숫자의 합이 짝수&& B , 행렬 숫자의 합이 홀수 && W 이면 카운트1 ++ 첫칸(0,0)이 B일 경우 -> 행렬 숫자의 합이 짝수&& W , 행렬 숫자의 합이 홀수 && B 이면 카운트2 ++","fields":{"slug":"/algorithm/baekjoon/ac1018/"},"frontmatter":{"categories":"알고리즘","title":"체스판 다시 칠하기","date":"February 21, 2021"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac1158/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac1002/"}}},{"node":{"id":"b649d21c-479b-53de-9ae8-a7f14866c540","excerpt":"백준 prev와 next란 배열을 서로 인덱스로 교차하며 배열을 출력한다. n이 7이고 m이 3일 경우 처음 모양은 이러하다.  0 1 2 3 4 5 6 7 prev -1 0 1 2 3 4 5 6 next 1 2 3 4 5 6 7 8 prev의 1번째에는 n을 넣고 next의 n번째에는 1을 넣는다.  0 1 2 3 4 5 6 7 prev -1 7 1 2 3 4 5 6 next 1 2 3 4 5 6 7 1 i에 next[i]를 넣으면서 탐색을 나가는데 0부터 시작하여 m번 반복한다.\r\ni = (next[0] => next[1] => next[2]) =>3\r\ni = 3 i 값을 출력해주고 next에 이전 값이 담긴 자리에 다음 위치의 값을 넣는다.\r\nnext[prev[i]] = next[i];\r\nnext[prev[3]] = next[3];\r\nnext[2] = next[3];  0 1 2 3 4 5 6 7 prev -1 7 1 2 3 4 5 6 next 1 2 4 4 5 6 7 1 그…","fields":{"slug":"/algorithm/baekjoon/ac1158/"},"frontmatter":{"categories":"알고리즘","title":"요세푸스 문제","date":"May 31, 2019"}},"next":{"fields":{"slug":"/algorithm/baekjoon/ac9095/"}},"previous":{"fields":{"slug":"/algorithm/baekjoon/ac1018/"}}},{"node":{"id":"b3df46d1-ccd8-5669-93be-f4b57689c3fc","excerpt":"백준 T개 주어지는 정수 n에 대해 1,2,3의 합으로 표현하는 방법의 갯수를 세는 문제이다 경우는 앞의 숫자를 고정하고 나머지 값을 가변시켜보는 방식으로 카운트하게 만들면 된다. 정수 n 표현 방법 가지 수 1 1 1 2 2, 1+1 2 3 3, 2+1, 1+2, 1+1+1 4 4 3+1, 2+2, 2+1+1, 1+3, 1+2+1, 1+1+2, 1+1+1+1 7 5 3+2, 3+1+1, 1+3+1, 1+1+3, 2+3, 2+2+1, 2+1+2, 1+2+2, 2+1+1+1, 1+2+1+1, 1+1+2+1, 1+1+1+2, 1+1+1+1+1 13 1,2,3의 경우는 각자 값을 가지고 이상의 n은 n-1,n-2,n-3의 합과 같다.","fields":{"slug":"/algorithm/baekjoon/ac9095/"},"frontmatter":{"categories":"알고리즘","title":"1,2,3 더하기","date":"May 11, 2019"}},"next":null,"previous":{"fields":{"slug":"/algorithm/baekjoon/ac1158/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}